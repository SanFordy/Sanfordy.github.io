<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <link rel="apple-touch-icon" href="touch-icon-mac.png">
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  
  
  
  

  
    
    
  

  

  

  
    
      
    

    
  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|comic sans:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  




<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="SanFordy`s Magic" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="由于移动设备的内存极其有限，所以每个app所占的内存也是有限制的，当app所占用的内存较多时，系统就会发出内存警告，这时需要回收一些不需要再继续使用的内存空间，比如回收一些不再使用的对象和变量等。">
<meta property="og:type" content="article">
<meta property="og:title" content="【06】内存管理">
<meta property="og:url" content="http://sanfordy.com/2016/08/25/〖A〗【2-0】OC-语法/【06】内存管理/index.html">
<meta property="og:site_name" content="SanFordy`s Magic">
<meta property="og:description" content="由于移动设备的内存极其有限，所以每个app所占的内存也是有限制的，当app所占用的内存较多时，系统就会发出内存警告，这时需要回收一些不需要再继续使用的内存空间，比如回收一些不再使用的对象和变量等。">
<meta property="og:image" content="http://images2015.cnblogs.com/blog/776348/201608/776348-20160829114938558-306622190.png">
<meta property="og:image" content="http://images2015.cnblogs.com/blog/776348/201608/776348-20160829115217777-1123017812.png">
<meta property="og:image" content="http://images2015.cnblogs.com/blog/776348/201608/776348-20160829115223668-286487842.png">
<meta property="og:image" content="http://images2015.cnblogs.com/blog/776348/201608/776348-20160829115246449-2140660921.png">
<meta property="og:image" content="http://images2015.cnblogs.com/blog/776348/201608/776348-20160829225656824-1310872121.png">
<meta property="og:image" content="http://images2015.cnblogs.com/blog/776348/201608/776348-20160829225708668-1476578082.png">
<meta property="og:image" content="http://images2015.cnblogs.com/blog/776348/201608/776348-20160829225720980-611397820.png">
<meta property="og:image" content="http://images2015.cnblogs.com/blog/776348/201608/776348-20160829225726980-1147773046.png">
<meta property="og:image" content="http://images2015.cnblogs.com/blog/776348/201608/776348-20160829225732621-647918422.png">
<meta property="og:image" content="http://images2015.cnblogs.com/blog/776348/201608/776348-20160829225738090-382980942.png">
<meta property="og:image" content="http://images2015.cnblogs.com/blog/776348/201608/776348-20160829225743199-540920695.png">
<meta property="og:updated_time" content="2016-08-29T15:46:44.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="【06】内存管理">
<meta name="twitter:description" content="由于移动设备的内存极其有限，所以每个app所占的内存也是有限制的，当app所占用的内存较多时，系统就会发出内存警告，这时需要回收一些不需要再继续使用的内存空间，比如回收一些不再使用的对象和变量等。">
<meta name="twitter:image" content="http://images2015.cnblogs.com/blog/776348/201608/776348-20160829114938558-306622190.png">


<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: undefined,
      author: '博主'
    }
  };
</script>



  <title> 【06】内存管理 | SanFordy`s Magic </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">SanFordy`s Magic</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">　　　　　　</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-th fa-fw"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-user fa-fw"></i> <br />
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="#" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>


    </div>
  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                【06】内存管理
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-25T17:03:26+08:00" content="2016-08-25">
              2016-08-25
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/〖A〗【2-0】OC-语法/" itemprop="url" rel="index">
                    <span itemprop="name">〖A〗【2-0】OC-语法</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/08/25/〖A〗【2-0】OC-语法/【06】内存管理/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/08/25/〖A〗【2-0】OC-语法/【06】内存管理/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
              &nbsp; | &nbsp;
              <span class="page-pv">
              <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>次数阅读
              </span>
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote>
<p>由于移动设备的内存极其有限，所以每个app所占的内存也是有限制的，当app所占用的内存较多时，系统就会发出内存警告，这时需要回收一些不需要再继续使用的内存空间，比如回收一些不再使用的对象和变量等。</p>
</blockquote>
<a id="more"></a>
<h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><h3 id="为什么要进行内存管理"><a href="#为什么要进行内存管理" class="headerlink" title="为什么要进行内存管理"></a>为什么要进行内存管理</h3><p>由于移动设备的内存极其有限，所以每个app所占的内存也是有限制的，当app所占用的内存较多时，系统就会发出内存警告，这时需要回收一些不需要再继续使用的内存空间，比如回收一些不再使用的对象和变量等。</p>
<p>当代码块结束时这个代码块中涉及的所有局部变量会被回收，指向对象的指针也被回收，此时对象已经没有指针指向，但依然存在于堆内存中并占用大量内存，造成内存泄露。</p>
<h3 id="常见内存问题"><a href="#常见内存问题" class="headerlink" title="常见内存问题"></a>常见内存问题</h3><p>内存问题主要体现在三个方面：内存泄露、内存溢出、野指针异常。</p>
<ol>
<li>内存泄露：其实说白了就是该内存空间使用完毕之后未回收导致内存越用越少。</li>
<li>内存溢出：应用程序所占的内存大小超过了系统给定的内存上限称为内存溢出。iOS给每个应用程序提供了一定的内存，用于程序的运行，比如Phone 5S 提供80M左右。一旦超出内存上限，程序就会Crash。 </li>
<li>野指针异常：对象内存空间已经被系统回收，仍然使用指针操作这块内存。野指针异常是程序crash的主要原因。</li>
</ol>
<h3 id="内存管理的范围"><a href="#内存管理的范围" class="headerlink" title="内存管理的范围"></a>内存管理的范围</h3><p>内存管理对任何继承NSObject的对象有效，对基本数据类型无效。本质原因是因为对象和基本数据类型在系统中的存储空间不一样。在CO中对象的本质就是栈中的指针指向堆中的内存，而对象存储的内容就在堆中的内存中，所以可以这么说：对象是存储在堆中的，系统并不会自动释放堆中的内存而是有我们自己管理堆内存。基本数据类型不是存在于栈（局部变量）就是存在于静态存储区（全局或static修饰的局部变量），而这两个内存区都由系统管理，我们无需做更多地操作。</p>
<h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><p>C语言中，使用malloc和free，进行堆内存的创建和释放。堆内存只有正在使⽤和销毁两种状态。实际开发中可能会遇到两个以上的指针使用同一块内存，C语言无法记录内存使用者的个数。 </p>
<p>OC采用引用计数机制管理内存，当一个新的引用（指针）指向对象（对象所占的内存）时，引用计数器就递增，当去掉一个引用（指针）时，引用计数就递减。当引用计数到零时，该对象所在占的内存就会被释放。</p>
<p>一个比较形象的比喻，假设我们有一条狗和几个用绳子牵着这条狗的人，那么不到最后一个人松掉手中的绳子，这只狗是不能获得自由的。而持有计数的作用就是记录了到底有多少个人牵着绳子。 </p>
<h3 id="对象的基本结构"><a href="#对象的基本结构" class="headerlink" title="对象的基本结构"></a>对象的基本结构</h3><p>每个OC对象都有自己的引用计数器，是一个整数表示对象当前被引用的个数，即现在有多少东西在使用这个对象。对象刚被创建时，默认计数器值为1，当计数器的值变为0时，则对象销毁。</p>
<p>在每个OC对象内部，都专门有4个字节的存储空间来存储引用计数器。</p>
<blockquote>
<p><strong>注意</strong>：判断对象要不要销毁的唯一依据就是计数器是否为0，若为0则对象销毁，否则不销毁。</p>
</blockquote>
<h3 id="对象的销毁"><a href="#对象的销毁" class="headerlink" title="对象的销毁"></a>对象的销毁</h3><p>当一个对象的引用计数器为0时，那么它将被销毁，其占用的内存被系统回收。</p>
<p>当对象被销毁时，系统会自动向对象发送一条dealloc消息，一般会重写dealloc方法，在这里释放相关的资源，dealloc就像是对象的“临终遗言”。一旦重写了dealloc方法就必须调用[super dealloc]，并且放在代码块的最后调用（不能直接调用dealloc方法）。</p>
<p>一旦对象被回收了，那么他所占据的存储空间就不再可用，坚持使用会导致程序崩溃（野指针错误）。</p>
<h2 id="内存管理原则（MRC）"><a href="#内存管理原则（MRC）" class="headerlink" title="内存管理原则（MRC）"></a>内存管理原则（MRC）</h2><ol>
<li>如果你通过alloc，new，copy来创建了一个对象或给对象发送了retain消息，那么你就必须调用release或者autorelease方法。</li>
<li>当要你想使用这个对象时，那么就应该手动通过retain让这个对象的引用计数器+1。</li>
<li>当你不想使用这个对象时，那么就应该手动通过release让这个对象的引用计数器-1。</li>
<li>引用计数的增加和减少应该相等，有加就应该有减。曾经让某个对象计数器加1，就应该让其在最后-1，当引用计数降为0之后，调用对象的dealloc方法进行回收，我们不应该再使用这块内存空间。</li>
<li>判断对象会不会被回收的唯一依据就是引用计数是否为0。</li>
</ol>
<h2 id="内存管理的操作（MRC）"><a href="#内存管理的操作（MRC）" class="headerlink" title="内存管理的操作（MRC）"></a>内存管理的操作（MRC）</h2><h3 id="alloc"><a href="#alloc" class="headerlink" title="+alloc"></a>+alloc</h3><p>开辟内存空间，让被开辟的内存空间的引⽤计数变为1，这是由0到1的过程。 </p>
<h3 id="retain"><a href="#retain" class="headerlink" title="-retain"></a>-retain</h3><p>引用计数加1，如果内存空间之前引用计数为1，ratain之 后变为2，该方法返回对象本身。</p>
<h3 id="copy"><a href="#copy" class="headerlink" title="-copy"></a>-copy</h3><p>使用copy功能的前提：需要遵守NSCopying协议（系统类大部分都遵守了），实现copyWithZone：方法（系统类大部分都实现了）。</p>
<p>copy的结果是返回一个<code>不可变</code>对象。</p>
<p>copy对系统类的可变对象是深拷贝（即把内容拷贝至新内存并返回新内存地址）：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//  可变字符串</span></span><br><span class="line">    <span class="built_in">NSMutableString</span> *mString = [<span class="built_in">NSMutableString</span> stringWithString:<span class="string">@"可变字符串"</span>];</span><br><span class="line">    [[mString <span class="keyword">copy</span>]appendString:<span class="string">@"1"</span>];<span class="comment">// error：Attempt to mutate immutable object with appendString，原因是[mString copy]是一个不可变字符串，不能用appendString方法改变其值。</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"mString-&gt;%@:%p,[mString copy]-&gt;%@:%p"</span>,mString,mString,[mString <span class="keyword">copy</span>],[mString <span class="keyword">copy</span>]);</span><br><span class="line">    <span class="comment">//  输出：mString-&gt;可变字符串:0x7fba13f14310,[mString copy]-&gt;可变字符串:0x7fba13f0ef80</span></span><br><span class="line">    <span class="comment">//  可以发现，mString和[mString copy]指向的是不同的内存区域，此时是深拷贝。</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  可变数组</span></span><br><span class="line">    <span class="built_in">NSMutableArray</span> *mArray = [<span class="built_in">NSMutableArray</span> arrayWithObjects:<span class="string">@"a"</span>,<span class="string">@"b"</span>,<span class="string">@"c"</span>, <span class="literal">nil</span>];</span><br><span class="line"><span class="comment">//    [[mArray copy] addObject:@"d"];// error:unrecognized selector sent to instance 0x7fc43ad0c7a0'，因为[mArray copy]返回的是一个不可变数组</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"mArray-&gt;%@:%p,[mArray copy]-&gt;%@:%p"</span>,mArray,mArray,[mArray <span class="keyword">copy</span>],[mArray <span class="keyword">copy</span>]);</span><br><span class="line">    <span class="comment">/*输出：mArray-&gt;(</span><br><span class="line">     a,</span><br><span class="line">     b,</span><br><span class="line">     c</span><br><span class="line">     ):0x7fd5cbd030f0,[mArray copy]-&gt;(</span><br><span class="line">     a,</span><br><span class="line">     b,</span><br><span class="line">     c</span><br><span class="line">     ):0x7fd5cbd0f6f0*/</span></span><br><span class="line">    <span class="comment">//  可以发现，mArray和[mArray copy]指向的是不同的内存区域，此时是深拷贝。</span></span><br></pre></td></tr></table></figure>
<p>对系统的不可变对象是浅拷贝（即拷贝指针并返回指针）：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  不可变字符串</span></span><br><span class="line"><span class="built_in">NSString</span> *string = <span class="string">@"不可变字符串"</span>;</span><br><span class="line"><span class="comment">//  copy：拷贝string对象的地址并赋值给stringCopy</span></span><br><span class="line"><span class="built_in">NSString</span> *stringCopy = [string <span class="keyword">copy</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"string-&gt;%@:%p,stringCopy-&gt;%@:%p"</span>,string,string,stringCopy,stringCopy);</span><br><span class="line"><span class="comment">//  输出：string-&gt;origion:0x109533050,stringCopy-&gt;origion:0x109533050</span></span><br><span class="line"><span class="comment">//  可以发现，string和stringCopy指向的是同一块内存区域，此时stringCopy的引用计数和string的一样都为２</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  不可变数组</span></span><br><span class="line"><span class="built_in">NSArray</span> *array = [<span class="built_in">NSArray</span> arrayWithObjects:<span class="string">@"a"</span>,<span class="string">@"b"</span>,<span class="string">@"c"</span>,<span class="literal">nil</span>];</span><br><span class="line"><span class="comment">//  copy：拷贝array对象的地址并赋值给arrayCopy</span></span><br><span class="line"><span class="built_in">NSArray</span> *arrayCopy = [array <span class="keyword">copy</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"array-&gt;%@:%p,arrayCopy-&gt;%@:%p"</span>,array,array,arrayCopy,arrayCopy);</span><br><span class="line"><span class="comment">/*输出：array-&gt;(</span><br><span class="line"> a,</span><br><span class="line"> b,</span><br><span class="line"> c</span><br><span class="line"> ):0x7feaa361afa0,arrayCopy-&gt;(</span><br><span class="line"> a,</span><br><span class="line"> b,</span><br><span class="line"> c</span><br><span class="line"> ):0x7feaa361afa0*/</span></span><br><span class="line"><span class="comment">//  可以发现，array和arrayCopy指向的是同一块内存空间。</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：容器类对象的深拷贝指的是单层深拷贝，即仅仅是拷贝容器这个对象，容器内部的元素仍然是指针拷贝。</p>
</blockquote>
<h3 id="mutableCopy"><a href="#mutableCopy" class="headerlink" title="-mutableCopy"></a>-mutableCopy</h3><p>使用mutableCopy功能的前提：需要遵守NSMutableCopying协议（系统类大部分都遵守了），实现mutableCopyWithZone:方法（系统类大部分都实现了）。</p>
<p>mutableCopy的结果是返回一个<code>可变</code>对象。</p>
<p>mutableCopy对系统的可变对象和不可变对象都是深拷贝（即把内容拷贝至新内存并返回新内存地址）：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  不可变字符串</span></span><br><span class="line"><span class="built_in">NSString</span> *string = <span class="string">@"不可变字符串"</span>;</span><br><span class="line"><span class="comment">//  mutableCopy，返回一个可变字符串</span></span><br><span class="line"><span class="built_in">NSMutableString</span> *mString = [string mutableCopy];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"string-&gt;%@:%p,mString-&gt;%@:%p"</span>,string,string,mString,mString);</span><br><span class="line"><span class="comment">//  输出：string-&gt;不可变字符串:0x101873050,mString-&gt;不可变字符串:0x7f9c83c20d20</span></span><br><span class="line"><span class="comment">//  可以发现，string和mString指向了不同的内存空间</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  可变字符串</span></span><br><span class="line"><span class="built_in">NSMutableString</span> *mString1 = [<span class="built_in">NSMutableString</span> stringWithString:<span class="string">@"可变字符串"</span>];</span><br><span class="line"><span class="built_in">NSMutableString</span> *mString2 = [mString1 mutableCopy];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"mString1-&gt;%@:%p,mString2-&gt;%@:%p"</span>,mString1,mString1,mString2,mString2);</span><br><span class="line"><span class="comment">//  输出：mString1-&gt;可变字符串:0x7fe9a370d540,mString2-&gt;可变字符串:0x7fe9a370c530</span></span><br><span class="line"><span class="comment">//  可以发现：mString1和mString指向了不同的内存空间</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  不可变数组</span></span><br><span class="line"><span class="built_in">NSArray</span> *array = [<span class="built_in">NSArray</span> arrayWithObjects:<span class="string">@"a"</span>,<span class="string">@"b"</span>,<span class="string">@"c"</span>, <span class="literal">nil</span>];</span><br><span class="line"><span class="comment">//  mutableCopy，返回一个可变数组</span></span><br><span class="line"><span class="built_in">NSMutableArray</span> *mArray = [array mutableCopy];</span><br><span class="line">[mArray addObject:<span class="string">@"d"</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"array-&gt;%@:%p,mArray-&gt;%@:%p"</span>,array,array,mArray,mArray);</span><br><span class="line"><span class="comment">/*输出：array-&gt;(</span><br><span class="line"> a,</span><br><span class="line"> b,</span><br><span class="line"> c</span><br><span class="line"> ):0x7fec0bc52f50,mArray-&gt;(</span><br><span class="line"> a,</span><br><span class="line"> b,</span><br><span class="line"> c,</span><br><span class="line"> d</span><br><span class="line"> ):0x7fec0bc52c40*/</span></span><br><span class="line"><span class="comment">//  可以发现，array和mArray指向了不同的内存空间</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  可变数组</span></span><br><span class="line"><span class="built_in">NSMutableArray</span> *mArray1 = [<span class="built_in">NSMutableArray</span> arrayWithObjects:<span class="string">@"a"</span>,<span class="string">@"b"</span>,<span class="string">@"c"</span>, <span class="literal">nil</span>];</span><br><span class="line"><span class="comment">//  mutableCopy，返回一个可变数组</span></span><br><span class="line"><span class="built_in">NSMutableArray</span> *mArray2 = [mArray1 mutableCopy];</span><br><span class="line">[mArray2 addObject:<span class="string">@"d"</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"mArray1-&gt;%@:%p,mArray2-&gt;%@:%p"</span>,mArray1,mArray1,mArray2,mArray2);</span><br><span class="line"><span class="comment">/*输出：mArray1-&gt;(</span><br><span class="line"> a,</span><br><span class="line"> b,</span><br><span class="line"> c</span><br><span class="line"> ):0x7faa23404c10,mArray2-&gt;(</span><br><span class="line"> a,</span><br><span class="line"> b,</span><br><span class="line"> c,</span><br><span class="line"> d</span><br><span class="line"> ):0x7faa23460910*/</span></span><br><span class="line"><span class="comment">//  可以发现，mArray1和mArray2指向了不同的内存空间</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：容器类对象的深拷贝指的是单层深拷贝，即仅仅是拷贝容器这个对象，容器内部的元素仍然是指针拷贝。</p>
</blockquote>
<h3 id="release"><a href="#release" class="headerlink" title="-release"></a>-release</h3><p>引用计数减1，如果内存空间之前引用计数为4，release之后变为3，release之后变为0内存被系统回收。</p>
<h3 id="autorelease"><a href="#autorelease" class="headerlink" title="-autorelease"></a>-autorelease</h3><p>未来的某一时刻引用计数减1。如果内存之前引用计数为4，autorelease之后仍然为4，未来某个时刻会变为3。</p>
<h4 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h4><ol>
<li>会将对象放到一个自动释放池中。</li>
<li>当自动释放池被销毁时，会对池子里的所有对象做一次release。</li>
<li>会返回对象本身。</li>
<li>调用完autorelease方法后，对象的计数器不受影响（销毁时影响）。</li>
</ol>
<h4 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h4><ol>
<li>不需要再关心对象释放的时间。</li>
<li>不需要再关心什么时候调用release。</li>
</ol>
<h4 id="使用注意"><a href="#使用注意" class="headerlink" title="使用注意"></a>使用注意</h4><ol>
<li>占用内存较大的对象，不要随便使用autorelease，应该使用release来精确控制。</li>
<li>占用内存较小的对象使用autorelease，没有太大的影响。</li>
</ol>
<h4 id="自动释放池"><a href="#自动释放池" class="headerlink" title="自动释放池"></a>自动释放池</h4><ol>
<li>在ios程序运行过程中，会创建无数个池子，这些池子都是以栈结构（先进后出）存在的。</li>
<li>当一个对象调用autorelease时，会将这个对象放到位于栈顶的释放池中。</li>
</ol>
<h4 id="自动释放池的创建方式"><a href="#自动释放池的创建方式" class="headerlink" title="自动释放池的创建方式"></a>自动释放池的创建方式</h4><p>ios 5.0以前的创建方式：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">　　　　　　<span class="built_in">NSAutoreleasePool</span> *pool=[[<span class="built_in">NSAutoreleasePool</span> alloc] init];</span><br><span class="line">　　　　　　<span class="comment">//......  //</span></span><br><span class="line">　　　　　　[pool  release];<span class="comment">//[pool drain];用于mac</span></span><br></pre></td></tr></table></figure>
<p>Ios5.0以后的创建方式：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">　　　　　　<span class="keyword">@autoreleasepool</span>&#123;<span class="comment">//开始代表创建自动释放池</span></span><br><span class="line"></span><br><span class="line">　　　　　　·······</span><br><span class="line"></span><br><span class="line">　　　　　　&#125;<span class="comment">//结束代表销毁自动释放池</span></span><br></pre></td></tr></table></figure>
<h4 id="Autorelease注意"><a href="#Autorelease注意" class="headerlink" title="Autorelease注意"></a>Autorelease注意</h4><ol>
<li>系统自带的方法中，如果不包含alloc new copy等，则这些方法返回的对象都是autorelease的，如[NSDate  date]。</li>
<li>开发中经常会写一些类方法来快速创建一个autorelease对象，创建对象时不要直接使用类名，而是使用self。</li>
</ol>
<h4 id="retainCount"><a href="#retainCount" class="headerlink" title="-retainCount"></a>-retainCount</h4><p>获得对象当前的引用计数器值。</p>
<h4 id="dealloc"><a href="#dealloc" class="headerlink" title="-dealloc"></a>-dealloc</h4><p>是继承自父类的方法，当对象引用计数为0的时候，则系统会自动调用这个对象的dealloc方法来销毁这个对象。 </p>
<p>dealloc是NSObject的一个实例方法，与alloc对应，用于回收开辟的内存空间。</p>
<p>dealloc方法的代码规范：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  通常我们在dealloc中释放该类setter方法泄露的成员变量</span></span><br><span class="line">[_name release];</span><br><span class="line"><span class="comment">//  一定要[super dealloc]，而且要放到最后，是因为你所创建的每个类都是从父类，根类继承来的，有很多成员变量也会继承过来，这部分成员变量有时候会在你的程序内使用，它们不会自动释放内存，这需要调用父类的 dealloc方法来释放，然而在此之前你需要先把自己所写类中的成员变量内存先释放掉，否则就会造成你本类中的内存积压，造成泄漏。</span></span><br><span class="line">[<span class="keyword">super</span> dealloc];</span><br></pre></td></tr></table></figure>
<h2 id="内存管理代码示例"><a href="#内存管理代码示例" class="headerlink" title="内存管理代码示例"></a>内存管理代码示例</h2><p>&lt; 代码示例 &gt;</p>
<p><em>Person.h</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">assign</span>) <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>Person.m</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Person.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark 重写dealloc方法，在这个方法中通常进行成员变量释放操作</span></span><br><span class="line">-(<span class="keyword">void</span>)dealloc&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Invoke Person's dealloc method."</span>);</span><br><span class="line">    [<span class="keyword">super</span> dealloc];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>main.m</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Person.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Test1()&#123;</span><br><span class="line">    Person *p=[[Person alloc]init]; <span class="comment">//调用alloc，引用计数器+1</span></span><br><span class="line">    p.name=<span class="string">@"Kenshin"</span>;</span><br><span class="line">    p.age=<span class="number">28</span>;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"retainCount=%lu"</span>,[p retainCount]);</span><br><span class="line">    <span class="comment">//结果：retainCount=1</span></span><br><span class="line">    [p release];</span><br><span class="line">    <span class="comment">//结果：Invoke Person's dealloc method.</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//上面调用过release方法，p指向的对象就会被销毁，但是此时变量p中还存放着Person对象的地址，</span></span><br><span class="line">    <span class="comment">//如果不设置p=nil，则p就是一个野指针，它指向的内存已经不属于这个程序，因此是很危险的</span></span><br><span class="line">    p=<span class="literal">nil</span>;</span><br><span class="line">    <span class="comment">//如果不设置p=nil，此时如果再调用对象release会报错，但是如果此时p已经是空指针了，</span></span><br><span class="line">    <span class="comment">//则在OC中给空指针发送消息是不会报错的</span></span><br><span class="line">    [p release];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Test2()&#123;</span><br><span class="line">    Person *p=[[Person alloc]init];</span><br><span class="line">    p.name=<span class="string">@"Kenshin"</span>;</span><br><span class="line">    p.age=<span class="number">28</span>;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"retainCount=%lu"</span>,[p retainCount]);</span><br><span class="line">    <span class="comment">//结果：retainCount=1</span></span><br><span class="line">    </span><br><span class="line">    [p retain];<span class="comment">//引用计数器+1</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"retainCount=%lu"</span>,[p retainCount]);</span><br><span class="line">    <span class="comment">//结果：retainCount=2</span></span><br><span class="line">    </span><br><span class="line">    [p release];<span class="comment">//调用1次release引用计数器-1</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"retainCount=%lu"</span>,[p retainCount]);</span><br><span class="line">    <span class="comment">//结果：retainCount=1</span></span><br><span class="line">    [p release];</span><br><span class="line">    <span class="comment">//结果：Invoke Person's dealloc method.</span></span><br><span class="line">    p=<span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> Test3()&#123;</span><br><span class="line">    Person *p1 = [[Person alloc] init];</span><br><span class="line">    <span class="comment">//  这时候p2和p1指向了同一块内存空间，这时候就需要我们手动添加retain了，如果我们不手动添加retain，这块内存空间的引用计数还是为1</span></span><br><span class="line">    Person *p2 = p1;<span class="comment">//  其实这种做法是错误的</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%lu,%lu"</span>,[p1 retainCount],[p2 retainCount]);</span><br><span class="line">    <span class="comment">//结果：1,1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这种做法才对，因为我们让p3也指向了p1指向的内存，所以需要我们手动让p1指向内存的引用计数+1</span></span><br><span class="line">    Person *p3 = [p1 retain];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%lu,%lu,"</span>[p1 retainCount],[p3 retainCount]);</span><br><span class="line">    <span class="comment">//结果：2,2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        Test1();</span><br><span class="line">        Test2();</span><br><span class="line">        Test3();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>在上面的代码中我们可以通过dealloc方法来查看是否一个对象已经被回收，如果没有被回收则有可能造成内存泄露。如果一个对象被释放之后，那么最后引用它的变量我们手动设置为nil，否则可能造成野指针错误，而且需要注意在OC中给空对象发送消息是不会引起错误的。</li>
<li>野指针错误形式在Xcode中通常表现为：Thread 1：EXC_BAD_ACCESS(code=EXC_I386_GPFLT)错误。因为你访问了一块已经不属于你的内存。</li>
</ul>
<h2 id="内存的相关概念"><a href="#内存的相关概念" class="headerlink" title="内存的相关概念"></a>内存的相关概念</h2><h3 id="野指针"><a href="#野指针" class="headerlink" title="野指针"></a>野指针</h3><p>野指针指向了一块垃圾内存（已经被回收的，不可用的内存），野指针是非常危险的。</p>
<p>自定义Student类，在main函数中添加下列代码：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Student *stu = [[Student alloc] init];</span><br><span class="line"></span><br><span class="line">[stu setAge:<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">[stu release];</span><br><span class="line"></span><br><span class="line">[stu setAge:<span class="number">10</span>];</span><br></pre></td></tr></table></figure>
<p>&lt; CRASH &gt;</p>
<p><img src="http://images2015.cnblogs.com/blog/776348/201608/776348-20160829114938558-306622190.png" alt=""></p>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>执行完第1行代码后，内存中有个指针变量stu，指向了Student对象（即Student创建的对象）：<br><img src="http://images2015.cnblogs.com/blog/776348/201608/776348-20160829115217777-1123017812.png" alt=""><br>假设Student对象的地址为0xff43，指针变量stu的地址为0xee45，stu中存储的是Student对象的地址0xff43。即指针变量stu指向了这个Student对象。</li>
<li>第3行代码的意思是：给stu所指向的Student对象发送一条setAge:消息，即调用这个Student对象的setAge:方法。目前来说，这个Student对象仍存在于内存中，所以这句代码没有任何问题。</li>
<li>第5行代码的意思是：给stu指向的Student对象发送一条release消息。在这里，Student对象接收到release消息后，会马上被销毁，所占用的内存会被回收：<br><img src="http://images2015.cnblogs.com/blog/776348/201608/776348-20160829115223668-286487842.png" alt=""><br>Student对象被销毁了，地址为0xff43的内存就变成了”垃圾内存”，然而，指针变量stu仍然指向这一块内存，这时候，stu就称为了野指针！</li>
<li>第7行代码的意思仍然是： 给stu所指向的Student对象发送一条setAge:消息。但是在执行完第5行代码后，Student对象已经被销毁了，它所占用的内存已经是垃圾内存，如果你还去访问这一块内存，那就会报野指针错误。这块内存已经不可用了，也不属于你了，你还去访问它，肯定是不合法的。所以，这行代码报错了！</li>
<li>如果改动一下代码，就不会报错：</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Student *stu = [[Student alloc] init];</span><br><span class="line"></span><br><span class="line">[stu setAge:<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">[stu release];</span><br><span class="line"><span class="comment">//  stu变成了空指针，stu就不再指向任何内存了</span></span><br><span class="line">stu = <span class="literal">nil</span>;</span><br><span class="line"><span class="comment">//  因为stu是个空指针，没有指向任何对象，因此setAge:消息是发不出去的，不会造成任何影响。当然，肯定也不会报错。</span></span><br><span class="line">[stu setAge:<span class="number">10</span>];</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>总结</strong>：利用野指针发消息是很危险的，会报错。也就是说，如果一个对象已经被回收了，就不要再去操作它，不要再尝试给它发消息；利用空指针发消息是没有任何问题的。</p>
</blockquote>
<h3 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h3><p>空指针没有指向任何东西的指针（存储的东西是0,null，nil），给空指针发送消息不会报错：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="literal">nil</span> setAge:<span class="number">10</span>];</span><br></pre></td></tr></table></figure>
<h3 id="僵尸对象"><a href="#僵尸对象" class="headerlink" title="僵尸对象"></a>僵尸对象</h3><p>僵尸对象是指所占内存已经被回收的对象，僵尸对象不能再被使用：</p>
<p><img src="http://images2015.cnblogs.com/blog/776348/201608/776348-20160829115246449-2140660921.png" alt=""></p>
<blockquote>
<p><strong>注意</strong>：不能使用[p retaion]让僵尸对象起死复生。</p>
</blockquote>
<h2 id="便利构造器的内存管理"><a href="#便利构造器的内存管理" class="headerlink" title="便利构造器的内存管理"></a>便利构造器的内存管理</h2><p>在OC中通常如果一个静态方法返回一个对象本身的话，在静态方法中我们需要调用autorelease方法，因为按照内存释放原则，在外部使用时不会进行alloc操作也就不需要再调用release或者autorelase，因为这个操作已经放到静态方法内部完成了：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">id</span>)personWithName:(<span class="built_in">NSString</span> *)name&#123;</span><br><span class="line">  Person *p =[[Person alloc] initWithName:name];</span><br><span class="line">  <span class="keyword">return</span> [p autorelease];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>第3行return [p autorelease];是最完美的解决方案，既不会内存泄露，也不会产生野指针。</li>
</ul>
<h2 id="collection的内存管理"><a href="#collection的内存管理" class="headerlink" title="collection的内存管理"></a>collection的内存管理</h2><p>collection就是NSArray，NSDictionary，NSSet…等容器类。</p>
<p>collection会自主管理自己内部的元素：</p>
<ol>
<li>加入collection中的对象会被retain。</li>
<li>移除出collection的对象会被release。</li>
<li>collection被释放会对内部所有对象release。</li>
</ol>
<h2 id="property的参数（MRC）"><a href="#property的参数（MRC）" class="headerlink" title="@property的参数（MRC）"></a>@property的参数（MRC）</h2><p>@property的参数分为三类，也就是说参数最多可以有三个，中间用逗号分隔。如果不进行设置或者只设置其中一类参数，程序会使用三类中的各个默认参数。</p>
<blockquote>
<p><strong>注意</strong>：本文基于MRC进行介绍，ARC下的情况不同，例如ARC下基本数据类型默认的属性参数为（atomic,readwrite,assign），对象类型默认的属性参数为（atomic,readwrite,strong）。</p>
</blockquote>
<h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><h4 id="atomic"><a href="#atomic" class="headerlink" title="atomic"></a>atomic</h4><p>低性能（默认），如果在多线程开发中一个属性可能会被两个及两个以上的线程同时访问，建议使用atomic，加锁，效率低。</p>
<h4 id="nonatomic"><a href="#nonatomic" class="headerlink" title="nonatomic"></a>nonatomic</h4><p>高性能，如果在多线程开发中一个属性不会被两个及两个以上的线程同时访问，建议使用nonatomic，不加锁，效率较高。</p>
<h3 id="读写属性"><a href="#读写属性" class="headerlink" title="读写属性"></a>读写属性</h3><h4 id="readwrite"><a href="#readwrite" class="headerlink" title="readwrite"></a>readwrite</h4><p>读写（默认），同时生成setter和getter的声明和实现。</p>
<h4 id="readonly"><a href="#readonly" class="headerlink" title="readonly"></a>readonly</h4><p>只读，只会生成getter的声明和实现。</p>
<h3 id="内存处理"><a href="#内存处理" class="headerlink" title="内存处理"></a>内存处理</h3><h4 id="assign"><a href="#assign" class="headerlink" title="assign"></a>assign</h4><p>直接赋值（适用于基本数据类型）：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  setter</span></span><br><span class="line">- (<span class="keyword">void</span>)setAge:(<span class="built_in">NSString</span> *)age&#123;</span><br><span class="line">     _age = age;<span class="comment">//基本数据类型：直接复制</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//  getter</span></span><br><span class="line">- (<span class="keyword">int</span>)age&#123;</span><br><span class="line">  <span class="keyword">return</span> _age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="retain-1"><a href="#retain-1" class="headerlink" title="retain"></a>retain</h4><p>release旧值，retain新值（适用于除copy外的OC对象类型）：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  setter  </span></span><br><span class="line">- (<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)name&#123;</span><br><span class="line">    <span class="comment">//1.先判断是不是新传进来的对象</span></span><br><span class="line">    <span class="keyword">if</span>(_name != name)&#123;</span><br><span class="line">       <span class="comment">//2.对旧对象做一次release,若没有旧对象，则没有影响</span></span><br><span class="line">        [_name release];</span><br><span class="line">       <span class="comment">//3.对新对象做一次retain</span></span><br><span class="line">        _name = [name retain]; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//  getter</span></span><br><span class="line"> - (<span class="built_in">NSString</span> *)name&#123;</span><br><span class="line">     <span class="keyword">return</span> [[_name retain]autorelease];</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h4 id="copy-1"><a href="#copy-1" class="headerlink" title="copy"></a>copy</h4><p>release旧值，copy新值（适用于NSStrig、NSArray、NSDictionary、block）：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  setter </span></span><br><span class="line">- (<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)name&#123; </span><br><span class="line">     <span class="comment">//1.先判断是不是新传进来的对象</span></span><br><span class="line">     <span class="keyword">if</span>(_name != name)&#123;</span><br><span class="line">    <span class="comment">//2.对旧对象做一次release,若没有旧对象，则没有影响</span></span><br><span class="line">     [_name release];</span><br><span class="line">   <span class="comment">//3.对新对象做一次copy</span></span><br><span class="line">     _name = [name <span class="keyword">copy</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  getter</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)name&#123;</span><br><span class="line">  <span class="keyword">return</span> [[_name retain]autorelease];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="set和get方法的名称"><a href="#set和get方法的名称" class="headerlink" title="set和get方法的名称"></a>set和get方法的名称</h3><p>修改set和get方法的名称，主要用于布尔类型。因为返回布尔类型的方法名一般以is开头，修改名称一般用在布尔类型中的getter：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@propery(setter=setAbc,getter=isRich) <span class="built_in">BOOL</span> rich;</span><br></pre></td></tr></table></figure>
<h2 id="自动释放池-1"><a href="#自动释放池-1" class="headerlink" title="自动释放池"></a>自动释放池</h2><p>在ios程序运行过程中，会创建无数个池子，这些池子都是以栈结构（先进后出）存在的，当一个对象调用autorelease时，会将这个对象放到位于栈顶的释放池中，当自动释放池被销毁时，会对池子里的所有对象做一次release。这样一来就起到了自动释放的作用，同时对象的销毁过程也得到了延迟（统一调用release方法）。看下面的代码：</p>
<p>&lt; 代码示例 &gt;</p>
<p><em>Person.h</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"></span><br><span class="line">-(Person *)initWithName:(<span class="built_in">NSString</span> *)name;</span><br><span class="line">+(Person *)personWithName:(<span class="built_in">NSString</span> *)name;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>Person.m</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Person.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark 带参数的构造函数</span></span><br><span class="line">-(Person *)initWithName:(<span class="built_in">NSString</span> *)name&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">self</span>=[<span class="keyword">super</span> init])&#123;</span><br><span class="line">        <span class="keyword">self</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#pragma mark 取得一个对象（静态方法）</span></span><br><span class="line">+(Person *)personWithName:(<span class="built_in">NSString</span> *)name&#123;</span><br><span class="line">    Person *p=[[[Person alloc]initWithName:name] autorelease];<span class="comment">//注意这里调用了autorelease</span></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#pragma mark 重写dealloc方法</span></span><br><span class="line">-(<span class="keyword">void</span>)dealloc&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Invoke Person(%@) dealloc method."</span>,<span class="keyword">self</span>.name);</span><br><span class="line">    [<span class="keyword">super</span> dealloc];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>main.m</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Person.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        Person *person1=[[Person alloc]init];</span><br><span class="line">        <span class="comment">//  调用了autorelease方法后面就不需要手动调用release方法了</span></span><br><span class="line">        [person1 autorelease];</span><br><span class="line">        <span class="comment">//  由于autorelease是延迟释放，所以这里仍然可以使用person1</span></span><br><span class="line">        person1.name=<span class="string">@"Kenshin"</span>;</span><br><span class="line">        <span class="comment">//  调用了autorelease方法</span></span><br><span class="line">        Person *person2=[[[Person alloc]initWithName:<span class="string">@"Kaoru"</span>] autorelease];</span><br><span class="line">        <span class="comment">//  内部已经调用了autorelease，所以不需要手动释放，这也符合内存管理原则，因为这里并没有alloc所以不需要release或者autorelease</span></span><br><span class="line">        Person *person3=[Person personWithName:<span class="string">@"rosa"</span>];</span><br><span class="line">        </span><br><span class="line">        Person *person4=[Person personWithName:<span class="string">@"jack"</span>];</span><br><span class="line">        [person4 retain];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*结果：</span><br><span class="line">     Invoke Person(rosa) dealloc method.</span><br><span class="line">     Invoke Person(Kaoru) dealloc method.</span><br><span class="line">     Invoke Person(Kenshin) dealloc method.</span><br><span class="line">     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li><code>main.m</code>：当上面@autoreleaespool代码块执行完之后，三个对象都得到了释放，但是person4并没有释放，原因很简单，由于我们手动retain了一次，当自动释放池释放后调用四个对的release方法，当调用完person4的release之后它的引用计数器为1，所有它并没有释放（这是一个反例，会造成内存泄露）；autorelase方法将一个对象的内存释放延迟到了自动释放池销毁的时候，因此上面person1，调用完autorelase之后它还存在，因此给name赋值不会有任何问题。</li>
<li>在OC中通常如果一个静态方法返回一个对象本身的话，在静态方法中我们需要调用autorelease方法，因为按照内存释放原则，在外部使用时不会进行alloc操作也就不需要再调用release或者autorelase，所以这个操作需要放到静态方法内部完成。</li>
<li>出了大括号，⾃动释放池才向各个对象统一发送release消息。 </li>
</ul>
<p>对于自动内存释放简单总结一下：</p>
<ol>
<li>autorelease方法不会改变对象的引用计数，只是将这个对象放到自动释放池中。</li>
<li>自动释放池本质上是一个stack，扔到pool中的对象等价于入栈。当自动释放池销毁后调用对象的release方法，不一定就能销毁对象（例如如果一个对象的引用计数器&gt;1则此时就无法销毁）。</li>
<li>由于自动释放池最后统一销毁对象，因此如果一个操作比较占用内存（对象比较多或者对象占用资源比较多），最好不要放到自动释放池或者考虑放到多个自动释放池。</li>
<li>OC中类库中的静态方法一般都不需要手动释放，内部已经调用了autorelease方法。</li>
</ol>
<h2 id="ARC内存管理机制"><a href="#ARC内存管理机制" class="headerlink" title="ARC内存管理机制"></a>ARC内存管理机制</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>ARC是自iOS 5之后增加的新特性，完全消除了手动管理内存的烦琐，编译器会自动在适当的地方插入适当的retain、release、autorelease语句。你不再需要担心内存管理，因为编译器为你处理了一切。</p>
<blockquote>
<p><strong>注意</strong>：ARC 是编译器特性，而不是 iOS 运行时特性（除了weak指针系统），它也不是类似于其它语言中的垃圾收集器。因此 ARC 和手动内存管理性能是一样的，有时还能更加快速，因为编译器还可以执行某些优化。</p>
</blockquote>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>ARC 的规则非常简单：只要还有一个指针指向对象，对象就会保持在内存中。当指针指向新值，或者指针不再存在时，相关联的对象就会自动释放。这条规则对于成员变量、synthesize属性、局部变量都是适用的。</p>
<h3 id="strong指针"><a href="#strong指针" class="headerlink" title="strong指针"></a>strong指针</h3><p>控制器中有个文本输入框框属性：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UITextField</span> *nameField;</span><br></pre></td></tr></table></figure>
<p>如果用户在文本框中输入mj这个字符串，那么就可以说，nameField的text属性是NSString对象的指针，也就是拥有者，该对象保存了文本输入框的内容：</p>
<p><img src="http://images2015.cnblogs.com/blog/776348/201608/776348-20160829225656824-1310872121.png" alt=""></p>
<p>如果执行了如下代码：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *name = <span class="keyword">self</span>.nameField.text;</span><br></pre></td></tr></table></figure>
<p>一个对象可以有多个拥有者,在上面代码中,name变量同样也是这个NSString对象的拥有者,也就是有两个指针指向同一个对象：</p>
<p><img src="http://images2015.cnblogs.com/blog/776348/201608/776348-20160829225708668-1476578082.png" alt=""></p>
<p>随后用户改变了输入框的内容，比如输入“mike”，此时nameFeild的text属性就指向了新的NSString对象。但原来的NSString对象仍然还有一个所有者(name变量)，因此会继续保留在内存中：</p>
<p><img src="http://images2015.cnblogs.com/blog/776348/201608/776348-20160829225720980-611397820.png" alt=""></p>
<p>当name变量获得新值,或者不再存在时（如局部变量方法返回时、实例变量对象释放时）,原先的NSString对象就不再拥有任何所有者,retain计数降为0,这时对象会被释放。如，给name变量赋予一个新值“Jake”：</p>
<p><img src="http://images2015.cnblogs.com/blog/776348/201608/776348-20160829225726980-1147773046.png" alt=""></p>
<p>我们称name和nameField.text指针为”strong指针”，因为它们能够保持对象的生命。默认所有实例变量和局部变量都是strong指针。</p>
<h3 id="weak指针"><a href="#weak指针" class="headerlink" title="weak指针"></a>weak指针</h3><p>weak型的指针变量仍然可以指向一个对象，但不属于对象的拥有者。</p>
<p>执行下面的代码：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__<span class="keyword">weak</span> <span class="built_in">NSString</span> *name = <span class="keyword">self</span>.nameField.text;</span><br></pre></td></tr></table></figure>
<p>name变量和nameField.text属性都指向同一个NSString对象,但name不是拥有者：</p>
<p><img src="http://images2015.cnblogs.com/blog/776348/201608/776348-20160829225732621-647918422.png" alt=""></p>
<p>如果文本框的内容发生变化,则原先的NSString对象就没有拥有者,会被释放,此时name变量会自动变成nil,称为空指针：</p>
<p><img src="http://images2015.cnblogs.com/blog/776348/201608/776348-20160829225738090-382980942.png" alt=""></p>
<p>weak型的指针变量自动变为nil是非常方便的，这样阻止了weak指针继续指向已释放对象，避免了野指针的产生，不然会导致非常难于寻找的Bug，空指针消除了类似的问题。</p>
<p>weak指针主要用于阻止所有权循环，典型例子是delegate模式，你的ViewController通过strong指针（self.view）拥有一个UITableView，UITableView的dataSource和delegate都是weak指针，指向你的ViewController：</p>
<p><img src="http://images2015.cnblogs.com/blog/776348/201608/776348-20160829225743199-540920695.png" alt=""></p>
<h3 id="strong和weak的使用注意"><a href="#strong和weak的使用注意" class="headerlink" title="strong和weak的使用注意"></a>strong和weak的使用注意</h3><p>下面代码是有问题的:</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">__<span class="keyword">weak</span> <span class="built_in">NSString</span> *str = [[<span class="built_in">NSString</span> alloc] initWithFormat:<span class="string">@"1234"</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, str); <span class="comment">// 打印出来是"(null)"</span></span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>str是个weak指针，所以NSString对象没有拥有者，在创建之后就会被立即释放。Xcode还会给出警告（”Warning: Assigning retained object to weak variable; object will be released after assignment”）。</li>
</ul>
<p>一般的指针变量默认就是strong类型的，因此一般我们对于strong变量不加__strong修饰，以下两行代码是等价的：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *name = <span class="keyword">self</span>.nameField.text;</span><br><span class="line">__<span class="keyword">strong</span> <span class="built_in">NSString</span> *name = <span class="keyword">self</span>.nameField.text;</span><br></pre></td></tr></table></figure>
<p>属性可以是strong或weak，写法如下：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">id</span> delegate;</span><br></pre></td></tr></table></figure>
<p>以下代码在ARC之前是可能会行不通的，因为在手动内存管理中，从NSArray中移除一个对象时，这个对象会发送一条release消息，可能会被立即释放。随后NSLog()打印该对象就会导致应用崩溃：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> obj = [array objectAtIndex:<span class="number">0</span>];</span><br><span class="line">[array removeObjectAtIndex:<span class="number">0</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, obj);</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>在ARC中这段代码是完全合法的，因为obj变量是一个strong指针，它成为了对象的拥有者，从NSArray中移除该对象也不会导致对象被释放。</li>
</ul>
<h3 id="ARC小结"><a href="#ARC小结" class="headerlink" title="ARC小结"></a>ARC小结</h3><ol>
<li>有了ARC,我们的代码可以清晰很多，你不再需要考虑什么时候retain或release对象。唯一需要考虑的是对象之间的关联，也就是哪个对象拥有哪个对象。</li>
<li>ARC也有一些限制：<ul>
<li>首先ARC只能工作于OC对象，如果应用使用了Core Foundation或malloc()/free()，此时还是需要你来手动管理内存。</li>
<li>此外ARC还有其它一些更为严格的语言规则，以确保ARC能够正常地工作。</li>
</ul>
</li>
<li>虽然ARC管理了retain和release，但并不表示你完全不需要关心内存管理的问题。因为strong指针会保持对象的生命，某些情况下你仍然需要手动设置这些指针为nil，否则可能导致应用内存不足。无论何时你创建一个新对象时，都需要考虑谁拥有该对象，以及这个对象需要存活多久。</li>
<li>ARC还能很好地结合C++使用，这对游戏开发是非常有帮助的。</li>
</ol>
<h3 id="ARC使用注意总结"><a href="#ARC使用注意总结" class="headerlink" title="ARC使用注意总结"></a>ARC使用注意总结</h3><ol>
<li>不能直接调用dealloc方法，不能调用retain，release，autorelease，retainCount方法，包括@selector(retain)的方式也不行。　　</li>
<li>允许重写dealloc，可以用dealloc方法来管理一些资源，不能用来释放实例变量。不允许调用[super dealloc]，在ARC下父类的dealloc同样由编译器来自动完成。</li>
<li>Core Foundation类型的对象仍然可以用CFRetain，CFRelease这些方法。</li>
<li>不能在C结构体中使用对象指针，如果有类似功能可以创建一个OC类来管理这些对象。</li>
<li>在id和void＊之间没有简便的转换方法，同样在OC和Core Foundation类型之间的转换都需要使用编译器制定的转换函数。</li>
<li>不能再使用NSAutoreleasePool对象，ARC提供了@autoreleasepool块来代替它，这样更有效率。</li>
<li>不能使用内存存储区（不能再使用NSZone）。</li>
<li>不能以new为开头给一个属性命名。</li>
<li>声明IBOutlet时一般应当使用weak，除了对StoryBoard这样nib中间的顶层对象要用strong</li>
<li>weak相当于老版本的assign，strong相当于retain。</li>
<li>只要没有强指针指向对象，对象就会被释放。</li>
</ol>
<h3 id="property修饰符小结"><a href="#property修饰符小结" class="headerlink" title="@property修饰符小结"></a>@property修饰符小结</h3><ol>
<li><code>strong</code>（修饰对象用__strong，适用于OC对象）: 强引用，相当于原来的retain，每次赋值引用计数器加1，只要指针引用这个对象，这个对象就不会被销毁。</li>
<li><code>weak</code>（修饰对象用__weak，适用于OC对象）: 弱引用，相当于原来的assign，该属性所声明的变量将没有对象的所有权，并且当对象被释放之后，对象将被自动赋值nil，记住IBOutlet应该使用weak。</li>
<li><code>unsafe_unretained</code>（修饰对象用__unsafe_unretained，适用于OC对象）:和weak类似并没有对象的所有权，区别就是如果对象释放后它不会像weak一样自动将指针设置为nil，有可能出现野指针，iOS5之前的系统用该属性代替weak来使用。</li>
<li><code>copy</code>（只能做修饰符不能直接修饰对象，适用于OC对象）: 和之前的copy一样，适用于NSString、NSArray、NSDictionary、Block。</li>
<li><code>assign</code>（只能做修饰符不能直接修饰对象，适用于基本数据类型）: 对象不能使用assign。</li>
</ol>
<h3 id="autoreleasing"><a href="#autoreleasing" class="headerlink" title="__autoreleasing"></a>__autoreleasing</h3><p><code>__autoreleasing</code>（只能修饰变量不能修饰属性）：修饰一个对象在使用完之后自动释放，通常用于延迟释放内存，同在MRC下和调用对象的autorelease方法是等效的。</p>
<p><code>__autoreleasing</code>主要用于函数参数是OC对象指针的情况下（也就是参数”NSObject **obj”类型，指针的指针），典型的应用就是NSError的使用。在这种情况下，经常需要在函数内部重新创建一个对象给传入的参数赋值（修改参数内容），如果使用<code>__autorelesing</code>关键字编译器在处理内部函数时会使用自动释放池，即保证内部对象能够正常释放又可以修改外部变量。之所以很多时候使用NSError作为参数传递到一些方法中没有将变量声明为<code>__autoreleasing</code>是因为编译器已经自动做了处理（因此，如果考虑到性能推荐还是加上此关键字）。</p>
<h2 id="内存管理中的循环引用问题以及解决"><a href="#内存管理中的循环引用问题以及解决" class="headerlink" title="内存管理中的循环引用问题以及解决"></a>内存管理中的循环引用问题以及解决</h2><p>不能使用#import的方式相互包含，这就形成了循环引用。当存在循环依赖时（A类使用B类，B类使用A类），内存将无法释放从而造成内存泄露，可以用<code>@class</code>防止循环导入。</p>
<p>新的关键字<code>@class</code>能够解决循环引用问题，提高性能。</p>
<p>@class的作用：声明一个类，告诉编译器某个名称是一个类。</p>
<p>开发中引用一个类的规范：</p>
<ol>
<li>在.h文件中使用@class来声明类。</li>
<li>在.m文件中真正要使用到的时候，使用#import来包含类中的所有东西。</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.cnblogs.com/mjios/" target="_blank" rel="external">M了个J的博客</a></p>
<hr>

      
    </div>
    
    <div>
      
        
      
    </div>

    <div>
      
        
<div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center">
<div>想请我吃辣条吗？</div>
<button id="rewardButton", disable="enable", onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}", style="cursor: pointer; border: 0; outline: 0; border-radius: 100%; padding: 0; margin: 0; letter-spacing: normal; text-transform: none; text-indent: 0px; text-shadow: none">
<span onmouseover="this.style.color='rgb(236,96,0)';this.style.background='rgb(204,204,204)'" onMouseOut="this.style.color='#fff';this.style.background='rgb(236,96,0)'" style="display: inline-block; width: 70px; height: 70px; border-radius: 100%; line-height: 81px; color: #fff; font: 400 35px/75px 'microsofty'; background: rgb(236,96,0)">赏</span>
</button>
<div id="QR" style="display: none;">

<div id="wechat" style="display: inline-block">
<img id="wechat_qr" src="http://i4.piimg.com/508f386ab6942876.jpg" alt="SanFordy WeChat Pay" style="width: 200px; max-width: 100%; display: inline-block"/>
<p>微信打赏</p>
</div>


<div id="alipay" style="display: inline-block">
<img id="alipay_qr" src="http://i4.piimg.com/481cbcc6ec69d37b.png" alt="SanFordy Alipay" style="width: 200px; max-width: 100%; display: inline-block"/>
<p>支付宝打赏</p>
</div>

</div>
</div>

      
    </div>

    <footer class="post-footer">
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/08/25/〖A〗【2-0】OC-语法/【05】构造方法和description方法/" rel="next" title="【05】构造方法和description方法">
                <i class="fa fa-chevron-left"></i> 【05】构造方法和description方法
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/08/30/〖A〗【2-0】OC-语法/【07】OC面向对象特性（一）：封装/" rel="prev" title="【07】OC面向对象特性（一）：封装">
                【07】OC面向对象特性（一）：封装 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2016/08/25/〖A〗【2-0】OC-语法/【06】内存管理/"
           data-title="【06】内存管理" data-url="http://sanfordy.com/2016/08/25/〖A〗【2-0】OC-语法/【06】内存管理/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/icon.jpg"
               alt="SanFordy" />
          <p class="site-author-name" itemprop="name">SanFordy</p>
          <p class="site-description motion-element" itemprop="description">I am a happy programmer.</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">46</span>
              <span class="site-state-item-name">归档</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="" target="_blank" title="GitHub">
                  
                    <i class="fa fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="" target="_blank" title="Weibo">
                  
                    <i class="fa fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="" target="_blank" title="Twitter">
                  
                    <i class="fa fa-twitter-square"></i>
                  
                  Twitter
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="" target="_blank" title="Facebook">
                  
                    <i class="fa fa-facebook-square"></i>
                  
                  Facebook
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="" target="_blank" title="Stackoverflow">
                  
                    <i class="fa fa-stack-overflow"></i>
                  
                  Stackoverflow
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="" target="_blank" title="Zhihu">
                  
                    <i class="fa fa-book"></i>
                  
                  Zhihu
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="" target="_blank" title="Douban">
                  
                    <i class="fa fa-coffee"></i>
                  
                  Douban
                </a>
              </span>
            
          
        </div>

        
        
          <div class="cc-license motion-element" itemprop="license">
            <a href="http://creativecommons.org/licenses/by-nc-sa/4.0" class="cc-opacity" target="_blank">
              <img src="/images/cc-by-nc-sa.svg" alt="Creative Commons" />
            </a>
          </div>
        

        
        
          <div class="links-of-blogroll motion-element">
            <div class="links-of-blogroll-title">
              <i class="fa fa-globe fa-fw"></i>
              Links
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.guijj.com/pics/201404/535a0243a9698.gif" title="biggift" target="_blank">biggift</a>
                </li>
              
            </ul>
          </div>
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#基本原理"><span class="nav-number">1.</span> <span class="nav-text">基本原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么要进行内存管理"><span class="nav-number">1.1.</span> <span class="nav-text">为什么要进行内存管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常见内存问题"><span class="nav-number">1.2.</span> <span class="nav-text">常见内存问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内存管理的范围"><span class="nav-number">1.3.</span> <span class="nav-text">内存管理的范围</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#引用计数"><span class="nav-number">1.4.</span> <span class="nav-text">引用计数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象的基本结构"><span class="nav-number">1.5.</span> <span class="nav-text">对象的基本结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象的销毁"><span class="nav-number">1.6.</span> <span class="nav-text">对象的销毁</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存管理原则（MRC）"><span class="nav-number">2.</span> <span class="nav-text">内存管理原则（MRC）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存管理的操作（MRC）"><span class="nav-number">3.</span> <span class="nav-text">内存管理的操作（MRC）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#alloc"><span class="nav-number">3.1.</span> <span class="nav-text">+alloc</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#retain"><span class="nav-number">3.2.</span> <span class="nav-text">-retain</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#copy"><span class="nav-number">3.3.</span> <span class="nav-text">-copy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mutableCopy"><span class="nav-number">3.4.</span> <span class="nav-text">-mutableCopy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#release"><span class="nav-number">3.5.</span> <span class="nav-text">-release</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#autorelease"><span class="nav-number">3.6.</span> <span class="nav-text">-autorelease</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#基本功能"><span class="nav-number">3.6.1.</span> <span class="nav-text">基本功能</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#好处"><span class="nav-number">3.6.2.</span> <span class="nav-text">好处</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用注意"><span class="nav-number">3.6.3.</span> <span class="nav-text">使用注意</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#自动释放池"><span class="nav-number">3.6.4.</span> <span class="nav-text">自动释放池</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#自动释放池的创建方式"><span class="nav-number">3.6.5.</span> <span class="nav-text">自动释放池的创建方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Autorelease注意"><span class="nav-number">3.6.6.</span> <span class="nav-text">Autorelease注意</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#retainCount"><span class="nav-number">3.6.7.</span> <span class="nav-text">-retainCount</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#dealloc"><span class="nav-number">3.6.8.</span> <span class="nav-text">-dealloc</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存管理代码示例"><span class="nav-number">4.</span> <span class="nav-text">内存管理代码示例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存的相关概念"><span class="nav-number">5.</span> <span class="nav-text">内存的相关概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#野指针"><span class="nav-number">5.1.</span> <span class="nav-text">野指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#空指针"><span class="nav-number">5.2.</span> <span class="nav-text">空指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#僵尸对象"><span class="nav-number">5.3.</span> <span class="nav-text">僵尸对象</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#便利构造器的内存管理"><span class="nav-number">6.</span> <span class="nav-text">便利构造器的内存管理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#collection的内存管理"><span class="nav-number">7.</span> <span class="nav-text">collection的内存管理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#property的参数（MRC）"><span class="nav-number">8.</span> <span class="nav-text">@property的参数（MRC）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#原子性"><span class="nav-number">8.1.</span> <span class="nav-text">原子性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#atomic"><span class="nav-number">8.1.1.</span> <span class="nav-text">atomic</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#nonatomic"><span class="nav-number">8.1.2.</span> <span class="nav-text">nonatomic</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#读写属性"><span class="nav-number">8.2.</span> <span class="nav-text">读写属性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#readwrite"><span class="nav-number">8.2.1.</span> <span class="nav-text">readwrite</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#readonly"><span class="nav-number">8.2.2.</span> <span class="nav-text">readonly</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内存处理"><span class="nav-number">8.3.</span> <span class="nav-text">内存处理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#assign"><span class="nav-number">8.3.1.</span> <span class="nav-text">assign</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#retain-1"><span class="nav-number">8.3.2.</span> <span class="nav-text">retain</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#copy-1"><span class="nav-number">8.3.3.</span> <span class="nav-text">copy</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#set和get方法的名称"><span class="nav-number">8.4.</span> <span class="nav-text">set和get方法的名称</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#自动释放池-1"><span class="nav-number">9.</span> <span class="nav-text">自动释放池</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ARC内存管理机制"><span class="nav-number">10.</span> <span class="nav-text">ARC内存管理机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#简介"><span class="nav-number">10.1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#原理"><span class="nav-number">10.2.</span> <span class="nav-text">原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#strong指针"><span class="nav-number">10.3.</span> <span class="nav-text">strong指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#weak指针"><span class="nav-number">10.4.</span> <span class="nav-text">weak指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#strong和weak的使用注意"><span class="nav-number">10.5.</span> <span class="nav-text">strong和weak的使用注意</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ARC小结"><span class="nav-number">10.6.</span> <span class="nav-text">ARC小结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ARC使用注意总结"><span class="nav-number">10.7.</span> <span class="nav-text">ARC使用注意总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#property修饰符小结"><span class="nav-number">10.8.</span> <span class="nav-text">@property修饰符小结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#autoreleasing"><span class="nav-number">10.9.</span> <span class="nav-text">__autoreleasing</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存管理中的循环引用问题以及解决"><span class="nav-number">11.</span> <span class="nav-text">内存管理中的循环引用问题以及解决</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考"><span class="nav-number">12.</span> <span class="nav-text">参考</span></a></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2014 - 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">SanFordy</span>
</div>





        

<div class="busuanzi-count">

  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  

  
  
</div>



        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"sanfordy"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
      
      <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
      <script src="/js/src/hook-duoshuo.js"></script>
    
  





  
  
  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
       search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body").append('<div class="popoverlay">').css('overflow', 'hidden');
      $('.popup').toggle();

    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
    'use strict';
    $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
            // get the contents from search data
            isfetched = true;
            $('.popup').detach().appendTo('.header-inner');
            var datas = $( "entry", xmlResponse ).map(function() {
                return {
                    title: $( "title", this ).text(),
                    content: $("content",this).text(),
                    url: $( "url" , this).text()
                };
            }).get();
            var $input = document.getElementById(search_id);
            var $resultContent = document.getElementById(content_id);
            $input.addEventListener('input', function(){
                var matchcounts = 0;
                var str='<ul class=\"search-result-list\">';                
                var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                $resultContent.innerHTML = "";
                if (this.value.trim().length > 1) {
                // perform local searching
                datas.forEach(function(data) {
                    var isMatch = true;
                    var content_index = [];
                    var data_title = data.title.trim().toLowerCase();
                    var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                    var data_url = data.url;
                    var index_title = -1;
                    var index_content = -1;
                    var first_occur = -1;
                    // only match artiles with not empty titles and contents
                    if(data_title != '' && data_content != '') {
                        keywords.forEach(function(keyword, i) {
                            index_title = data_title.indexOf(keyword);
                            index_content = data_content.indexOf(keyword);
                            if( index_title < 0 && index_content < 0 ){
                                isMatch = false;
                            } else {
                                if (index_content < 0) {
                                    index_content = 0;
                                }
                                if (i == 0) {
                                    first_occur = index_content;
                                }
                            }
                        });
                    }
                    // show search results
                    if (isMatch) {
                        matchcounts += 1;
                        str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                        var content = data.content.trim().replace(/<[^>]+>/g,"");
                        if (first_occur >= 0) {
                            // cut out 100 characters
                            var start = first_occur - 20;
                            var end = first_occur + 80;
                            if(start < 0){
                                start = 0;
                            }
                            if(start == 0){
                                end = 50;
                            }
                            if(end > content.length){
                                end = content.length;
                            }
                            var match_content = content.substring(start, end);
                            // highlight all keywords
                            keywords.forEach(function(keyword){
                                var regS = new RegExp(keyword, "gi");
                                match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                            });
                            
                            str += "<p class=\"search-result\">" + match_content +"...</p>"
                        }
                        str += "</li>";
                    }
                })};
                str += "</ul>";
                if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
                if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
                $resultContent.innerHTML = str;
            });
            proceedsearch();
        }
    });}

    // handle and trigger popup window;
    $('.popup-trigger').mousedown(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };

    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".popoverlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>

  

  

  

</body>
</html>
