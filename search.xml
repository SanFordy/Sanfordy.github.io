<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[【16】Foundation框架]]></title>
      <url>http://sanfordy.com/2016/08/31/%E3%80%96A%E3%80%97%E3%80%902-0%E3%80%91OC-%E8%AF%AD%E6%B3%95/%E3%80%9016%E3%80%91Foundation%E6%A1%86%E6%9E%B6/</url>
      <content type="html"><![CDATA[<blockquote>
<p>Foundation：基础框架。框架中包含了很多开发中常用的数据类型，如结构体，枚举，类等，是其他ios框架的基础。</p>
</blockquote>
<a id="more"></a>
<h2 id="Cocoa概述"><a href="#Cocoa概述" class="headerlink" title="Cocoa概述"></a>Cocoa概述</h2><p>为什么前面说的内容中新建一个类的时候我们都是选择<code>Cocoa Class</code>呢？Cocoa是什么呢？</p>
<p><code>Cocoa</code>不是一种编程语言（它可以运行多种编程语言），它也不是一个开发工具（通过命令行我们仍然可以开发Cocoa程序），它是创建Mac OS X和IOS程序的原生面向对象API，为这两者应用提供了编程环境。</p>
<p>我们通常称为“Cocoa框架”，事实上Cocoa本身是一个框架的集合，它包含了众多子框架，其中最重要的要数“Foundation”和“UIKit”。前者是框架的基础，和界面无关，其中包含了大量常用的API；后者是基础的UI类库，以后我们在IOS开发中会经常用到。这两个框架在系统中的位置如下图：</p>
<p><img src="http://images2015.cnblogs.com/blog/776348/201608/776348-20160831181444621-1522185614.jpg" alt=""></p>
<h2 id="Foundation概述"><a href="#Foundation概述" class="headerlink" title="Foundation概述"></a>Foundation概述</h2><p>Foundation：基础框架。框架中包含了很多开发中常用的数据类型，如结构体，枚举，类等，是其他iOS框架的基础。</p>
<p>如果要想使用foundation框架中的数据类型，那么包含它的主头文件就可以了。即#import<foundation foundation.h=""></foundation></p>
<p>core foundation框架相对底层，里面的代码几乎都是c语言的，而foundation中是OC的。</p>
<p>其实所有的Mac OS X和iOS程序都是由大量的对象构成，而这些对象的根对象都是NSObject，NSObject就处在Foundation框架之中，具体的类结构如下：</p>
<p><img src="http://images2015.cnblogs.com/blog/776348/201608/776348-20160831182418886-1199302970.jpg" alt=""></p>
<p><img src="http://images2015.cnblogs.com/blog/776348/201608/776348-20160831182426465-1985118258.jpg" alt=""></p>
<p><img src="http://images2015.cnblogs.com/blog/776348/201608/776348-20160831182431980-1263950777.jpg" alt=""></p>
<h2 id="常用结构体"><a href="#常用结构体" class="headerlink" title="常用结构体"></a>常用结构体</h2><p>在Foundation中定义了很多常用结构体类型来简化我们的日常开发，这些结构体完全采用Objective-C定义，和我们自己定义的结构体没有任何区别，之所以由框架为我们提供完全是为了简化我们的开发。</p>
<p>常用的结构体：</p>
<ol>
<li>NSRange（location length）：表示范围。</li>
<li>NSPoint/CGPoint：表示坐标。</li>
<li>NSSize/CGSize：表示UI元素的尺寸。</li>
<li>NSRect/CGRect（CGPoint CGSize）：表示一个UI元素的位置和尺寸。</li>
</ol>
<p>&lt; 代码示例 &gt;</p>
<p><em>main.m</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - NSRange的使用 -</span></span><br><span class="line"><span class="keyword">void</span> test1()&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  第一种创建方式（第一参数是起始位置，第二个参数是长度）</span></span><br><span class="line">    <span class="built_in">NSRange</span> rg1 = &#123;<span class="number">3</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="comment">//  第二种创建方式（这种方式比较常见）</span></span><br><span class="line">    <span class="built_in">NSRange</span> rg2 = <span class="built_in">NSMakeRange</span>(<span class="number">3</span>,<span class="number">5</span>);</span><br><span class="line">    <span class="comment">//  打印NSRange可以使用Foundation中方法（注意不能直接NSLog(@"rg2 is %@", rg2)，因为rg2不是对象（准确的说%@是指针）而是结构体）</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"rg2 is %@"</span>, <span class="built_in">NSStringFromRange</span>(rg2));<span class="comment">//  输出：rg2 is &#123;3, 5&#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  简单使用：查找某个字符串在str中的范围</span></span><br><span class="line">    <span class="built_in">NSString</span> *str = <span class="string">@"wo shi da SB"</span>;</span><br><span class="line">    <span class="built_in">NSRange</span> rg3 = [str rangeOfString:<span class="string">@"da"</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"location = %ld,lenth = %ld"</span>,rg3.location,rg3.length);<span class="comment">// 输出：location = 7,lenth = 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - NSPoint/CGPoint的使用 -</span></span><br><span class="line"><span class="keyword">void</span> test2()&#123;</span><br><span class="line">    <span class="comment">//  NSPoint其实就是CGPoint，开发中常用CGPoint，因为他是跨平台的）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  第一种创建方式</span></span><br><span class="line">    <span class="built_in">NSPoint</span> p1 = <span class="built_in">NSMakePoint</span>(<span class="number">10</span>, <span class="number">15</span>);</span><br><span class="line">    <span class="comment">//  第二种创建方式（这种方式比较常见）</span></span><br><span class="line">    <span class="built_in">CGPoint</span> p2 = <span class="built_in">CGPointMake</span>(<span class="number">10</span>, <span class="number">15</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,<span class="built_in">NSStringFromPoint</span>(p2));<span class="comment">//   输出：&#123;10, 15&#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  简单使用：比较两个点是否相同</span></span><br><span class="line">    <span class="built_in">BOOL</span> b = <span class="built_in">CGPointEqualToPoint</span>(p1, p2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - NSSize/CGSize的使用 -</span></span><br><span class="line"><span class="keyword">void</span> test3()&#123;</span><br><span class="line">    <span class="comment">//  NSSize其实就是CGSize</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  第一种创建方式（宽度10，高度15）</span></span><br><span class="line">    <span class="built_in">NSSize</span> s1 = <span class="built_in">NSMakeSize</span>(<span class="number">10</span>, <span class="number">15</span>);</span><br><span class="line">    <span class="comment">//  第二种创建方式（这种方式比较常见）</span></span><br><span class="line">    <span class="built_in">CGSize</span> s2=<span class="built_in">CGSizeMake</span>(<span class="number">100</span>, <span class="number">150</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,<span class="built_in">NSStringFromSize</span>(s2));<span class="comment">//    输出：&#123;100, 150&#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  简单使用：比较两个尺寸是否相同</span></span><br><span class="line">    <span class="built_in">BOOL</span> b = <span class="built_in">CGSizeEqualToSize</span>(s1, s2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - NSRect/CGRect的使用 -</span></span><br><span class="line"><span class="keyword">void</span> test4()&#123;</span><br><span class="line">    <span class="comment">//  NSRect其实就是CGRect</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  第一种创建方式</span></span><br><span class="line">    <span class="built_in">NSRect</span> r1 = <span class="built_in">NSMakeRect</span>(<span class="number">10</span>, <span class="number">5</span>, <span class="number">100</span>, <span class="number">200</span>);</span><br><span class="line">    <span class="comment">//  第二种创建方式（这种方式比较常见）</span></span><br><span class="line">    <span class="built_in">NSRect</span> r2=<span class="built_in">CGRectMake</span>(<span class="number">10</span>, <span class="number">5</span>, <span class="number">100</span>, <span class="number">200</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,<span class="built_in">NSStringFromRect</span>(r2));<span class="comment">//    输出：&#123;&#123;10, 5&#125;, &#123;100, 200&#125;&#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  简单使用1：比较两个区域是否相同</span></span><br><span class="line">    <span class="built_in">BOOL</span> b1 = <span class="built_in">CGRectEqualToRect</span>(r1, r2);</span><br><span class="line">    <span class="comment">//  简单使用2：判断这个点是否在区域范围内</span></span><br><span class="line">    <span class="built_in">BOOL</span> b2 = <span class="built_in">CGRectContainsPoint</span>(r1, <span class="built_in">CGPointMake</span>(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        test1();</span><br><span class="line">        test2();</span><br><span class="line">        test3();</span><br><span class="line">        test4();</span><br><span class="line">    &#125; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="日期"><a href="#日期" class="headerlink" title="日期"></a>日期</h2><p>接下来熟悉一下Foundation框架中日期的操作：</p>
<p>&lt; 代码示例 &gt;</p>
<p><em>main.m</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  NSDate类创建的对象永远都是零时区（格林尼治标准时间，当前时间-8个小时）的时间对象</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  输出所有时区信息</span></span><br><span class="line">    <span class="built_in">NSArray</span> *names = [<span class="built_in">NSTimeZone</span> knownTimeZoneNames];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,names);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  通过便利构造器创建的时间对象表示了当前的时间</span></span><br><span class="line">    <span class="built_in">NSDate</span> *date1 = [<span class="built_in">NSDate</span> date];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,date1); <span class="comment">//  结果：2015-12-30 13:46:40 +0000</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  在当前日期的基础上加上100秒，注意在OC中多数时间单位都是秒</span></span><br><span class="line">    <span class="built_in">NSDate</span> *date2 = [<span class="built_in">NSDate</span> dateWithTimeIntervalSinceNow:<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,date2); <span class="comment">//  结果：2015-12-30 13:48:20 +0000</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  随机获取一个将来的日期</span></span><br><span class="line">    <span class="built_in">NSDate</span> *date3 = [<span class="built_in">NSDate</span> distantFuture];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,date3); <span class="comment">//  结果：4001-01-01 00:00:00 +0000</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  根据给定的时间段推算距离2001年1月1日零点的时间</span></span><br><span class="line">    <span class="built_in">NSDate</span> *date4 = [<span class="built_in">NSDate</span> dateWithTimeIntervalSinceReferenceDate:<span class="number">24</span>*<span class="number">3600</span>*<span class="number">365</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,date4);<span class="comment">//   结果：2002-01-01 00:00:00 +0000</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  根据给定的时间片段推算距离零时区1970年1月1日零点的时间</span></span><br><span class="line">    <span class="built_in">NSDate</span> *date5 = [<span class="built_in">NSDate</span> dateWithTimeIntervalSince1970:<span class="number">24</span>*<span class="number">3600</span>*<span class="number">365</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,date5);<span class="comment">//   结果：1971-01-01 00:00:00 +0000</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  返回比较早的日期（同样也有返回较晚的时间：laterDate:）</span></span><br><span class="line">    <span class="built_in">NSDate</span> *date6 = [date1 earlierDate:date2];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,date6); <span class="comment">//  结果：2015-12-30 13:46:40 +0000</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  两个日期之差，返回单位为秒</span></span><br><span class="line">    <span class="built_in">NSTimeInterval</span> timeInterval1=[date2 timeIntervalSinceDate:date1];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%f"</span>,timeInterval1); <span class="comment">//   结果：100.003422</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  当前对象距离1970年1月1日的时间段（同样的还有：SinceNow，SinceReferenceDate）</span></span><br><span class="line">    <span class="built_in">NSTimeInterval</span> timeInterval2 = [date3 timeIntervalSince1970];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%f"</span>,timeInterval2);<span class="comment">//   结果：64092211200.000000</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  判断两个时间对象是否相同</span></span><br><span class="line">    <span class="built_in">BOOL</span> result = [date2 isEqual:date3];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,result ? <span class="string">@"YES"</span> :<span class="string">@"NO"</span>);<span class="comment">//  结果：NO</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  自定义日期格式</span></span><br><span class="line">    <span class="built_in">NSDateFormatter</span> *formater = [[<span class="built_in">NSDateFormatter</span> alloc]init];</span><br><span class="line">    formater.dateFormat = <span class="string">@"yyyy年-MM月-dd日 hh:mm:ss"</span>;</span><br><span class="line">    <span class="built_in">NSString</span> *datestr1=[formater stringFromDate:date1];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,datestr1); <span class="comment">//   结果：2015年-12月-30日 09:46:40</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  字符串转化为日期</span></span><br><span class="line">    <span class="built_in">NSDate</span> *date7 = [formater dateFromString:<span class="string">@"2015年-12月-30日 09:46:26"</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,date7); <span class="comment">//  结果：2015-12-30 01:46:26 +0000</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  设置系统日期样式</span></span><br><span class="line">    [formater setDateStyle:(<span class="built_in">NSDateFormatterFullStyle</span>)];</span><br><span class="line">    <span class="built_in">NSString</span> *datestr2 = [formater stringFromDate:date1];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,datestr2);<span class="comment">//    结果：2015年12月30日 星期三</span></span><br><span class="line">    <span class="comment">//  设置系统时间样式</span></span><br><span class="line">    [formater setTimeStyle:(<span class="built_in">NSDateFormatterFullStyle</span>)];</span><br><span class="line">    <span class="built_in">NSString</span> *datestr3 = [formater stringFromDate:date1];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,datestr3);<span class="comment">//    结果：2015年12月30日 星期三 中国标准时间下午9:46:40</span></span><br><span class="line">    <span class="comment">//  设置对应的时区信息</span></span><br><span class="line">    [formater setTimeZone:[<span class="built_in">NSTimeZone</span> timeZoneWithName:<span class="string">@"America/Santiago"</span>]];</span><br><span class="line">    <span class="built_in">NSString</span> *datestr4 = [formater stringFromDate:date6];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@ "</span>,datestr4);<span class="comment">//   结果：2015年12月30日 星期三 智利标准时间上午10:46:40</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>C语言中，字符串是由char（ASCII码）字符组成，OC中，字符串是由uichar（Unicode）字符组成。</p>
<h3 id="NSString"><a href="#NSString" class="headerlink" title="NSString"></a>NSString</h3><p>&lt; 代码示例 &gt;</p>
<p><em>main.m</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - 字符串创建 -</span></span><br><span class="line"><span class="keyword">void</span> test1()&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  语法糖，不需要管理内存</span></span><br><span class="line">    <span class="built_in">NSString</span> *str2=<span class="string">@"OC string"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  根据指定格式创建字符串</span></span><br><span class="line">    <span class="built_in">NSString</span> *str3 = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"age is %i,name is %.2f"</span>,<span class="number">19</span>,<span class="number">1.72</span>f];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  这是C语言创建的字符串</span></span><br><span class="line">    <span class="keyword">char</span> *str1=<span class="string">"C string"</span>;</span><br><span class="line">    <span class="comment">//  C语言的字符串转换为OC字符串1</span></span><br><span class="line">    <span class="built_in">NSString</span> *str4 = [<span class="built_in">NSString</span> stringWithUTF8String:<span class="string">"C string"</span>];</span><br><span class="line">    <span class="comment">//  C语言的字符串转换为OC字符串2</span></span><br><span class="line">    <span class="built_in">NSString</span> *str5 = [<span class="built_in">NSString</span> stringWithCString:str1 encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  根据指定路径的文件内容创建字符串对象</span></span><br><span class="line">    <span class="built_in">NSString</span> *str6 = [<span class="built_in">NSString</span> stringWithContentsOfFile:<span class="string">@"/Users/lanouhn/Desktop/test.txt"</span> encoding:<span class="built_in">NSUTF8StringEncoding</span> error:<span class="literal">nil</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,str6);<span class="comment">//    结果：桌面上的txt文件</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - 字符串大小写转化 -</span></span><br><span class="line"><span class="keyword">void</span> test2()&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  转化成大写</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"\"Hello world!\" to upper is %@"</span>,[<span class="string">@"Hello world!"</span> uppercaseString]);<span class="comment">//  结果："Hello world!" to upper is HELLO WORLD!</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  转化成小写</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"\"Hello world!\" to lowwer is %@"</span>,[<span class="string">@"Hello world!"</span> lowercaseString]);<span class="comment">// 结果："Hello world!" to lowwer is hello world!</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  首字母大写，其他字母小写</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"\"Hello world!\" to capitalize is %@"</span>,[<span class="string">@"Hello world!"</span> capitalizedString]);<span class="comment">//   结果："Hello world!" to capitalize is Hello World!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - 字符串比较及判断 -</span></span><br><span class="line"><span class="keyword">void</span> test3()&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  比较：比较两个字符串的大小（如果是[@"abc" caseInsensitiveCompare:@"aBc"]则忽略大小写比较）</span></span><br><span class="line">    <span class="built_in">NSComparisonResult</span> result2= [<span class="string">@"abc"</span> compare:<span class="string">@"aBc"</span>];</span><br><span class="line">    <span class="keyword">if</span>(result2 == <span class="built_in">NSOrderedAscending</span>)&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"left&lt;right."</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(result2==<span class="built_in">NSOrderedDescending</span>)&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"left&gt;right."</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(result2==<span class="built_in">NSOrderedSame</span>)&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"left=right."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//结果：left&gt;right.</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  判断：判断两个字符串是否相同</span></span><br><span class="line">    <span class="built_in">BOOL</span> result= [<span class="string">@"abc"</span> isEqualToString:<span class="string">@"aBc"</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%i"</span>,result);<span class="comment">//  结果：0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  判断：判断一个字符串是否拥有前缀字符串</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"has prefix ab? %i"</span>,[<span class="string">@"abcdef"</span> hasPrefix:<span class="string">@"ab"</span>]);<span class="comment">//  结果：has prefix ab? 1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  判断：判断一个字符串是否拥有后缀</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"has suffix ab? %i"</span>,[<span class="string">@"abcdef"</span> hasSuffix:<span class="string">@"ef"</span>]);<span class="comment">//  结果：has suffix ab? 1</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - 字符串分割及拼接 -</span></span><br><span class="line"><span class="keyword">void</span> test4()&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  分割：从第三个索引开始（包括第三个索引对应的字符）截取到最后一位（字符串中一个字符拥有一个下标，从0下标开始）</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[<span class="string">@"abcdef"</span> substringFromIndex:<span class="number">3</span>]);<span class="comment">//  结果：def</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  分割：从0开始截取到第三个索引（不包括第三个索引对应的字符）</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[<span class="string">@"abcdef"</span> substringToIndex:<span class="number">3</span>]);<span class="comment">//  结果：abc</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  分割：从下标为2（包括2）的字符往后取3个字符</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[<span class="string">@"abcdef"</span> substringWithRange:<span class="built_in">NSMakeRange</span>(<span class="number">2</span>, <span class="number">3</span>)]);<span class="comment">//    结果：cde</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  分割：获取在字符串A中字符串B的位置（注意如果遇到cde则不再往后面搜索,如果从后面搜索或其他搜索方式可以设置第二个options参数）</span></span><br><span class="line">    <span class="built_in">NSRange</span> range=[<span class="string">@"abcdefabcdef"</span> rangeOfString:<span class="string">@"cde"</span>];</span><br><span class="line">    <span class="keyword">if</span>(range.location==<span class="built_in">NSNotFound</span>)&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"not found."</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"range is %@"</span>,<span class="built_in">NSStringFromRange</span>(range));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  结果：range is &#123;2, 3&#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  分割：以"."为分割点把字符串分割几串，并返回一个数组</span></span><br><span class="line">    <span class="built_in">NSArray</span> *array=[<span class="string">@"12.abcd.3a"</span> componentsSeparatedByString:<span class="string">@"."</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,array);</span><br><span class="line">    <span class="comment">/*结果：</span><br><span class="line">     (</span><br><span class="line">     12,</span><br><span class="line">     abcd,</span><br><span class="line">     3a</span><br><span class="line">     )</span><br><span class="line">     */</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  拼接：根据给定的参数字符串拼接并产生新的字符串，不改变原有字符串（因为原字符串是不可变字符串）</span></span><br><span class="line">    <span class="built_in">NSString</span> *newString1 = [<span class="string">@"手机号："</span> stringByAppendingString:<span class="string">@"10086"</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,newString1);<span class="comment">//  结果：手机号：10086</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  拼接：根据给定的格式串以及参数拼接产生新的字符串</span></span><br><span class="line">    <span class="built_in">NSString</span> *newString2 = [<span class="string">@"小明"</span> stringByAppendingFormat:<span class="string">@"%@%@"</span>,<span class="string">@"住在"</span>,@<span class="number">504</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,newString2);<span class="comment">//  结果：小明住在504</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  拼接：路径拼接</span></span><br><span class="line">    <span class="built_in">NSString</span> *newString3 = [<span class="string">@"E盘"</span> stringByAppendingPathComponent:<span class="string">@"苍井空"</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,newString3);<span class="comment">//  结果：E盘/苍井空</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - 其他操作 -</span></span><br><span class="line"><span class="keyword">void</span> test5()&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  类型转换（必须是纯数字的字符串，如果第一个是字母则输出零，如果数字后面有字母则遇到第一个字母停止转换）</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%i"</span>,[<span class="string">@"12"</span> intValue]);<span class="comment">//    结果：12</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  字符串长度注意不是字节数</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%zi"</span>,[<span class="string">@"hello world,世界你好！"</span> length]);<span class="comment">//  结果：17</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  取出指定位置的字符</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%c"</span>,[<span class="string">@"abc"</span> characterAtIndex:<span class="number">0</span>]);<span class="comment">// 结果：a</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  转换为C语言字符串</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *s=[<span class="string">@"abc"</span> UTF8String];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>,s);<span class="comment">//   结果：abc</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  字符串的替换：通过给定的第二个字符串替换str8中当前存在的字符串（把"shuaige"替换成了"SB"）</span></span><br><span class="line">    <span class="built_in">NSString</span> *newString = [<span class="string">@"shuaige is me"</span> stringByReplacingOccurrencesOfString:<span class="string">@"shuaige"</span> withString:<span class="string">@"SB"</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,newString);<span class="comment">//   结果：SB is me</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    test1();</span><br><span class="line">    test2();</span><br><span class="line">    test3();</span><br><span class="line">    test4();</span><br><span class="line">    test5();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="NSMutableString"><a href="#NSMutableString" class="headerlink" title="NSMutableString"></a>NSMutableString</h3><p>NSMutableString，它是NSString的子类，可变字符串的初始化不能用语法糖：</p>
<p>&lt; 代码示例 &gt;</p>
<p><em>main.m</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  字符串的创建1：注意虽然initWithCapacity分配字符串大小，但是不是绝对的不可以超过此范围，声明此变量对性能有好处</span></span><br><span class="line">    <span class="built_in">NSMutableString</span> *str1= [[<span class="built_in">NSMutableString</span> alloc] initWithCapacity:<span class="number">10</span>];</span><br><span class="line">    <span class="comment">//  设置字符串</span></span><br><span class="line">    [str1 setString:<span class="string">@"hello"</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,str1);<span class="comment">//    结果：hello</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  字符串的创建2</span></span><br><span class="line">    <span class="built_in">NSMutableString</span> *str2 =  [<span class="built_in">NSMutableString</span> string];</span><br><span class="line">    <span class="comment">//  设置字符串</span></span><br><span class="line">    str2.string = <span class="string">@"world"</span>;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,str2);<span class="comment">//    结果：world</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  追加字符串</span></span><br><span class="line">    [str1 appendString:str2];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,str1);<span class="comment">//    结果：helloworld!</span></span><br><span class="line">    </span><br><span class="line">    [str1 appendFormat:<span class="string">@"我的年龄是%i。dear,I love you."</span>,<span class="number">18</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,str1);<span class="comment">//    结果：hello,world!我的年龄是18。dear,I love you.</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  替换字符串：根据给定的字符串替换指定范围的字符们</span></span><br><span class="line">    <span class="built_in">NSRange</span> range=[str1 rangeOfString:<span class="string">@"dear"</span>];</span><br><span class="line">    [str1 replaceCharactersInRange:range withString:<span class="string">@"Honey"</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,str1);<span class="comment">//    结果：hello,world!我的年龄是18。Honey,I love you.</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  插入字符串</span></span><br><span class="line">    [str1 insertString:<span class="string">@"My name is Kenshin."</span> atIndex:<span class="number">12</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,str1);<span class="comment">//    结果：hello,world!My name is Kenshin.我的年龄是18。Honey,I love you.</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  删除字符串</span></span><br><span class="line">    [str1 deleteCharactersInRange:[str1 rangeOfString:<span class="string">@"My name is Kenshin."</span>]];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,str1);<span class="comment">//    结果：hello,world!我的年龄是18。Honey,I love you.</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  将不可变字符串转为可变字符串</span></span><br><span class="line">    <span class="built_in">NSMutableString</span> *str3 = [<span class="built_in">NSMutableString</span> stringWithString:str1];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="拓展：文件操作"><a href="#拓展：文件操作" class="headerlink" title="拓展：文件操作"></a>拓展：文件操作</h3><p>在OC中路径、文件读写等操作是利用字符串来完成的，这里通过几个简单的例子来演示（首先在桌面上新建一个test.txt文件，里面存储的内容是”hello world,世界你好！”）：</p>
<p>&lt; 代码示例 &gt;</p>
<p><em>main.m</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> test1()&#123;</span><br><span class="line">    <span class="comment">//读取文件内容</span></span><br><span class="line">    <span class="built_in">NSString</span> *path=<span class="string">@"/Users/kenshincui/Desktop/test.txt"</span>;</span><br><span class="line">    <span class="built_in">NSString</span> *str1=[<span class="built_in">NSString</span> stringWithContentsOfFile:path encoding:<span class="built_in">NSUTF8StringEncoding</span> error:<span class="literal">nil</span>];</span><br><span class="line">    <span class="comment">//注意上面也可以使用gb2312 gbk等,例如kCFStringEncodingGB_18030_2000，但是需要用CFStringConvertEncodingToNSStringEncoding转换</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"str1 is %@"</span>,str1);</span><br><span class="line">    <span class="comment">//结果：str1 is hello world,世界你好！</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//上面我们看到了读取文件，但并没有处理错误,当然在ObjC中可以@try @catch @finnally但通常我们并不那么做</span></span><br><span class="line">    <span class="comment">//由于我们的test.txt中有中文，所以使用下面的编码读取会报错，下面的代码演示了错误获取的过程</span></span><br><span class="line">    <span class="built_in">NSError</span> *error;</span><br><span class="line">    <span class="built_in">NSString</span> *str2=[<span class="built_in">NSString</span> stringWithContentsOfFile:path encoding:k<span class="built_in">CFStringEncodingGB_18030_2000</span> error:&amp;error];<span class="comment">//注意这句话中的error变量是**error，就是指针的指针那就是指针的地址，由于error就是一个指针此处也就是error的地址&amp;error，具体原因见下面补充</span></span><br><span class="line">    <span class="keyword">if</span>(error)&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"read error ,the error is %@"</span>,error);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"read success,the file content is %@"</span>,str2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//结果：read error ,the error is Error Domain=NSCocoaErrorDomain Code=261 "The file couldn’t be opened using the specified text encoding." UserInfo=0x100109620 &#123;NSFilePath=/Users/kenshincui/Desktop/test.txt, NSStringEncoding=1586&#125;</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//读取文件内容还有一种方式就是利用URl，它除了可以读取本地文件还可以读取网络文件</span></span><br><span class="line">    <span class="comment">//NSURL *url=[NSURL URLWithString:@"file:///Users/kenshincui/Desktop/test.txt"];</span></span><br><span class="line">    <span class="built_in">NSURL</span> *url=[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://www.apple.com"</span>];</span><br><span class="line">    <span class="built_in">NSString</span> *str3=[<span class="built_in">NSString</span> stringWithContentsOfURL:url encoding:<span class="built_in">NSUTF8StringEncoding</span> error:<span class="literal">nil</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"str3 is %@"</span>,str3);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> test2()&#123;</span><br><span class="line">    <span class="comment">//下面是文件写入</span></span><br><span class="line">    <span class="built_in">NSString</span> *path1=<span class="string">@"/Users/kenshincui/Desktop/test2.txt"</span>;</span><br><span class="line">    <span class="built_in">NSError</span> *error1;</span><br><span class="line">    <span class="built_in">NSString</span> *str11=<span class="string">@"hello world,世界你好！"</span>;</span><br><span class="line">    [str11 writeToFile:path1 atomically:<span class="literal">YES</span> encoding:<span class="built_in">NSUTF8StringEncoding</span> error:&amp;error1];<span class="comment">//automically代表一次性写入，如果写到中间出错了最后就全部不写入</span></span><br><span class="line">    <span class="keyword">if</span>(error1)&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"write fail,the error is %@"</span>,[error1 localizedDescription]);<span class="comment">//调用localizedDescription是只打印关键错误信息</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"write success!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//结果：write success!</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//路径操作</span></span><br><span class="line"><span class="keyword">void</span> test3()&#123;</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *marray=[<span class="built_in">NSMutableArray</span> array];<span class="comment">//可变数组</span></span><br><span class="line">    [marray addObject:<span class="string">@"Users"</span>];</span><br><span class="line">    [marray addObject:<span class="string">@"KenshinCui"</span>];</span><br><span class="line">    [marray addObject:<span class="string">@"Desktop"</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSString</span> *path=[<span class="built_in">NSString</span> pathWithComponents:marray];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,path);<span class="comment">//字符串拼接成路径</span></span><br><span class="line">    <span class="comment">//结果：Users/KenshinCui/Desktop</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[path pathComponents]);<span class="comment">//路径分割成数组</span></span><br><span class="line">    <span class="comment">/*结果： </span><br><span class="line">     (</span><br><span class="line">        Users,</span><br><span class="line">        KenshinCui,</span><br><span class="line">        Desktop</span><br><span class="line">    )</span><br><span class="line">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%i"</span>,[path isAbsolutePath]);<span class="comment">//是否绝对路径（其实就是看字符串是否以“/”开头）</span></span><br><span class="line">    <span class="comment">//结果：0</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[path lastPathComponent]);<span class="comment">//取得最后一个目录</span></span><br><span class="line">    <span class="comment">//结果：Desktop</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[path stringByDeletingLastPathComponent]);<span class="comment">//删除最后一个目录，注意path本身是常量不会被修改,只是返回一个新字符串</span></span><br><span class="line">    <span class="comment">//结果：Users/KenshinCui</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[path stringByAppendingPathComponent:<span class="string">@"Documents"</span>]);<span class="comment">//路径拼接</span></span><br><span class="line">    <span class="comment">//结果：Users/KenshinCui/Desktop/Documents</span></span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">//扩展名操作</span></span><br><span class="line"><span class="keyword">void</span> test4()&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *path=<span class="string">@"Users/KenshinCui/Desktop/test.txt"</span>;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[path pathExtension]);<span class="comment">//取得扩展名，注意ObjC中扩展名不包括"."</span></span><br><span class="line">    <span class="comment">//结果：txt</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[path stringByDeletingPathExtension]);<span class="comment">//删除扩展名，注意包含"."</span></span><br><span class="line">    <span class="comment">//结果：Users/KenshinCui/Desktop/test</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[<span class="string">@"Users/KenshinCui/Desktop/test"</span> stringByAppendingPathExtension:<span class="string">@"mp3"</span>]);<span class="comment">//添加扩展名</span></span><br><span class="line">    <span class="comment">//结果：Users/KenshinCui/Desktop/test.mp3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    test1();</span><br><span class="line">    test2();</span><br><span class="line">    test3();</span><br><span class="line">    test4();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组是有序集合，只能存放对象，数组有下标（index）的概念，靠index来索引元素，下标从0开始。</p>
<h3 id="NSArray"><a href="#NSArray" class="headerlink" title="NSArray"></a>NSArray</h3><p>&lt; 代码示例 &gt;</p>
<p><em>main.m</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - 数组基础 -</span></span><br><span class="line"><span class="keyword">void</span> test1()&#123;</span><br><span class="line">    <span class="comment">//  创建不可变数组1：可以写多个，nil表示参数列表结束，是个结束标志，不能省</span></span><br><span class="line">    <span class="built_in">NSArray</span> *array1 = [<span class="built_in">NSArray</span> arrayWithObjects:<span class="string">@"1"</span>,@<span class="number">2</span>,<span class="string">@"贺贺"</span>, <span class="literal">nil</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,array1);</span><br><span class="line">    <span class="comment">/*  结果：(</span><br><span class="line">     1,</span><br><span class="line">     2,</span><br><span class="line">     "\U8d3a\U8d3a"</span><br><span class="line">     )*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  创建不可变数组2：语法糖</span></span><br><span class="line">    <span class="built_in">NSArray</span> *array2 = @[<span class="string">@"1"</span>,@<span class="number">2</span>,<span class="string">@"^_^"</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,array2);</span><br><span class="line">    <span class="comment">/*  结果：(</span><br><span class="line">     1,</span><br><span class="line">     2,</span><br><span class="line">     "^_^"</span><br><span class="line">     )*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  获取数组元素的个数</span></span><br><span class="line">    <span class="built_in">NSInteger</span> count = [array2 count];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%ld"</span>,count);<span class="comment">//  结果：3</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  通过对象去查找他在数组中的下标</span></span><br><span class="line">    <span class="built_in">NSInteger</span> index = [array2 indexOfObject:@<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%ld"</span>,index);<span class="comment">//  结果：1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  通过对象的下标去查找他在数组中的对象</span></span><br><span class="line">    <span class="keyword">id</span> a  = [array1 objectAtIndex:<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,a);<span class="comment">//   结果：贺贺</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - 数组的遍历 -</span></span><br><span class="line"><span class="keyword">void</span> test2()&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSObject</span> *obj=[[<span class="built_in">NSObject</span> alloc]init];</span><br><span class="line">    <span class="built_in">NSArray</span> *array=[[<span class="built_in">NSArray</span> alloc] initWithObjects:<span class="string">@"abc"</span>,obj,<span class="string">@"cde"</span>,<span class="string">@"opq"</span>,@<span class="number">25</span>, <span class="literal">nil</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  方法1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,len = array.count;i&lt;len;++i)&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"method1:index %i is %@"</span>,i,[array objectAtIndex:i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*结果：</span><br><span class="line">     method1:index 0 is abc</span><br><span class="line">     method1:index 1 is &lt;NSObject: 0x100106de0&gt;</span><br><span class="line">     method1:index 2 is cde</span><br><span class="line">     method1:index 3 is opq</span><br><span class="line">     method1:index 4 is 25</span><br><span class="line">     */</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//方法2</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">id</span> obj <span class="keyword">in</span> array)&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"method2:index %zi is %@"</span>,[array indexOfObject:obj],obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*结果：</span><br><span class="line">     method2:index 0 is abc</span><br><span class="line">     method2:index 1 is &lt;NSObject: 0x100602f00&gt;</span><br><span class="line">     method2:index 2 is cde</span><br><span class="line">     method2:index 3 is opq</span><br><span class="line">     method2:index 4 is 25</span><br><span class="line">     */</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//方法3,利用代码块方法</span></span><br><span class="line">    [array enumerateObjectsUsingBlock:^(<span class="keyword">id</span> obj, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"method3:index %zi is %@"</span>,idx,obj);</span><br><span class="line">        <span class="keyword">if</span>(idx==<span class="number">2</span>)&#123;<span class="comment">//当idx=2时设置*stop为YES停止遍历</span></span><br><span class="line">            *stop=<span class="literal">YES</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="comment">/*结果：</span><br><span class="line">     method3:index 0 is abc</span><br><span class="line">     method3:index 1 is &lt;NSObject: 0x100106de0&gt;</span><br><span class="line">     method3:index 2 is cde</span><br><span class="line">     */</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//方法4，利用迭代器</span></span><br><span class="line">    <span class="comment">//NSEnumerator *enumerator= [array objectEnumerator];//获得一个迭代器</span></span><br><span class="line">    <span class="built_in">NSEnumerator</span> *enumerator=[array reverseObjectEnumerator];<span class="comment">//获取一个反向迭代器</span></span><br><span class="line">    <span class="comment">//NSLog(@"all:%@",[enumerator allObjects]);//获取所有迭代对象，注意调用完此方法迭代器就遍历完了，下面的nextObject就没有值了</span></span><br><span class="line">    <span class="keyword">id</span> obj2=<span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">while</span> (obj2=[enumerator nextObject]) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"method4:%@"</span>,obj2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*结果：</span><br><span class="line">     method4:25</span><br><span class="line">     method4:opq</span><br><span class="line">     method4:cde</span><br><span class="line">     method4:&lt;NSObject: 0x100106de0&gt;</span><br><span class="line">     method4:abc</span><br><span class="line">     */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - 数组派生出新的数组 -</span></span><br><span class="line"><span class="keyword">void</span> test3()&#123;</span><br><span class="line">    <span class="built_in">NSArray</span> *array=[<span class="built_in">NSArray</span> arrayWithObjects:<span class="string">@"1"</span>,<span class="string">@"2"</span>,<span class="string">@"3"</span>, <span class="literal">nil</span>];</span><br><span class="line">    <span class="built_in">NSArray</span> *array2=[array arrayByAddingObject:<span class="string">@"4"</span>];<span class="comment">//注意此时array并没有变</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,array2);</span><br><span class="line">    <span class="comment">/*结果：</span><br><span class="line">     (</span><br><span class="line">     1,</span><br><span class="line">     2,</span><br><span class="line">     3,</span><br><span class="line">     4</span><br><span class="line">     )</span><br><span class="line">     */</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[array2 arrayByAddingObjectsFromArray:[<span class="built_in">NSArray</span> arrayWithObjects:<span class="string">@"5"</span>,<span class="string">@"6"</span>, <span class="literal">nil</span>]]);<span class="comment">//追加形成新的数组</span></span><br><span class="line">    <span class="comment">/*结果：</span><br><span class="line">     (</span><br><span class="line">     1,</span><br><span class="line">     2,</span><br><span class="line">     3,</span><br><span class="line">     4,</span><br><span class="line">     5,</span><br><span class="line">     6</span><br><span class="line">     )</span><br><span class="line">     */</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[array2 subarrayWithRange:<span class="built_in">NSMakeRange</span>(<span class="number">1</span>, <span class="number">3</span>)]);<span class="comment">//根据一定范围取得生成一个新的数组</span></span><br><span class="line">    <span class="comment">/*结果：</span><br><span class="line">     (</span><br><span class="line">     2,</span><br><span class="line">     3,</span><br><span class="line">     4</span><br><span class="line">     )</span><br><span class="line">     */</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[array componentsJoinedByString:<span class="string">@","</span>]);<span class="comment">//数组连接，形成一个字符串</span></span><br><span class="line">    <span class="comment">//结果：1,2,3</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//读写文件</span></span><br><span class="line">    <span class="built_in">NSString</span> *path=<span class="string">@"/Users/KenshinCui/Desktop/array.xml"</span>;</span><br><span class="line">    [array writeToFile:path atomically:<span class="literal">YES</span>];</span><br><span class="line">    <span class="built_in">NSArray</span> *array3=[<span class="built_in">NSArray</span> arrayWithContentsOfFile:path];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,array3);</span><br><span class="line">    <span class="comment">/*结果：</span><br><span class="line">     (</span><br><span class="line">     1,</span><br><span class="line">     2,</span><br><span class="line">     3</span><br><span class="line">     )</span><br><span class="line">     */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - 数组排序 -</span></span><br><span class="line"><span class="keyword">void</span> test4()&#123;</span><br><span class="line">    <span class="comment">//方法1：使用自带的比较器</span></span><br><span class="line">    <span class="built_in">NSArray</span> *array=[<span class="built_in">NSArray</span> arrayWithObjects:<span class="string">@"3"</span>,<span class="string">@"1"</span>,<span class="string">@"2"</span>, <span class="literal">nil</span>];</span><br><span class="line">    <span class="built_in">NSArray</span> *array2= [array sortedArrayUsingSelector:<span class="keyword">@selector</span>(compare:)];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,array2);</span><br><span class="line">    <span class="comment">/*结果：</span><br><span class="line">     (</span><br><span class="line">     1,</span><br><span class="line">     2,</span><br><span class="line">     3</span><br><span class="line">     )</span><br><span class="line">     */</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//方法2：使用代码块</span></span><br><span class="line">    <span class="built_in">NSArray</span> *array3 = [array sortedArrayUsingComparator:^<span class="built_in">NSComparisonResult</span>(<span class="keyword">id</span>  _Nonnull obj1, <span class="keyword">id</span>  _Nonnull obj2) &#123;</span><br><span class="line">        <span class="keyword">return</span> [obj2 compare:obj1];<span class="comment">//降序</span></span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,array3);</span><br><span class="line">    <span class="comment">/*结果：</span><br><span class="line">     (</span><br><span class="line">     "name=Rosa",</span><br><span class="line">     "name=Kenshin",</span><br><span class="line">     "name=Kaoru"</span><br><span class="line">     )</span><br><span class="line">     */</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    test1();</span><br><span class="line">    test2();</span><br><span class="line">    test3();</span><br><span class="line">    test4();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="NSMutableArray"><a href="#NSMutableArray" class="headerlink" title="NSMutableArray"></a>NSMutableArray</h3><p>&lt; 代码示例 &gt;</p>
<p><em>main.m</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  将不可变数组转为可变数组</span></span><br><span class="line">        <span class="built_in">NSArray</span> *array1 = @[@<span class="number">1</span>,@<span class="number">2</span>];</span><br><span class="line">        <span class="built_in">NSMutableArray</span> *mutableArray2 = [<span class="built_in">NSMutableArray</span> arrayWithArray:array1];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,mutableArray2);</span><br><span class="line">    <span class="comment">/*  结果：(</span><br><span class="line">     1,</span><br><span class="line">     2</span><br><span class="line">     )</span><br><span class="line">     */</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment">//  添加元素(对象):在最后面添加</span></span><br><span class="line">        [mutableArray2 addObject:@<span class="number">33</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,mutableArray2);</span><br><span class="line">    <span class="comment">/*  结果：(</span><br><span class="line">     1,</span><br><span class="line">     2,</span><br><span class="line">     33</span><br><span class="line">     )</span><br><span class="line">     */</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment">//  插入元素(对象)</span></span><br><span class="line">        [mutableArray2 insertObject:<span class="string">@"123"</span> atIndex:<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,mutableArray2);</span><br><span class="line">    <span class="comment">/*  结果：(</span><br><span class="line">     1,</span><br><span class="line">     123,</span><br><span class="line">     2,</span><br><span class="line">     33</span><br><span class="line">     )</span><br><span class="line">     */</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment">//  替换一个已有元素(对象)</span></span><br><span class="line">        [mutableArray2 replaceObjectAtIndex:<span class="number">0</span> withObject:<span class="string">@"heihei"</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,mutableArray2);</span><br><span class="line">    <span class="comment">/*  结果：(</span><br><span class="line">     heihei,</span><br><span class="line">     123,</span><br><span class="line">     2,</span><br><span class="line">     33</span><br><span class="line">     )</span><br><span class="line">     */</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment">//  交换两个对应下标的元素(对象)的位置</span></span><br><span class="line">        [mutableArray2 exchangeObjectAtIndex:<span class="number">1</span> withObjectAtIndex:<span class="number">2</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,mutableArray2);</span><br><span class="line">    <span class="comment">/*  结果：(</span><br><span class="line">     heihei,</span><br><span class="line">     2,</span><br><span class="line">     123,</span><br><span class="line">     33</span><br><span class="line">     )</span><br><span class="line">     */</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment">//  删除最后一个元素(对象)</span></span><br><span class="line">        [mutableArray2 removeLastObject];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,mutableArray2);</span><br><span class="line">    <span class="comment">/*  结果：(</span><br><span class="line">     heihei,</span><br><span class="line">     2,</span><br><span class="line">     123</span><br><span class="line">     )</span><br><span class="line">     */</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment">//  删除指定下标的元素(对象)</span></span><br><span class="line">        [mutableArray2 removeObjectAtIndex:<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,mutableArray2);</span><br><span class="line">    <span class="comment">/*  结果：(</span><br><span class="line">     2,</span><br><span class="line">     123</span><br><span class="line">     )</span><br><span class="line">     */</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment">//  删除数组所有元素(对象)</span></span><br><span class="line">        [mutableArray2 removeAllObjects];<span class="comment">//数组元素删完了，不过数组还在</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,mutableArray2);</span><br><span class="line">    <span class="comment">/*  结果：(</span><br><span class="line">     )</span><br><span class="line">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数组的三种排序"><a href="#数组的三种排序" class="headerlink" title="数组的三种排序"></a>数组的三种排序</h3><h4 id="简单排序"><a href="#简单排序" class="headerlink" title="简单排序"></a>简单排序</h4><p>不可变数组的排序（不可变数组中的只有<code>字符串</code>或<code>数值类对象</code>）：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *array = [<span class="built_in">NSArray</span> arrayWithObjects:<span class="string">@"abc"</span>,<span class="string">@"456"</span>,<span class="string">@"123"</span>,<span class="string">@"789"</span>,<span class="string">@"ef"</span>, <span class="literal">nil</span>];</span><br><span class="line"><span class="comment">//  返回值是不可变数组</span></span><br><span class="line"><span class="built_in">NSArray</span> *sortedArray = [array sortedArrayUsingSelector:<span class="keyword">@selector</span>(compare:)];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"排序后:%@"</span>,sortedArray);</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2015-04-29 11:59:01.403 11[1424:96014] 排序后:( 123, 456, 789, abc, ef )</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<p>可变数组的排序（可变数组中的所有<code>字符串</code>或<code>数值类对象</code>）：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSMutableArray</span> *array = [<span class="built_in">NSMutableArray</span> arrayWithObjects:<span class="string">@"abc"</span>,<span class="string">@"456"</span>,<span class="string">@"123"</span>,<span class="string">@"789"</span>,<span class="string">@"ef"</span>, <span class="literal">nil</span>]; </span><br><span class="line">[array sortUsingSelector:<span class="keyword">@selector</span>(compare:)]; </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"排序后:%@“,array);</span></span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2015-04-29 11:59:01.403 11[1424:96014] 排序后:( 123, 456, 789, abc, ef )</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<p>当然，除了利用字符串自带的compare:方法，也可以自己写compare:方法，进行对象的比较。</p>
<h4 id="利用block"><a href="#利用block" class="headerlink" title="利用block"></a>利用block</h4><p>不可变数组的排序：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  1.第一种排序（降序）</span></span><br><span class="line"><span class="built_in">NSComparator</span> sortBlock = ^(<span class="keyword">id</span> obj1,<span class="keyword">id</span> obj2)&#123;</span><br><span class="line">    <span class="keyword">return</span> [obj2 compare: obj1];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//  在这一行调用了sortBlock比较器,在此之前，sortBlock比较器只是被编译了。</span></span><br><span class="line"><span class="built_in">NSArray</span> *resultArray1 = [array sortedArrayUsingComparator:sortBlock];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,resultArray1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//  2.第二种排序（升序）</span></span><br><span class="line"><span class="built_in">NSArray</span> *resultArray2 = [array sortedArrayUsingComparator:^<span class="built_in">NSComparisonResult</span>(<span class="keyword">id</span> obj1, <span class="keyword">id</span> obj2) &#123;</span><br><span class="line">    <span class="keyword">return</span> [obj1 compare:obj2];</span><br><span class="line">&#125;];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,resultArray2);</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">2016-01-01 13:33:30.626 OC10[30490:316048] (</span><br><span class="line">    16,</span><br><span class="line">    12,</span><br><span class="line">    10,</span><br><span class="line">    8,</span><br><span class="line">    1</span><br><span class="line">)</span><br><span class="line">2016-01-01 13:33:30.629 OC10[30490:316048] (</span><br><span class="line">    1,</span><br><span class="line">    8,</span><br><span class="line">    10,</span><br><span class="line">    12,</span><br><span class="line">    16</span><br><span class="line">)</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<p>可变数组的排序：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSMutableArray</span> *array = [<span class="built_in">NSMutableArray</span> arrayWithObjects:@<span class="number">1</span>,@<span class="number">16</span>,@<span class="number">8</span>,@<span class="number">10</span>,@<span class="number">12</span>,<span class="literal">nil</span>];</span><br><span class="line">    <span class="comment">//  1.第一种排序（降序）</span></span><br><span class="line">    <span class="built_in">NSComparator</span> sortBlock = ^(<span class="keyword">id</span> obj1,<span class="keyword">id</span> obj2)&#123;</span><br><span class="line">        <span class="keyword">return</span> [obj2 compare: obj1];</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//  在这一行调用了sortBlock比较器,在此之前，sortBlock比较器只是被编译了。</span></span><br><span class="line">    [array sortUsingComparator:sortBlock];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,array);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  2.第二种排序（升序）</span></span><br><span class="line">    [array sortUsingComparator:^<span class="built_in">NSComparisonResult</span>(<span class="keyword">id</span>  _Nonnull obj1, <span class="keyword">id</span>  _Nonnull obj2) &#123;</span><br><span class="line">        <span class="keyword">return</span> [obj1 compare:obj2];</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,array);</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span><span class="number">-01</span><span class="number">-01</span> <span class="number">13</span>:<span class="number">41</span>:<span class="number">15.184</span> OC10[<span class="number">30942</span>:<span class="number">320847</span>] (</span><br><span class="line">    <span class="number">16</span>,</span><br><span class="line">    <span class="number">12</span>,</span><br><span class="line">    <span class="number">10</span>,</span><br><span class="line">    <span class="number">8</span>,</span><br><span class="line">    <span class="number">1</span></span><br><span class="line">)</span><br><span class="line"><span class="number">2016</span><span class="number">-01</span><span class="number">-01</span> <span class="number">13</span>:<span class="number">41</span>:<span class="number">15.185</span> OC10[<span class="number">30942</span>:<span class="number">320847</span>] (</span><br><span class="line">    <span class="number">1</span>,</span><br><span class="line">    <span class="number">8</span>,</span><br><span class="line">    <span class="number">10</span>,</span><br><span class="line">    <span class="number">12</span>,</span><br><span class="line">    <span class="number">16</span></span><br><span class="line">)</span><br><span class="line">Program ended with exit code: <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h4 id="高级排序"><a href="#高级排序" class="headerlink" title="高级排序"></a>高级排序</h4><p>如果是这样一种情况呢？Person类里有另外一个类的变量，比如说Person类除了name，age变量，还有一辆车Car类型，Car类里有个name属性。对Person对象进行排序，有这样的要求：按照Car的name排序，如果是同一辆车，也就是Car的name相同，那么再按照年龄进行排序，如果年龄也相同，最后按照Person的name进行排序。</p>
<p>不可变数组的排序：</p>
<p>&lt; 代码示例 &gt;</p>
<p><em>Person.h</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Car.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>) Car *car;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">assign</span>) <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">+ (Person *)personWithAge:(<span class="keyword">int</span>)age</span><br><span class="line">                     Name:(<span class="built_in">NSString</span> *)name</span><br><span class="line">                      Car:(Car *)car;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>Person.m</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Person.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line">+ (Person *)personWithAge:(<span class="keyword">int</span>)age Name:(<span class="built_in">NSString</span> *)name Car:(Car *)car&#123;</span><br><span class="line">    Person *person =[[Person alloc] init];</span><br><span class="line">    person.age = age;</span><br><span class="line">    person.car = car;</span><br><span class="line">    person.name = name;</span><br><span class="line">    <span class="keyword">return</span> person;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)description&#123;</span><br><span class="line">     <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"age is %zi , name is %@, car is %@"</span>,_age,_name,_car.name];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>Car.h</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Car</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"></span><br><span class="line">+(Car *)carWithName:(<span class="built_in">NSString</span> *)name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>Car.m</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Car.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Car</span></span></span><br><span class="line"></span><br><span class="line">+ (Car *)carWithName:(<span class="built_in">NSString</span> *)name&#123;</span><br><span class="line">    Car *car = [[Car alloc] init];</span><br><span class="line">    car.name = name;</span><br><span class="line">    <span class="keyword">return</span> car;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>main.m</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Person.h"</span></span></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  首先来3辆车，分别是奥迪、劳斯莱斯、宝马</span></span><br><span class="line">    Car *car1 = [Car carWithName:<span class="string">@"Audio"</span>];</span><br><span class="line">    Car *car2 = [Car carWithName:<span class="string">@"Rolls-Royce"</span>];</span><br><span class="line">    Car *car3 = [Car carWithName:<span class="string">@"BMW"</span>];</span><br><span class="line">    <span class="comment">//  再来5个Person，每人送辆车，分别为car2、car1、car1、car3、car2</span></span><br><span class="line">    Person *p1 = [Person personWithAge:<span class="number">21</span> Name:<span class="string">@"A"</span> Car:car2];</span><br><span class="line">    Person *p2 = [Person personWithAge:<span class="number">23</span> Name:<span class="string">@"B"</span> Car:car1];</span><br><span class="line">    Person *p3 = [Person personWithAge:<span class="number">24</span> Name:<span class="string">@"D"</span> Car:car1];</span><br><span class="line">    Person *p4 = [Person personWithAge:<span class="number">23</span> Name:<span class="string">@"C"</span> Car:car3];</span><br><span class="line">    Person *p5 = [Person personWithAge:<span class="number">23</span> Name:<span class="string">@"E"</span> Car:car1];</span><br><span class="line">    <span class="built_in">NSArray</span> *array = [<span class="built_in">NSArray</span> arrayWithObjects:p1,p2,p3,p4,p5, <span class="literal">nil</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  构建排序描述器（ascending:YES 升序，ascending:NO 降序）</span></span><br><span class="line">    <span class="built_in">NSSortDescriptor</span> *carNameDesc = [<span class="built_in">NSSortDescriptor</span> sortDescriptorWithKey:<span class="string">@"car.name"</span> ascending:<span class="literal">YES</span>];</span><br><span class="line">    <span class="built_in">NSSortDescriptor</span> *personNameDesc = [<span class="built_in">NSSortDescriptor</span> sortDescriptorWithKey:<span class="string">@"name"</span> ascending:<span class="literal">YES</span>];</span><br><span class="line">    <span class="built_in">NSSortDescriptor</span> *personAgaDesc = [<span class="built_in">NSSortDescriptor</span> sortDescriptorWithKey:<span class="string">@"age"</span> ascending:<span class="literal">YES</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  把排序描述器放进数组里，放入的顺序就是你想要排序的顺序，我这里是：首先按年龄排序，然后是车的名字，最后按照人的名字</span></span><br><span class="line">    <span class="built_in">NSArray</span> *descriporArray = @[personAgaDesc,carNameDesc,personNameDesc];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSArray</span> *sortedArray = [array sortedArrayUsingDescriptors:descriporArray];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,sortedArray);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">2016-01-01 14:19:46.555 OC10[33035:344658] (</span><br><span class="line">    &quot;age is 21 , name is A, car is Rolls-Royce&quot;,</span><br><span class="line">    &quot;age is 23 , name is B, car is Audio&quot;,</span><br><span class="line">    &quot;age is 23 , name is E, car is Audio&quot;,</span><br><span class="line">    &quot;age is 23 , name is C, car is BMW&quot;,</span><br><span class="line">    &quot;age is 24 , name is D, car is Audio&quot;</span><br><span class="line">)</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<p>可变数组的排序：</p>
<p>&lt; 代码示例 &gt;</p>
<p><em>Person.h</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Car.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>) Car *car;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">assign</span>) <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">+ (Person *)personWithAge:(<span class="keyword">int</span>)age</span><br><span class="line">                     Name:(<span class="built_in">NSString</span> *)name</span><br><span class="line">                      Car:(Car *)car;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>Person.m</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Person.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line">+ (Person *)personWithAge:(<span class="keyword">int</span>)age Name:(<span class="built_in">NSString</span> *)name Car:(Car *)car&#123;</span><br><span class="line">    Person *person =[[Person alloc] init];</span><br><span class="line">    person.age = age;</span><br><span class="line">    person.car = car;</span><br><span class="line">    person.name = name;</span><br><span class="line">    <span class="keyword">return</span> person;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)description&#123;</span><br><span class="line">     <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"age is %zi , name is %@, car is %@"</span>,_age,_name,_car.name];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>Car.h</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Car</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"></span><br><span class="line">+(Car *)carWithName:(<span class="built_in">NSString</span> *)name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>Car.m</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Car.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Car</span></span></span><br><span class="line"></span><br><span class="line">+ (Car *)carWithName:(<span class="built_in">NSString</span> *)name&#123;</span><br><span class="line">    Car *car = [[Car alloc] init];</span><br><span class="line">    car.name = name;</span><br><span class="line">    <span class="keyword">return</span> car;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>main.m</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Person.h"</span></span></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  首先来3辆车，分别是奥迪、劳斯莱斯、宝马</span></span><br><span class="line">    Car *car1 = [Car carWithName:<span class="string">@"Audio"</span>];</span><br><span class="line">    Car *car2 = [Car carWithName:<span class="string">@"Rolls-Royce"</span>];</span><br><span class="line">    Car *car3 = [Car carWithName:<span class="string">@"BMW"</span>];</span><br><span class="line">    <span class="comment">//  再来5个Person，每人送辆车，分别为car2、car1、car1、car3、car2</span></span><br><span class="line">    Person *p1 = [Person personWithAge:<span class="number">21</span> Name:<span class="string">@"A"</span> Car:car2];</span><br><span class="line">    Person *p2 = [Person personWithAge:<span class="number">23</span> Name:<span class="string">@"B"</span> Car:car1];</span><br><span class="line">    Person *p3 = [Person personWithAge:<span class="number">24</span> Name:<span class="string">@"D"</span> Car:car1];</span><br><span class="line">    Person *p4 = [Person personWithAge:<span class="number">23</span> Name:<span class="string">@"C"</span> Car:car3];</span><br><span class="line">    Person *p5 = [Person personWithAge:<span class="number">23</span> Name:<span class="string">@"E"</span> Car:car1];</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *array = [<span class="built_in">NSMutableArray</span> arrayWithObjects:p1,p2,p3,p4,p5, <span class="literal">nil</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  构建排序描述器（ascending:YES 升序，ascending:NO 降序）</span></span><br><span class="line">    <span class="built_in">NSSortDescriptor</span> *carNameDesc = [<span class="built_in">NSSortDescriptor</span> sortDescriptorWithKey:<span class="string">@"car.name"</span> ascending:<span class="literal">YES</span>];</span><br><span class="line">    <span class="built_in">NSSortDescriptor</span> *personNameDesc = [<span class="built_in">NSSortDescriptor</span> sortDescriptorWithKey:<span class="string">@"name"</span> ascending:<span class="literal">YES</span>];</span><br><span class="line">    <span class="built_in">NSSortDescriptor</span> *personAgaDesc = [<span class="built_in">NSSortDescriptor</span> sortDescriptorWithKey:<span class="string">@"age"</span> ascending:<span class="literal">YES</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  把排序描述器放进数组里，放入的顺序就是你想要排序的顺序，我这里是：首先按年龄排序，然后是车的名字，最后按照人的名字</span></span><br><span class="line">    <span class="built_in">NSArray</span> *descriporArray = @[personAgaDesc,carNameDesc,personNameDesc];</span><br><span class="line">    </span><br><span class="line">    [array sortUsingDescriptors:descriporArray];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,array);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span><span class="number">-01</span><span class="number">-01</span> <span class="number">14</span>:<span class="number">33</span>:<span class="number">28.783</span> OC10[<span class="number">33800</span>:<span class="number">354490</span>] (</span><br><span class="line">    <span class="string">"age is 21 , name is A, car is Rolls-Royce"</span>,</span><br><span class="line">    <span class="string">"age is 23 , name is B, car is Audio"</span>,</span><br><span class="line">    <span class="string">"age is 23 , name is E, car is Audio"</span>,</span><br><span class="line">    <span class="string">"age is 23 , name is C, car is BMW"</span>,</span><br><span class="line">    <span class="string">"age is 24 , name is D, car is Audio"</span></span><br><span class="line">)</span><br><span class="line">Program ended with exit code: <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>字典用于保存具有映射关系（key-value）数据的集合，key不能重复，value必须是对象，键值对在字典中是无序存储的。</p>
<h3 id="NSDictionary"><a href="#NSDictionary" class="headerlink" title="NSDictionary"></a>NSDictionary</h3><p>&lt; 代码示例 &gt;</p>
<p><em>main.m</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  创建字典1：在创建字典对象时赋值键值对，但是顺序为：值，键（值在前键在后）</span></span><br><span class="line">    <span class="built_in">NSDictionary</span> *dic1 = [<span class="built_in">NSDictionary</span> dictionaryWithObjectsAndKeys:<span class="string">@"duke2"</span>,<span class="string">@"name"</span>,<span class="string">@"age"</span>,@<span class="number">33</span>,<span class="string">@"男"</span>,<span class="string">@"gender"</span> ,<span class="literal">nil</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,dic1);</span><br><span class="line">    <span class="comment">/*  结果：&#123;</span><br><span class="line">     name = duke2;</span><br><span class="line">     33 = age;</span><br><span class="line">     gender = "\U7537";</span><br><span class="line">     &#125;</span><br><span class="line">     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  创建字典2：语法糖（键值对之间用","隔开，键和值之间用":"隔开。）</span></span><br><span class="line">    <span class="built_in">NSDictionary</span> *dic2 = @&#123;<span class="string">@"name"</span>:<span class="string">@"duke"</span>,<span class="string">@"age"</span>:@<span class="number">33</span>,<span class="string">@"gender"</span>:<span class="string">@"male"</span>&#125;;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,dic2);</span><br><span class="line">    <span class="comment">/*  结果：&#123;</span><br><span class="line">     age = 33;</span><br><span class="line">     gender = male;</span><br><span class="line">     name = duke;</span><br><span class="line">     &#125;</span><br><span class="line">     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  利用NSArray创建字典:创建字典对象时，两个数组元素的个数必须一致</span></span><br><span class="line">    <span class="built_in">NSArray</span> *keys =@[<span class="string">@"name"</span>,<span class="string">@"age"</span>,<span class="string">@"gender"</span>];</span><br><span class="line">    <span class="built_in">NSArray</span> *values =@[<span class="string">@"duke3"</span>,@<span class="number">33</span>,<span class="string">@"男"</span>];</span><br><span class="line">    <span class="built_in">NSDictionary</span> *dic3 = [<span class="built_in">NSDictionary</span> dictionaryWithObjects:values forKeys:keys];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,dic3);</span><br><span class="line">    <span class="comment">/*  结果：&#123;</span><br><span class="line">     age = 33;</span><br><span class="line">     gender = "\U7537";</span><br><span class="line">     name = duke3;</span><br><span class="line">     &#125;</span><br><span class="line">     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  通过count方法获得字典中键值对的个数</span></span><br><span class="line">    <span class="built_in">NSInteger</span> count = [dic3 count];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%ld"</span>,count);<span class="comment">//  结果：3</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  获取字典中所有的键</span></span><br><span class="line">    <span class="built_in">NSArray</span> *allKeys = [dic3 allKeys];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,allKeys);</span><br><span class="line">    <span class="comment">/*  结果：&#123;</span><br><span class="line">     name,</span><br><span class="line">     age,</span><br><span class="line">     gender</span><br><span class="line">     &#125;</span><br><span class="line">     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  获取字典中所有的值</span></span><br><span class="line">    <span class="built_in">NSArray</span> *allValue = [dic3 allValues];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,allValue);</span><br><span class="line">    <span class="comment">/*  结果：&#123;</span><br><span class="line">     duke3,</span><br><span class="line">     33,</span><br><span class="line">     "\U7537"</span><br><span class="line">     &#125;</span><br><span class="line">     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  根据指定的键获取其在字典中对应的值</span></span><br><span class="line">    <span class="keyword">id</span> object1 = [dic3 objectForKey:<span class="string">@"age"</span>];</span><br><span class="line">    <span class="keyword">id</span> object2 = dic3[<span class="string">@"gender"</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@,%@"</span>,object1,object2);<span class="comment">//  结果：33,男</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSDictionary</span> *dic4=[<span class="built_in">NSDictionary</span> dictionaryWithObjectsAndKeys:</span><br><span class="line">                        <span class="string">@"1"</span>,<span class="string">@"a"</span>,</span><br><span class="line">                        <span class="string">@"2"</span>,<span class="string">@"b"</span>,</span><br><span class="line">                        <span class="string">@"3"</span>,<span class="string">@"c"</span>,</span><br><span class="line">                        <span class="string">@"2"</span>,<span class="string">@"d"</span>,</span><br><span class="line">                        <span class="literal">nil</span>];</span><br><span class="line">    <span class="comment">//  遍历1：注意对于字典for遍历循环的是key</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">id</span> key <span class="keyword">in</span> dic4) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@=%@"</span>,key,[dic4 objectForKey:key]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*结果：</span><br><span class="line">     d=2</span><br><span class="line">     b=2</span><br><span class="line">     c=3</span><br><span class="line">     a=1</span><br><span class="line">     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  遍历2</span></span><br><span class="line">    <span class="built_in">NSEnumerator</span> *enumerator=[dic4 keyEnumerator];<span class="comment">//还有值的迭代器[dic4 objectEnumerator]</span></span><br><span class="line">    <span class="keyword">id</span> key=<span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">while</span> (key=[enumerator nextObject]) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@=%@"</span>,key,[dic4 objectForKey:key]);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*结果：</span><br><span class="line">     d=2</span><br><span class="line">     b=2</span><br><span class="line">     c=3</span><br><span class="line">     a=1</span><br><span class="line">     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//遍历3</span></span><br><span class="line">    [dic4 enumerateKeysAndObjectsUsingBlock:^(<span class="keyword">id</span> key, <span class="keyword">id</span> obj, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@=%@"</span>,key,obj);</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="comment">/*结果：</span><br><span class="line">     d=2</span><br><span class="line">     b=2</span><br><span class="line">     c=3</span><br><span class="line">     a=1</span><br><span class="line">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="NSMutableDictionary"><a href="#NSMutableDictionary" class="headerlink" title="NSMutableDictionary"></a>NSMutableDictionary</h3><p>&lt; 代码示例 &gt;</p>
<p><em>main.m</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  将不可变字典转为可变字典</span></span><br><span class="line">        <span class="built_in">NSMutableDictionary</span> *dic1 = [<span class="built_in">NSMutableDictionary</span> dictionaryWithDictionary:dic];</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//  创建空的字典</span></span><br><span class="line">        <span class="built_in">NSMutableDictionary</span> *dic2 = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//  增加键值对</span></span><br><span class="line">        [dic2 setObject:<span class="string">@"duke"</span> forKey:<span class="string">@"name"</span>];</span><br><span class="line">        [dic2 setObject:<span class="string">@"male"</span> forKey:<span class="string">@"gender"</span>];</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//  修改已有键对应的值</span></span><br><span class="line">        <span class="comment">//  如果键不存在，则是添加键值对，如果键存在，则为修改已有键对应的值（把dic9的@"duke" @"name"键值对覆盖了）</span></span><br><span class="line">        [dic9 setObject:<span class="string">@"dake"</span> forKey:<span class="string">@"name"</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//  根据指定键去删除对应的键值对</span></span><br><span class="line">        [dic9 removeObjectForKey:<span class="string">@"gender"</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//  删除所有键值对:删除的是内容，字典容器还留着。</span></span><br><span class="line">        [dic9 removeAllObjects];</span><br></pre></td></tr></table></figure>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>集合中的对象唯一，存储的对象无序。</p>
<h3 id="NSSet"><a href="#NSSet" class="headerlink" title="NSSet"></a>NSSet</h3><p>&lt; 代码示例 &gt;</p>
<p><em>main.m</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//  NSSet对象的创建</span></span><br><span class="line">        <span class="built_in">NSSet</span> *set1 = [<span class="built_in">NSSet</span> setWithObjects:<span class="string">@"1"</span>,<span class="string">@"2"</span>,<span class="string">@"3"</span>, <span class="literal">nil</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,set1);</span><br><span class="line">        <span class="comment">/*结果：&#123;(</span><br><span class="line">         1,</span><br><span class="line">         2,</span><br><span class="line">         3</span><br><span class="line">         )&#125;*/</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//  用数组对象来创建集合:可以将重复的元素过滤掉</span></span><br><span class="line">        <span class="built_in">NSArray</span> *array = @[@<span class="number">1</span>,@<span class="number">1</span>,@<span class="number">2</span>,@<span class="number">2</span>,@<span class="number">3</span>,@<span class="number">3</span>];</span><br><span class="line">        <span class="built_in">NSSet</span> *set2 = [<span class="built_in">NSSet</span> setWithArray:array];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,set2);</span><br><span class="line">        <span class="comment">/*结果：&#123;(</span><br><span class="line">         3,</span><br><span class="line">         2,</span><br><span class="line">         1</span><br><span class="line">         )&#125;*/</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//  获取集合中对象的个数</span></span><br><span class="line">        <span class="built_in">NSInteger</span> count = [set2 count];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%ld"</span>,count);<span class="comment">//  结果：3</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//  获取集合中的对象</span></span><br><span class="line">        <span class="keyword">id</span> object = [set2 anyObject];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,object);<span class="comment">//  结果：3</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//  判断一个对象是否包含在指定的集合中</span></span><br><span class="line">        <span class="built_in">BOOL</span> result = [set2 containsObject:@<span class="number">3</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@,is contained in set %@"</span>,<span class="string">@"3"</span>,result ?  <span class="string">@"YES"</span> : <span class="string">@"NO"</span>);<span class="comment">//  结果：3,is contained in set YES</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="NSMutableSet"><a href="#NSMutableSet" class="headerlink" title="NSMutableSet"></a>NSMutableSet</h3><p>&lt; 代码示例 &gt;</p>
<p><em>main.m</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//  NSMutableSet对象的创建</span></span><br><span class="line">        <span class="built_in">NSMutableSet</span> *mutableSet1 = [<span class="built_in">NSMutableSet</span> set];</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//  将不可变集合转位可变集合</span></span><br><span class="line"><span class="comment">//        NSMutableSet *mutableSet2 = [NSMutableSet setWithSet:set1];</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//  添加集合元素</span></span><br><span class="line">        [mutableSet1 addObject:<span class="string">@"5"</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,mutableSet1);</span><br><span class="line">        <span class="comment">/*结果：&#123;(</span><br><span class="line">         5</span><br><span class="line">         )&#125;*/</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//  移除单个集合元素</span></span><br><span class="line">        [mutableSet1 removeObject:<span class="string">@"3"</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,mutableSet1);</span><br><span class="line">        <span class="comment">/*结果：&#123;(</span><br><span class="line">         5</span><br><span class="line">         )&#125;*/</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//  移除所有元素</span></span><br><span class="line">        [mutableSet1 removeAllObjects];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,mutableSet1);</span><br><span class="line">        <span class="comment">/*结果：&#123;(</span><br><span class="line">         )&#125;*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="NSCountedSet"><a href="#NSCountedSet" class="headerlink" title="NSCountedSet"></a>NSCountedSet</h3><p>&lt; 代码示例 &gt;</p>
<p><em>main.m</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//NSCountedSet是NSSet的子类，基本用不到</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//  记录添加进去的对象重复了多少次</span></span><br><span class="line">        <span class="built_in">NSCountedSet</span> *countedSet = [<span class="built_in">NSCountedSet</span> set];</span><br><span class="line">        [countedSet addObject:@<span class="number">1</span>];</span><br><span class="line">        [countedSet addObject:@<span class="number">2</span>];</span><br><span class="line">        [countedSet addObject:@<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,countedSet);<span class="comment">//  结果：&lt;NSCountedSet: 0x100206020&gt; (1 [2], 2 [1])</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//  单独获取某个对象在集合中出现了多少次</span></span><br><span class="line">        <span class="built_in">NSInteger</span> countOfObjc = [countedSet countForObject:@<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%ld"</span>,countOfObjc);<span class="comment">//    结果：2</span></span><br></pre></td></tr></table></figure>
<h2 id="装箱和拆箱"><a href="#装箱和拆箱" class="headerlink" title="装箱和拆箱"></a>装箱和拆箱</h2><p>其实从上面的例子中我们也可以看到，数组和字典中只能存储对象类型，其他基本类型和结构体是没有办法放到数组和字典中的，当然你也是无法给它们发送消息的（也就是说有些NSObject的方法是无法调用的），这个时候通常会用到装箱（boxing）和拆箱（unboxing）。其实各种高级语言基本上都有装箱和拆箱的过程，例如C#中我们将基本数据类型转化为Object就是一个装箱的过程，将这个Object对象转换为基本数据类型的过程就是拆箱，而且在C#中装箱的过程可以自动完成，基本数据类型可以直接赋值给Object对象。但是在OC中装箱的过程必须手动实现，OC不支持自动装箱。</p>
<h3 id="NSNumber：用于基本数据类型"><a href="#NSNumber：用于基本数据类型" class="headerlink" title="NSNumber：用于基本数据类型"></a>NSNumber：用于基本数据类型</h3><p>NSNumber也是NSObject的子类，但是NSNumber不能对结构体装箱。</p>
<p>在OC中我们一般将基本数据类型装箱成NSNumber类型：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">　　　　+(<span class="built_in">NSNumber</span> *)numberWithChar:(<span class="keyword">char</span>)value;</span><br><span class="line"></span><br><span class="line">　　　　+(<span class="built_in">NSNumber</span> *)numberWithInt:(<span class="keyword">int</span>)value;</span><br><span class="line"></span><br><span class="line">　　　　+(<span class="built_in">NSNumber</span> *)numberWithFloat:(<span class="keyword">float</span>)value;</span><br><span class="line"></span><br><span class="line">　　　　+(<span class="built_in">NSNumber</span> *)numberWithDouble:(<span class="keyword">double</span>)value;</span><br><span class="line"></span><br><span class="line">　　　　+(<span class="built_in">NSNumber</span> *)numberWithBool:(<span class="built_in">BOOL</span>)value;</span><br><span class="line"></span><br><span class="line">　　　　+(<span class="built_in">NSNumber</span> *)numberWithInteger:(<span class="built_in">NSInteger</span>)value;</span><br></pre></td></tr></table></figure>
<p>拆箱的过程就更加简单了，可以调用如下方法：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">　　　　-(<span class="keyword">char</span>)charValue;</span><br><span class="line"></span><br><span class="line">　　　　-(<span class="keyword">int</span>)intValue;</span><br><span class="line"></span><br><span class="line">　　　　-(<span class="keyword">float</span>)floatValue;</span><br><span class="line"></span><br><span class="line">　　　　-(<span class="keyword">double</span>)doubleValue;</span><br><span class="line"></span><br><span class="line">　　　　-(<span class="built_in">BOOL</span>)boolValue;</span><br></pre></td></tr></table></figure>
<p>NSNumber装箱和拆箱的简单实用：</p>
<p>&lt; 代码示例 &gt;</p>
<p><em>main.m</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*可以存放基本类型到数组、字典*/</span></span><br><span class="line"><span class="keyword">void</span> test1()&#123;</span><br><span class="line">    <span class="comment">//包装类NSNumber，可以包装基本类型但是无法包装结构体类型</span></span><br><span class="line">    <span class="built_in">NSNumber</span> *number1=[<span class="built_in">NSNumber</span> numberWithChar:<span class="string">'a'</span>];<span class="comment">//'a'是一个C语言的char类型我们无法放倒NSArray中，但是我们可以通过NSNumber包装</span></span><br><span class="line">    <span class="built_in">NSArray</span> *array1=[<span class="built_in">NSArray</span> arrayWithObject:number1];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,array1);</span><br><span class="line">    <span class="comment">/*结果：</span><br><span class="line">     (</span><br><span class="line">        97</span><br><span class="line">     )</span><br><span class="line">     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSNumber</span> *number2= [array1 lastObject];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,number2);<span class="comment">//返回的不是基本类型,结果：97</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> char1=[number2 charValue];<span class="comment">//number转化为char</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%c"</span>,char1); <span class="comment">//结果：a</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    test1();</span><br><span class="line">    <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="NSValue：用于任何数据类型"><a href="#NSValue：用于任何数据类型" class="headerlink" title="NSValue：用于任何数据类型"></a>NSValue：用于任何数据类型</h3><p>上面我们看到了基本数据类型的装箱和拆箱过程，那么结构体呢？这个时候我们需要引入另外一个类型NSValue，其实上面的NSNumber就是NSValue的子类，它包装了一些基本数据类型的常用装箱、拆箱方法，当要对结构体进行装箱、拆箱操作我们需要使用NSValue，NSValue可以对任何数据类型进行装箱、拆箱操作。</p>
<h4 id="Foundation结构体"><a href="#Foundation结构体" class="headerlink" title="Foundation结构体"></a>Foundation结构体</h4><p>对应的装箱方法：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+(<span class="built_in">NSValue</span> *)valueWithPoint:(<span class="built_in">NSPoint</span>)point;</span><br><span class="line"></span><br><span class="line">+(<span class="built_in">NSValue</span> *)valueWithSize:(<span class="built_in">NSSize</span>)size;</span><br><span class="line"></span><br><span class="line">+(<span class="built_in">NSValue</span> *)valueWithRect:(<span class="built_in">NSRect</span>)rect;</span><br></pre></td></tr></table></figure>
<p>对应的拆箱方法：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="built_in">NSPoint</span>)pointValue;</span><br><span class="line"></span><br><span class="line">-(<span class="built_in">NSSize</span>)sizeValue;</span><br><span class="line"></span><br><span class="line">-(<span class="built_in">NSRect</span>)rectValue;</span><br></pre></td></tr></table></figure>
<p>Foundation结构体装箱拆箱代码示例：</p>
<p>&lt; 代码示例 &gt;</p>
<p><em>main.m</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//NSNumber是NSValue的子类，而NSValue可以包装任何类型，包括结构体</span></span><br><span class="line"><span class="keyword">void</span> test1()&#123;</span><br><span class="line">    <span class="built_in">CGPoint</span> point1=<span class="built_in">CGPointMake</span>(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">    <span class="built_in">NSValue</span> *value1=[<span class="built_in">NSValue</span> valueWithPoint:point1];<span class="comment">//对于系统自带类型一般都有直接的方法进行包装</span></span><br><span class="line">    <span class="built_in">NSArray</span> *array1=[<span class="built_in">NSArray</span> arrayWithObject:value1];<span class="comment">//放倒数组中</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,array1);</span><br><span class="line">    <span class="comment">/*结果：</span><br><span class="line">     (</span><br><span class="line">        "NSPoint: &#123;10, 20&#125;"</span><br><span class="line">     )</span><br><span class="line">     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSValue</span> *value2=[array1 lastObject];</span><br><span class="line">    <span class="built_in">CGPoint</span> point2=[value2 pointValue];<span class="comment">//同样对于系统自带的结构体有对应的取值方法（例如本例pointValue）</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"x=%f,y=%f"</span>,point2.x,point2.y);<span class="comment">//结果：x=10.000000,y=20.000000</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    test1();</span><br><span class="line">    <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="自定义的结构体"><a href="#自定义的结构体" class="headerlink" title="自定义的结构体"></a>自定义的结构体</h4><p>对应的装箱方法：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+(<span class="built_in">NSValue</span> *)valueWithBytes:(<span class="keyword">const</span> <span class="keyword">void</span> *)value objCType:(<span class="keyword">const</span> <span class="keyword">char</span> *)type;</span><br></pre></td></tr></table></figure>
<p>对应的拆箱方法：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)getValue:(<span class="keyword">void</span> *)value;</span><br></pre></td></tr></table></figure>
<p>自定义的结构体装箱拆箱代码示例：</p>
<p>&lt; 代码示例 &gt;</p>
<p><em>main.m</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> year;</span><br><span class="line">    <span class="keyword">int</span> month;</span><br><span class="line">    <span class="keyword">int</span> day;</span><br><span class="line">&#125; Date;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//NSNumber是NSValue的子类，而NSValue可以包装任何类型，包括结构体</span></span><br><span class="line"><span class="keyword">void</span> test1()&#123;</span><br><span class="line">    <span class="comment">//如果我们自己定义的结构体包装</span></span><br><span class="line">    Date date=&#123;<span class="number">2014</span>,<span class="number">2</span>,<span class="number">28</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> *type=@encode(Date);</span><br><span class="line">    <span class="built_in">NSValue</span> *value3=[<span class="built_in">NSValue</span> value:&amp;date withObjCType:type];<span class="comment">//第一参数传递结构体地址，第二个参数传递类型字符串</span></span><br><span class="line">    <span class="built_in">NSArray</span> *array2=[<span class="built_in">NSArray</span> arrayWithObject:value3];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,array2);</span><br><span class="line">    <span class="comment">/*结果：</span><br><span class="line">     (</span><br><span class="line">        "&lt;de070000 02000000 1c000000&gt;"</span><br><span class="line">     )</span><br><span class="line">     */</span></span><br><span class="line">    </span><br><span class="line">    Date date2;</span><br><span class="line">    [value3 getValue:&amp;date2];<span class="comment">//取出对应的结构体，注意没有返回值</span></span><br><span class="line">    <span class="comment">//[value3 objCType]//取出包装内容的类型</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%i,%i,%i"</span>,date2.year,date2.month,date2.day); <span class="comment">//结果：2014,2,28</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    test1();</span><br><span class="line">    <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="拓展1-NSNull"><a href="#拓展1-NSNull" class="headerlink" title="拓展1-NSNull"></a>拓展1-NSNull</h3><p>通过前面的介绍大家都知道无论在数组还是在字典中都必须以nil结尾，否则数组或字典无法判断是否这个数组或字典已经结束（与C语言中的字符串比较类似，C语言中定义字符串后面必须加一个”\0”）。但是我们有时候确实想在数据或字典中存储nil值而不是作为结束标记怎么办呢？这个时候需要使用NSNull，这个类是一个单例，只有一个null方法。简单看一下：</p>
<p>&lt; 代码示例 &gt;</p>
<p><em>main.m</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSNull</span> *nl=[<span class="built_in">NSNull</span> null];<span class="comment">//注意这是一个对象，是一个单例，只有一个方法null创建一个对象</span></span><br><span class="line">    <span class="built_in">NSNull</span> *nl2=[<span class="built_in">NSNull</span> null];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%i"</span>,nl==nl2);<span class="comment">//由于是单例所以地址相等,结果：1</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSArray</span> *array1=[<span class="built_in">NSArray</span> arrayWithObjects:<span class="string">@"abc"</span>,nl,@<span class="number">123</span>, <span class="literal">nil</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,array1);</span><br><span class="line">    <span class="comment">/*结果：</span><br><span class="line">     (</span><br><span class="line">         abc,</span><br><span class="line">         "&lt;null&gt;",</span><br><span class="line">         123</span><br><span class="line">     )</span><br><span class="line">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="拓展2-符号"><a href="#拓展2-符号" class="headerlink" title="拓展2-@符号"></a>拓展2-@符号</h3><p>我们知道在OC中很多关键字前都必须加上@符号，例如@protocol、@property等，当然OC中的字符串必须使用@符号，还有就是%@可以表示输出一个对象。其实@符号在新版的OC中还有一个作用：装箱。</p>
<p>相信聪明的童鞋在前面的例子中已经看到了，这里简单的介绍一下（在下面的演示中你也将看到很多OC新特性）：</p>
<p>&lt; 代码示例 &gt;</p>
<p><em>main.m</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">    spring,</span><br><span class="line">    summer,</span><br><span class="line">    autumn,</span><br><span class="line">    winter</span><br><span class="line">&#125; Season;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="comment">/*装箱*/</span></span><br><span class="line">    <span class="built_in">NSNumber</span> *number1=@<span class="number">100</span>;</span><br><span class="line">    <span class="built_in">NSArray</span> *array1=[<span class="built_in">NSArray</span> arrayWithObjects:number1,<span class="string">@"abc"</span>,@<span class="number">16</span>,@<span class="string">'A'</span>,@<span class="number">16.7</span>,@YES, <span class="literal">nil</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,array1);</span><br><span class="line">    <span class="comment">/*结果：</span><br><span class="line">     (</span><br><span class="line">         100,</span><br><span class="line">         abc,</span><br><span class="line">         16,</span><br><span class="line">         65,</span><br><span class="line">         "16.7"</span><br><span class="line">         1</span><br><span class="line">     )</span><br><span class="line">     */</span></span><br><span class="line">    <span class="built_in">NSNumber</span> *number2=@(<span class="number">1</span>+<span class="number">2</span>*<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,number2); <span class="comment">//结果：7</span></span><br><span class="line">    <span class="built_in">NSNumber</span> *number3=@(autumn);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,number3); <span class="comment">//结果：2</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSArray</span> *array2=@[<span class="string">@"abc"</span>,@<span class="number">16</span>,@<span class="string">'A'</span>,@<span class="number">16.7</span>,@YES];<span class="comment">//使用这种方式最后不用添加nil值了</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,array2[<span class="number">2</span>]); <span class="comment">//结果：65</span></span><br><span class="line">    <span class="built_in">NSMutableArray</span> *array3=[<span class="built_in">NSMutableArray</span> arrayWithArray:array2];</span><br><span class="line">    array3[<span class="number">0</span>]=<span class="string">@"def"</span>;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,array3[<span class="number">0</span>]); <span class="comment">//结果：def</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSDictionary</span> *dic1=@&#123;<span class="string">@"a"</span>:@<span class="number">123</span>,<span class="string">@"b"</span>:@<span class="string">'c'</span>,<span class="string">@"c"</span>:@YES&#125;;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,dic1);</span><br><span class="line">    <span class="comment">/*结果：</span><br><span class="line">     &#123;</span><br><span class="line">         a = 123;</span><br><span class="line">         b = 99;</span><br><span class="line">         c = 1;</span><br><span class="line">     &#125;</span><br><span class="line">     */</span></span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *dic2=[<span class="built_in">NSMutableDictionary</span> dictionaryWithDictionary:dic1];</span><br><span class="line">    dic2[<span class="string">@"a"</span>]=@<span class="number">456</span>;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,dic2[<span class="string">@"a"</span>]);<span class="comment">//结果：456</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>由于OC动态性，在OC中实现反射可以说是相当简单，下面代码中演示了常用的反射操作，具体作用也都在代码中进行了注释说明:</p>
<p>&lt; 代码示例 &gt;</p>
<p><em>Account.h</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Account</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">assign</span>) <span class="keyword">double</span> balance;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>Account.m</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Account.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Account</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>Person.h</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@class</span> <span class="title">Account</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,retain) Account *account;</span><br><span class="line"></span><br><span class="line">-(Person *)initWithName:(<span class="built_in">NSString</span> *)name;</span><br><span class="line"></span><br><span class="line">+(Person *)personWithName:(<span class="built_in">NSString</span> *)name;</span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)showMessage:(<span class="built_in">NSString</span> *)infomation;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自己实现对象比较方法</span></span><br><span class="line">-(<span class="built_in">NSComparisonResult</span>)comparePerson:(Person *)person;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>Person.m</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Person.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line">-(Person *)initWithName:(<span class="built_in">NSString</span> *)name&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">self</span>=[<span class="keyword">super</span> init])&#123;</span><br><span class="line">        <span class="keyword">self</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+(Person *)personWithName:(<span class="built_in">NSString</span> *)name&#123;</span><br><span class="line">    Person *person=[[Person alloc]initWithName:name];</span><br><span class="line">    <span class="keyword">return</span> person;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)showMessage:(<span class="built_in">NSString</span> *)infomation&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"My name is %@,the infomation is \"%@\"."</span>,_name,infomation);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自己实现对象比较方法</span></span><br><span class="line">-(<span class="built_in">NSComparisonResult</span>)comparePerson:(Person *)person&#123;</span><br><span class="line">    <span class="keyword">return</span> [_name compare:person.name];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(<span class="built_in">NSString</span> *)description&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"name=%@"</span>,_name];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>main.m</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Person.h"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="comment">/*常用方法*/</span></span><br><span class="line">    Person *person1=[Person personWithName:<span class="string">@"Kenshin"</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%i"</span>,[person1 isKindOfClass:[<span class="built_in">NSObject</span> class]]); <span class="comment">//判断一个对象是否为某种类型（如果是父类也返回YES），结果：1</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%i"</span>,[person1 isMemberOfClass:[<span class="built_in">NSObject</span> class]]); <span class="comment">//判断一个对象是否是某个类的实例化对象，结果：0</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%i"</span>,[person1 isMemberOfClass:[Person class]]); <span class="comment">//结果：1</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%i"</span>,[person1 conformsToProtocol:<span class="class"><span class="keyword">@protocol</span>(<span class="title">NSCopying</span>)]);//是否实现了某个协议，结果：0</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%i"</span>,[person1 respondsToSelector:<span class="keyword">@selector</span>(showMessage:)]);<span class="comment">//是否存在某个方法，结果：1</span></span><br><span class="line">    </span><br><span class="line">    [person1 showMessage:<span class="string">@"Hello,world!"</span>];<span class="comment">//直接调用一个方法</span></span><br><span class="line">    [person1 performSelector:<span class="keyword">@selector</span>(showMessage:) withObject:<span class="string">@"Hello,world!"</span>];</span><br><span class="line">    <span class="comment">//动态调用一个方法，注意如果有参数那么参数类型只能为ObjC对象，并且最多只能有两个参数</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*反射*/</span></span><br><span class="line">    <span class="comment">//动态生成一个类</span></span><br><span class="line">    <span class="built_in">NSString</span> *className=<span class="string">@"Person"</span>;</span><br><span class="line">    Class myClass=<span class="built_in">NSClassFromString</span>(className);<span class="comment">//根据类名生成类</span></span><br><span class="line">    Person *person2=[[myClass alloc]init]; <span class="comment">//实例化</span></span><br><span class="line">    person2.name=<span class="string">@"Kaoru"</span>;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,person2);<span class="comment">//结果：name=Kaoru</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//类转化为字符串</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@,%@"</span>,<span class="built_in">NSStringFromClass</span>(myClass),<span class="built_in">NSStringFromClass</span>([Person class])); <span class="comment">//结果：Person,Person</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用方法</span></span><br><span class="line">    <span class="built_in">NSString</span> *methodName=<span class="string">@"showMessage:"</span>;</span><br><span class="line">    SEL mySelector=<span class="built_in">NSSelectorFromString</span>(methodName);</span><br><span class="line">    Person *person3=[[myClass alloc]init];</span><br><span class="line">    person3.name=<span class="string">@"Rosa"</span>;</span><br><span class="line">    [person3 performSelector:mySelector withObject:<span class="string">@"Hello,world!"</span>]; <span class="comment">//结果：My name is Rosa,the infomation is "Hello,world!".</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法转化为字符串</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,<span class="built_in">NSStringFromSelector</span>(mySelector)); <span class="comment">//结果：showMessage:</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><p>让我们看一下Foundation中文件操作，下面将以一个例子进行说明：</p>
<p>&lt; 代码示例 &gt;</p>
<p><em>main.m</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*目录操作*/</span></span><br><span class="line"><span class="keyword">void</span> test1()&#123;</span><br><span class="line">    <span class="comment">//文件管理器是专门用于文件管理的类</span></span><br><span class="line">    <span class="built_in">NSFileManager</span> *manager=[<span class="built_in">NSFileManager</span> defaultManager];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获得当前程序所在目录(当然可以改变)</span></span><br><span class="line">    <span class="built_in">NSString</span> *currentPath=[manager currentDirectoryPath];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"current path is :%@"</span>,currentPath);</span><br><span class="line">    <span class="comment">//结果：/Users/kenshincui/Library/Developer/Xcode/DerivedData/FoundationFramework-awxjohcpgsqcpsanqofqogwbqgbx/Build/Products/Debug</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建目录</span></span><br><span class="line">    <span class="built_in">NSString</span> *myPath=<span class="string">@"/Users/kenshincui/Desktop/myDocument"</span>;</span><br><span class="line">    <span class="built_in">BOOL</span> result= [manager createDirectoryAtPath:myPath withIntermediateDirectories:<span class="literal">YES</span> attributes:<span class="literal">nil</span> error:<span class="literal">nil</span>];</span><br><span class="line">    <span class="keyword">if</span>(result==<span class="literal">NO</span>)&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Couldn't create directory!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//目录重命名，如果需要删除目录只要调用removeItemAtPath:&lt;#(NSString *)#&gt; error:&lt;#(NSError **)#&gt;</span></span><br><span class="line">    <span class="built_in">NSError</span> *error;</span><br><span class="line">    <span class="built_in">NSString</span> *newPath=<span class="string">@"/Users/kenshincui/Desktop/myNewDocument"</span>;</span><br><span class="line">    <span class="keyword">if</span>([manager moveItemAtPath:myPath toPath:newPath error:&amp;error]==<span class="literal">NO</span>)&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Rename directory failed!Error infomation is:%@"</span>,error);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//改变当前目录</span></span><br><span class="line">    <span class="keyword">if</span>([manager changeCurrentDirectoryPath:newPath]==<span class="literal">NO</span>)&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Change current directory failed!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"current path is :%@"</span>,[manager currentDirectoryPath]);</span><br><span class="line">    <span class="comment">//结果：current path is :/Users/kenshincui/Desktop/myNewDocument</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//遍历整个目录</span></span><br><span class="line">    <span class="built_in">NSString</span> *path;</span><br><span class="line">    <span class="built_in">NSDirectoryEnumerator</span> *directoryEnumerator= [manager enumeratorAtPath:newPath];</span><br><span class="line">    <span class="keyword">while</span> (path=[directoryEnumerator nextObject]) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,path);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*结果：</span><br><span class="line">     documents</span><br><span class="line">     est.txt</span><br><span class="line">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//或者这样遍历</span></span><br><span class="line">    <span class="built_in">NSArray</span> *paths= [manager contentsOfDirectoryAtPath:newPath error:<span class="literal">nil</span>];</span><br><span class="line">    <span class="built_in">NSObject</span> *p;</span><br><span class="line">    <span class="keyword">for</span> (p <span class="keyword">in</span> paths) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*结果：</span><br><span class="line">     documents</span><br><span class="line">     est.txt</span><br><span class="line">     */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*文件操作*/</span></span><br><span class="line"><span class="keyword">void</span> test2()&#123;</span><br><span class="line">    <span class="built_in">NSFileManager</span> *manager=[<span class="built_in">NSFileManager</span> defaultManager];</span><br><span class="line">    <span class="built_in">NSString</span> *filePath=<span class="string">@"/Users/kenshincui/Desktop/myNewDocument/test.txt"</span>;</span><br><span class="line">    <span class="built_in">NSString</span> *filePath2=<span class="string">@"/Users/kenshincui/Desktop/test.txt"</span>;</span><br><span class="line">    <span class="built_in">NSString</span> *newPath=<span class="string">@"/Users/kenshincui/Desktop/myNewDocument/test2.txt"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断文件是否存在，这个方法也可以判断目录是否存在，这要后面的参数设置位YES</span></span><br><span class="line">    <span class="keyword">if</span> ([manager fileExistsAtPath:filePath isDirectory:<span class="literal">NO</span>]) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"File exists！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//文件是否可读</span></span><br><span class="line">    <span class="keyword">if</span>([manager isReadableFileAtPath:filePath])&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"File is readable!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断两个文件内容是否相等</span></span><br><span class="line">    <span class="keyword">if</span> ([manager contentsEqualAtPath:filePath andPath:filePath2]) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"file1 equals file2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//文件重命名，方法类似于目录重命名</span></span><br><span class="line">    <span class="keyword">if</span> (![manager moveItemAtPath:filePath toPath:newPath error:<span class="literal">nil</span>]) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Rename file1 failed!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//文件拷贝</span></span><br><span class="line">    <span class="built_in">NSString</span> *filePath3=<span class="string">@"/Users/kenshincui/Desktop/test3.txt"</span>;</span><br><span class="line">    <span class="keyword">if</span>(![manager copyItemAtPath:newPath toPath:filePath3 error:<span class="literal">nil</span>])&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Copy failed!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//读取文件属性</span></span><br><span class="line">    <span class="built_in">NSDictionary</span> *attributes;</span><br><span class="line">    <span class="keyword">if</span> ((attributes=[manager attributesOfItemAtPath:newPath error:<span class="literal">nil</span>])==<span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Read attributes failed!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSObject</span> *key <span class="keyword">in</span> attributes) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@=%@"</span>,key,attributes[key]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*结果：</span><br><span class="line">         NSFileOwnerAccountID=501</span><br><span class="line">         NSFileHFSTypeCode=0</span><br><span class="line">         NSFileSystemFileNumber=1781953</span><br><span class="line">         NSFileExtensionHidden=0</span><br><span class="line">         NSFileSystemNumber=16777218</span><br><span class="line">         NSFileSize=27</span><br><span class="line">         NSFileGroupOwnerAccountID=20</span><br><span class="line">         NSFileOwnerAccountName=kenshincui</span><br><span class="line">         NSFileCreationDate=2014-07-28 11:47:58 +0000</span><br><span class="line">         NSFilePosixPermissions=420</span><br><span class="line">         NSFileHFSCreatorCode=0</span><br><span class="line">         NSFileType=NSFileTypeRegular</span><br><span class="line">         NSFileExtendedAttributes=&#123;</span><br><span class="line">         "com.apple.TextEncoding" = &lt;7574662d 383b3133 34323137 393834&gt;;</span><br><span class="line">         &#125;</span><br><span class="line">         NSFileGroupOwnerAccountName=staff</span><br><span class="line">         NSFileReferenceCount=1</span><br><span class="line">         NSFileModificationDate=2014-07-28 11:47:58 +0000</span><br><span class="line">     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//删除文件</span></span><br><span class="line">    [manager removeItemAtPath:newPath error:<span class="literal">nil</span>];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//文件操作--文件内容操作（NSData，非结构化字节流对象，有缓冲区管理机制，可用于网络传输）</span></span><br><span class="line"><span class="keyword">void</span> test3()&#123;</span><br><span class="line">    <span class="built_in">NSFileManager</span> *manager=[<span class="built_in">NSFileManager</span> defaultManager];</span><br><span class="line">    <span class="built_in">NSString</span> *filePath=<span class="string">@"/Users/kenshincui/Desktop/myNewDocument/test2.txt"</span>;</span><br><span class="line">    <span class="built_in">NSData</span> *data=[manager contentsAtPath:filePath];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,data);<span class="comment">//存储的是二进制字节流</span></span><br><span class="line">    <span class="comment">//结果:&lt;68656c6c 6f20776f 726c642c e4b896e7 958ce4bd a0e5a5bd efbc81&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//NSData转化成字符串</span></span><br><span class="line">    <span class="built_in">NSString</span> *str1=[[<span class="built_in">NSString</span> alloc]initWithData:data encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,str1);</span><br><span class="line">    <span class="comment">//结果：hello world,世界你好！</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//字符串转化成NSData</span></span><br><span class="line">    <span class="built_in">NSString</span> *str2=<span class="string">@"Kenshin"</span>;</span><br><span class="line">    <span class="built_in">NSData</span> *data2=[str2 dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,data2);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//当然一般如果仅仅是简单读取文件内容，直接用户NSString方法即可</span></span><br><span class="line">    <span class="built_in">NSString</span> *content=[<span class="built_in">NSString</span> stringWithContentsOfFile:filePath encoding:<span class="built_in">NSUTF8StringEncoding</span> error:<span class="literal">nil</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,content);</span><br><span class="line">    <span class="comment">//结果：hello world,世界你好！</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//文件操作--细粒度控制文件,文件操作柄</span></span><br><span class="line"><span class="keyword">void</span> test4()&#123;</span><br><span class="line">    <span class="built_in">NSFileManager</span> *manager=[<span class="built_in">NSFileManager</span> defaultManager];</span><br><span class="line">    <span class="built_in">NSString</span> *filePath=<span class="string">@"/Users/kenshincui/Desktop/myNewDocument/test2.txt"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//以只读方式打开文件</span></span><br><span class="line">    <span class="built_in">NSFileHandle</span> *fileHandle=[<span class="built_in">NSFileHandle</span> fileHandleForReadingAtPath:filePath];<span class="comment">//注意这个方法返回类型为instancetype，也就是说对于上面的NSFileHandle它的返回类型也是NSFileHandle</span></span><br><span class="line">    <span class="built_in">NSData</span> *data= [fileHandle readDataToEndOfFile];<span class="comment">//完整读取文件</span></span><br><span class="line">    <span class="built_in">NSString</span> *newPath=<span class="string">@"/Users/kenshincui/Desktop/test4.txt"</span>;</span><br><span class="line">    [manager createFileAtPath:newPath contents:<span class="literal">nil</span> attributes:<span class="literal">nil</span>];</span><br><span class="line">    <span class="built_in">NSFileHandle</span> *fileHandle2=[<span class="built_in">NSFileHandle</span> fileHandleForWritingAtPath:newPath];<span class="comment">//以可写方式打开文件</span></span><br><span class="line">    [fileHandle2 writeData:data];<span class="comment">//写入文件内容</span></span><br><span class="line">    </span><br><span class="line">    [fileHandle2 closeFile];<span class="comment">//关闭文件</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//定位到指定位置,默认在文件开头</span></span><br><span class="line">    [fileHandle seekToFileOffset:<span class="number">12</span>];</span><br><span class="line">    <span class="built_in">NSData</span> *data2= [fileHandle readDataToEndOfFile];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"data2=%@"</span>,[[<span class="built_in">NSString</span> alloc]initWithData:data2 encoding:<span class="built_in">NSUTF8StringEncoding</span>]);</span><br><span class="line">    <span class="comment">//结果：data2=世界你好！</span></span><br><span class="line">    </span><br><span class="line">    [fileHandle seekToFileOffset:<span class="number">6</span>];</span><br><span class="line">    <span class="built_in">NSData</span> *data3=[fileHandle readDataOfLength:<span class="number">5</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"data3=%@"</span>,[[<span class="built_in">NSString</span> alloc]initWithData:data3 encoding:<span class="built_in">NSUTF8StringEncoding</span>]);</span><br><span class="line">    <span class="comment">//结果：data3=world</span></span><br><span class="line">    </span><br><span class="line">    [fileHandle closeFile];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//文件路径</span></span><br><span class="line"><span class="keyword">void</span> test5()&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *filePath=<span class="string">@"/Users/kenshincui/Desktop/myDocument"</span>;</span><br><span class="line">    <span class="built_in">NSString</span> *filePath2=<span class="string">@"/Users/kenshincui/Desktop/test.txt"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//临时文件所在目录</span></span><br><span class="line">    <span class="built_in">NSString</span> *path=<span class="built_in">NSTemporaryDirectory</span>();</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"temporary directory is :%@"</span>,path);</span><br><span class="line">    <span class="comment">//结果：/var/folders/h6/lss6gncs509c2pgzgty3wd_40000gn/T/</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSString</span> *lastComponent= [filePath lastPathComponent];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,lastComponent); <span class="comment">//结果：myDocument</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[filePath stringByDeletingLastPathComponent]);</span><br><span class="line">    <span class="comment">//结果：/Users/kenshincui/Desktop</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[filePath stringByAppendingPathComponent:<span class="string">@"Pictrues"</span>]);</span><br><span class="line">    <span class="comment">//结果：/Users/kenshincui/Desktop/myDocument/Pictrues</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[filePath2 pathExtension]);</span><br><span class="line">    <span class="comment">//结果：txt</span></span><br><span class="line">    </span><br><span class="line">    [[filePath pathComponents] enumerateObjectsUsingBlock:^(<span class="keyword">id</span> obj, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%i=%@"</span>,idx,obj);</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="comment">/*结果：</span><br><span class="line">     0=/</span><br><span class="line">     1=Users</span><br><span class="line">     2=kenshincui</span><br><span class="line">     3=Desktop</span><br><span class="line">     4=myDocument</span><br><span class="line">     */</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//文件操作--NSURL</span></span><br><span class="line"><span class="keyword">void</span> test6()&#123;</span><br><span class="line">    <span class="built_in">NSURL</span> *url=[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://developer.apple.com"</span>];</span><br><span class="line">    <span class="built_in">NSString</span> *str1=[<span class="built_in">NSString</span> stringWithContentsOfURL:url encoding:<span class="built_in">NSUTF8StringEncoding</span> error:<span class="literal">nil</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,str1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//文件操作--NSBundle，程序包，一般用于获取Resource中的资源（当然由于当前并非IOS应用没有程序包，只是表示当前程序运行路径）</span></span><br><span class="line"><span class="comment">//在ios中经常用于读取应用程序中的资源文件，如图片、声音、视频等</span></span><br><span class="line"><span class="keyword">void</span> test7()&#123;</span><br><span class="line">    <span class="comment">//在程序包所在目录创建一个文件</span></span><br><span class="line">    <span class="built_in">NSFileManager</span> *manager=[<span class="built_in">NSFileManager</span> defaultManager];</span><br><span class="line">    <span class="built_in">NSString</span> *currentPath=[manager currentDirectoryPath];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"current path is :%@"</span>,currentPath);</span><br><span class="line">    <span class="comment">//结果：current path is :/Users/kenshincui/Library/Developer/Xcode/DerivedData/FoundationFramework-awxjohcpgsqcpsanqofqogwbqgbx/Build/Products/Debug</span></span><br><span class="line">    <span class="built_in">NSString</span> *filePath=[currentPath stringByAppendingPathComponent:<span class="string">@"test.txt"</span>];</span><br><span class="line">    [manager createFileAtPath:filePath contents:[<span class="string">@"Hello,world!"</span> dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>] attributes:<span class="literal">nil</span>];</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//利用NSBundle在程序包所在目录查找对应的文件</span></span><br><span class="line">    <span class="built_in">NSBundle</span> *bundle=[<span class="built_in">NSBundle</span> mainBundle];<span class="comment">//主要操作程序包所在目录</span></span><br><span class="line">    <span class="comment">//如果有test.txt则返回路径，否则返回nil</span></span><br><span class="line">    <span class="built_in">NSString</span> *path=[bundle pathForResource:<span class="string">@"test"</span> ofType:<span class="string">@"txt"</span>];<span class="comment">//也可以写成：[bundle pathForResource:@"instructions.txt" ofType:nil];</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,path);</span><br><span class="line">    <span class="comment">//结果：/Users/kenshincui/Library/Developer/Xcode/DerivedData/FoundationFramework-awxjohcpgsqcpsanqofqogwbqgbx/Build/Products/Debug/test.txt</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[<span class="built_in">NSString</span> stringWithContentsOfFile:path encoding:<span class="built_in">NSUTF8StringEncoding</span> error:<span class="literal">nil</span>]);</span><br><span class="line">    <span class="comment">//结果：Hello,world!</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//假设我们在程序运行创建一个Resources目录，并且其中新建pic.jpg，那么用下面的方法获得这个文件完整路径</span></span><br><span class="line">    <span class="built_in">NSString</span> *path1= [bundle pathForResource:<span class="string">@"pic"</span> ofType:<span class="string">@"jpg"</span> inDirectory:<span class="string">@"Resources"</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,path1);</span><br><span class="line">    <span class="comment">//结果：/Users/kenshincui/Library/Developer/Xcode/DerivedData/FoundationFramework-awxjohcpgsqcpsanqofqogwbqgbx/Build/Products/Debug/Resources/pic.jpg</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])&#123;</span><br><span class="line"></span><br><span class="line">    test1();</span><br><span class="line">    test2();</span><br><span class="line">    test3();</span><br><span class="line">    test4();</span><br><span class="line">    test5();</span><br><span class="line">    test6();</span><br><span class="line">    test7();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.cnblogs.com/mjios/" target="_blank" rel="external">M了个J的博客</a></p>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[【15】键值监听（KVO）]]></title>
      <url>http://sanfordy.com/2016/08/31/%E3%80%96A%E3%80%97%E3%80%902-0%E3%80%91OC-%E8%AF%AD%E6%B3%95/%E3%80%9015%E3%80%91%E9%94%AE%E5%80%BC%E7%9B%91%E5%90%AC%EF%BC%88KVO%EF%BC%89/</url>
      <content type="html"><![CDATA[<blockquote>
<p>KVO（Key Value Observing）其实是一种观察者模式，利用它可以很容易实现<code>视图组件</code>和<code>数据模型</code>的分离，当数据模型的属性值改变之后作为观察者的视图组件就会接到通知，接到通知后观察者就会进行回调。</p>
</blockquote>
<a id="more"></a>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>KVO（Key Value Observing）其实是一种观察者模式，利用它可以很容易实现视图组件和数据模型的分离，当数据模型的属性值改变之后作为观察者的视图组件就会接到通知，接到通知后观察者就会进行回调。</p>
<p>KVO适用于这样的情况，比方说根据A（数据类）的某个属性值变化，B（view类）中的某个属性做出相应变化。对于推崇MVC的cocoa而言，KVO应用价值很高。</p>
<p>熟悉KVO的朋友都知道，只有当我们调用KVC去访问key值的时候KVO才会起作用。所以肯定确定的是，KVO是基于KVC实现的。</p>
<p>在OC中要实现 KVO 则必须实现 NSKeyValueObServing 协议，不过幸运的是 NSObject 已经实现了该协议，因此几乎所有的OC对象都可以使用 KVO 。</p>
<p>在OC中使用KVO操作常用的方法如下：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  注册指定Key路径的观察者。</span></span><br><span class="line"><span class="comment">//  addObserver：观察者。</span></span><br><span class="line"><span class="comment">//  forKeyPath：观察的属性。</span></span><br><span class="line"><span class="comment">//  options：选项内容(NSKeyValueObservingOptionInitial：初始化和setter都会调用监听方法，NSKeyValueObservingOptionPrior：值发生改变前走一次监听方法，值发生改变后走一次监听方法，NSKeyValueObservingOptionNew：走监听方法后change会保留新值，NSKeyValueObservingOptionOld：走监听方法后change会保留旧值)。</span></span><br><span class="line"><span class="comment">//  context：context上下文（可以传递参数）。</span></span><br><span class="line">addObserver: forKeyPath: options:  context:</span><br><span class="line"></span><br><span class="line"><span class="comment">//  删除指定Key路径的观察者</span></span><br><span class="line"> removeObserver: forKeyPath、removeObserver: forKeyPath: context:</span><br><span class="line"> </span><br><span class="line"><span class="comment">//  回调</span></span><br><span class="line">observeValueForKeyPath: ofObject: change: context:</span><br></pre></td></tr></table></figure>
<p>KVO的使用步骤也比较简单：</p>
<ol>
<li>通过 addObserver: forKeyPath: options: context: 为被观察者（它通常是数据模型）注册观察者。</li>
<li>在观察者中实现 observeValueForKeyPath: ofObject: change: context: 回调方法。</li>
<li>移除观察者 removeObserver: forKeyPath 。</li>
</ol>
<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><h3 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h3><p>假设当我们的账户余额balance变动之后我们希望用户可以及时获得通知。那么此时Account就作为我们的被观察者，需要Person为它注册观察者（使用addObserver: forKeyPath: options: context:）;而Person作为观察者需要重写它的observeValueForKeyPath: ofObject: change: context:方法，当监听的余额发生改变后会回调观察者Person回调方法（observeValueForKeyPath: ofObject: change: context:）。下面通过代码模拟上面的过程：</p>
<p>&lt; 代码示例 &gt;</p>
<p><em>main.m</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Account.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Person.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        Person *person = [[Person alloc] init];</span><br><span class="line">        Account *account = [[Account alloc] init];</span><br><span class="line">        </span><br><span class="line">        person.account = account;</span><br><span class="line">        <span class="comment">//  由于我们观察的是new、old，所以balance变化时会在观察者中进行回调。</span></span><br><span class="line">        account.balance = <span class="number">19.4</span>;</span><br><span class="line">        account.balance = <span class="number">20.1</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>Account.h</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Account</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">assign</span>) <span class="keyword">float</span> balance;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>Account.m</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Account.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Account</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>Person.h</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Account.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="comment">//  账户</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>) Account *account;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>Person.m</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Person.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置人员账户</span></span><br><span class="line">-(<span class="keyword">void</span>)setAccount:(Account *)account&#123;</span><br><span class="line">    _account = account;</span><br><span class="line">    <span class="comment">//  参数：observer观察者是谁，forKeyPath观察者观察自己的哪个属性，options观察的内容NSKeyValueObservingOptionNew,NSKeyValueObservingOptionOld这两个参数的意思是监听它的新值和旧值。</span></span><br><span class="line">    [_account addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"balance"</span> options:<span class="built_in">NSKeyValueObservingOptionNew</span>|<span class="built_in">NSKeyValueObservingOptionOld</span> context:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  实现observeValueForKeyPath回调方法，当账户余额变化后此处获得通知</span><br><span class="line"> *</span><br><span class="line"> *  @param keyPath 观察的哪个属性，如果观察多个属性可以对keypath进行判断</span><br><span class="line"> *  @param object  观察的哪个对象</span><br><span class="line"> *  @param change  change字典中存放着new、old两个key，分别对应属性更改后的新值和更改前的老值</span><br><span class="line"> *  @param context 上下文环境</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *,<span class="keyword">id</span>&gt; *)change context:(<span class="keyword">void</span> *)context&#123;</span><br><span class="line">    <span class="comment">//  判断观察的是不是对象的balance属性</span></span><br><span class="line">    <span class="keyword">if</span> ([keyPath isEqualToString:<span class="string">@"balance"</span>]) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"keyPath=%@,object=%@,change=%@,context=%@"</span>,keyPath,object, change,context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc&#123;</span><br><span class="line">    <span class="comment">//  必须在观察者销毁之前移除观察者</span></span><br><span class="line">    [_account removeObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"balance"</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>在上面的代码中我们在给人员分配账户时给账户的balance属性添加了监听，并且在回调方法中输出了观察到的信息，同时在对象销毁时移除监听，这就构成了一个典型的KVO应用。</li>
</ul>
<h3 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h3><p>KVO高级应用，观察数组变化：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"ViewController.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,retain) <span class="built_in">NSMutableArray</span> *array;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.array = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    [<span class="keyword">self</span> addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"array"</span> options:<span class="built_in">NSKeyValueObservingOptionNew</span>|<span class="built_in">NSKeyValueObservingOptionOld</span> context:<span class="literal">nil</span>];</span><br><span class="line">    <span class="comment">//监听数组的时候，如果数组内容发生改变（增，删，替换）我们需要重写系统提供的方法，二个方法缺一不可，一个是插入方法，一个是删除方法</span></span><br><span class="line">    [<span class="keyword">self</span>.array addObject:<span class="string">@"111"</span>];</span><br><span class="line">    <span class="comment">//插入的时候change字典只打印new</span></span><br><span class="line">    [<span class="keyword">self</span> insertObject:<span class="string">@"12345"</span> inArrayAtIndex:<span class="number">0</span>];</span><br><span class="line">    <span class="comment">//删除的时候change字典只打印old</span></span><br><span class="line">    [<span class="keyword">self</span> removeObjectFromArrayAtIndex:<span class="number">0</span>];</span><br><span class="line">    <span class="comment">//替换元素</span></span><br><span class="line">    [<span class="keyword">self</span> replaceObjectInArrayAtIndex:<span class="number">0</span> withObject:<span class="string">@"654321"</span>];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(nullable <span class="built_in">NSString</span> *)keyPath ofObject:(nullable <span class="keyword">id</span>)object change:(nullable <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *,<span class="keyword">id</span>&gt; *)change context:(nullable <span class="keyword">void</span> *)context&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果监听多个属性，需要判断</span></span><br><span class="line">    <span class="keyword">if</span> ([keyPath isEqualToString:<span class="string">@"array"</span>]) &#123;</span><br><span class="line">        <span class="comment">//keyPath是观察者监听的属性，object就是被观察的对象，change是前后发生的改变，context是传递过来的参数</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"keyPath-&gt;%@  change-&gt;%@  context-&gt;%@"</span>,keyPath,change,context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重写插入方法</span></span><br><span class="line">- (<span class="keyword">void</span>)insertObject:(<span class="keyword">id</span> )object inArrayAtIndex:(<span class="built_in">NSUInteger</span>)index&#123;</span><br><span class="line">    [<span class="keyword">self</span>.array insertObject:object atIndex:index];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"a"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重写删除元素的方法</span></span><br><span class="line">- (<span class="keyword">void</span>)removeObjectFromArrayAtIndex:(<span class="built_in">NSUInteger</span>)index&#123;</span><br><span class="line">    [<span class="keyword">self</span>.array removeObjectAtIndex:index];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"b"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重写替换的方法</span></span><br><span class="line">- (<span class="keyword">void</span>)replaceObjectInArrayAtIndex:(<span class="built_in">NSUInteger</span>)index withObject:(<span class="keyword">id</span>)object&#123;</span><br><span class="line">    [<span class="keyword">self</span>.array replaceObjectAtIndex:index withObject:object];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"c"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.cnblogs.com/mjios/" target="_blank" rel="external">M了个J的博客</a></p>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[【14】键值编码（KVC）]]></title>
      <url>http://sanfordy.com/2016/08/31/%E3%80%96A%E3%80%97%E3%80%902-0%E3%80%91OC-%E8%AF%AD%E6%B3%95/%E3%80%9014%E3%80%91%E9%94%AE%E5%80%BC%E7%BC%96%E7%A0%81%EF%BC%88KVC%EF%BC%89/</url>
      <content type="html"><![CDATA[<blockquote>
<p>类的对象可以在类的外部对成员变量（就算成员变量是private也可以）进行动态读写，这种方式就是Key Value Coding（简称KVC）。</p>
</blockquote>
<a id="more"></a>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>类的对象可以在类的外部对成员变量（就算成员变量是private也可以）进行动态读写，这种方式就是<code>Key Value Coding</code>（简称<code>KVC</code>）。</p>
<p><code>KVC</code>的操作方法由<code>NSKeyValueCoding</code>协议提供，而<code>NSObject</code>就实现了这个协议，也就是说OC中几乎所有的对象都支持<code>KVC</code>操作，常用的<code>KVC</code>操作方法如下：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  动态设置：用于简单路径。</span></span><br><span class="line">setValue:属性值 forKey:属性名</span><br><span class="line"><span class="comment">//  动态设置：用于复合路径，例如Person有一个Account类型的属性，那么person.account就是一个复合路径。</span></span><br><span class="line">setValue:属性值 forKeyPath:属性路径</span><br><span class="line"></span><br><span class="line"><span class="comment">//  动态读取：用于简单路径</span></span><br><span class="line">valueForKey:属性名</span><br><span class="line"><span class="comment">//  动态读取：用于复合路径</span></span><br><span class="line">valueForKeyPath:属性名</span><br></pre></td></tr></table></figure>
<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>&lt; 代码示例 &gt;</p>
<p><em>Account.h</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Account</span> : <span class="title">NSObject</span></span>&#123;</span><br><span class="line">    <span class="keyword">@private</span></span><br><span class="line">    <span class="keyword">float</span> balance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>Account.m</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Account.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Account</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>Person.h</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@class</span> <span class="title">Account</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span>&#123;</span><br><span class="line">    <span class="keyword">@private</span></span><br><span class="line">    <span class="keyword">int</span> _age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 姓名</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="comment">// 账户</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,retain) Account *account;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>Person.m</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Person.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>main.m</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Person.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Account.h"</span></span></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        </span><br><span class="line">        Person *person1 = [[Person alloc] init];</span><br><span class="line">        <span class="comment">//  设置属性name</span></span><br><span class="line">        [person1 setValue:<span class="string">@"小明"</span> forKey:<span class="string">@"name"</span>];</span><br><span class="line">        <span class="comment">//  设置私有成员变量_age</span></span><br><span class="line">        [person1 setValue:@<span class="number">20</span> forKey:<span class="string">@"age"</span>];</span><br><span class="line">        <span class="comment">//  输出结果：person1's name is :小明,age is :20</span></span><br><span class="line">         <span class="built_in">NSLog</span>(<span class="string">@"person1's name is :%@,age is :%@"</span>,person1.name,[person1 valueForKey:<span class="string">@"age"</span>]);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//  也可以直接全部赋值</span></span><br><span class="line">        [person1 setValuesForKeysWithDictionary:@&#123;<span class="string">@"name"</span>:<span class="string">@"小刚"</span>,<span class="string">@"age"</span>:@<span class="number">18</span>&#125;];</span><br><span class="line">        <span class="comment">//  输出结果：person1's name is :小刚,age is :18</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"person1's name is :%@,age is :%@"</span>,person1.name,[person1 valueForKey:<span class="string">@"age"</span>]);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//  有两种方法可以给person的account属性赋值</span></span><br><span class="line">        <span class="comment">//  1.</span></span><br><span class="line">        Account *account1 = [[Account alloc] init];</span><br><span class="line">        [account1 setValue:@<span class="number">0.2</span> forKeyPath:<span class="string">@"balance"</span>];</span><br><span class="line">        [person1 setValue:account1 forKey:<span class="string">@"account"</span>];</span><br><span class="line">        <span class="comment">//  输出结果：person1's balance is :0.20</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"person1's balance is :%.2f"</span>,[[person1.account valueForKey:<span class="string">@"balance"</span>] floatValue]);</span><br><span class="line">        <span class="comment">//  2.</span></span><br><span class="line">        [person1 setValue:@<span class="number">0.3</span> forKeyPath:<span class="string">@"account.balance"</span>];</span><br><span class="line">        <span class="comment">//  输出结果：person1's balance is :0.30</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"person1's balance is :%.2f"</span>,[[person1 valueForKeyPath:<span class="string">@"account.balance"</span>] floatValue]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="KVC使用注意"><a href="#KVC使用注意" class="headerlink" title="KVC使用注意"></a>KVC使用注意</h2><p>KVC使用起来比较简单，但是它如何查找一个属性进行读取呢？具体查找规则（假设现在要利用KVC对person的name属性进行读取）：</p>
<ol>
<li>如果是动态设置属性，首先KVC先找有没有name属性，会通过name属性的setter方法给_name成员变量赋值，如果没找到name属性，会找_name成员变量给_name赋值，如果没找到_name这个成员变量，会找name这个成员变量给name赋值，如果name这个成员变量也没找到则会调用person的setValue:forUndefinedKey：方法。</li>
<li>如果是动态读取属性，首先KVC先找有没有name属性，会通过name属性的getter方法返回_name成员变量的值，如果没找到name属性，会找_name成员变量作为返回值，如果没找到_name这个成员变量，会找name这个成员变量作为返回值，如果name这个成员变量也没找到则会调用person的valueforUndefinedKey:方法。</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.cnblogs.com/mjios/" target="_blank" rel="external">M了个J的博客</a></p>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[【13】OC语法特性（四）：延展Extension]]></title>
      <url>http://sanfordy.com/2016/08/31/%E3%80%96A%E3%80%97%E3%80%902-0%E3%80%91OC-%E8%AF%AD%E6%B3%95/%E3%80%9013%E3%80%91OC%E8%AF%AD%E6%B3%95%E7%89%B9%E6%80%A7%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E5%BB%B6%E5%B1%95Extension/</url>
      <content type="html"><![CDATA[<blockquote>
<p>在设计一个类的时候，有些方法需要对外公开（我们称之为接口），有些方法仅仅在内部使用，这时候可以借助延展（Extension）。</p>
</blockquote>
<a id="more"></a>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>在设计一个类的时候，有些方法需要对外公开（我们称之为接口），有些方法仅仅在内部使用，这时候可以借助延展（Extension）。</p>
<p>Extension的主要作用是扩展类的成员变量，属性，私有方法。</p>
<p>Extension的语法格式和Category很相似，相当于把Category的.h文件挪到了原始类的.m文件中。</p>
<p>Extension针对的是我们自己的类，必须有源代码的类。</p>
<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>&lt; 代码示例 &gt;</p>
<p><em>Person.h</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)eatFood;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>Person.m</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Person.h"</span></span></span><br><span class="line"><span class="comment">//  #import和@interface不能挨在一起;</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> ()</span></span><br><span class="line"><span class="comment">//  延展所管理的私有方法肯定需要在当前类的某个方法实现内部调用,否则就没有意义;</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)_drinkCola;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)eatFood&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"小明一边吃东西一边%@"</span>,[<span class="keyword">self</span> _drinkCola]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)_drinkCola&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">@"喝可乐"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>main.m</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Person.h"</span></span></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        Person *person = [[Person alloc] init];</span><br><span class="line">        [person eatFood];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2015-12-29 23:31:57.985 Person[7525:78662] 小明一边吃东西一边喝可乐</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<h2 id="Category和Extension的区别"><a href="#Category和Extension的区别" class="headerlink" title="Category和Extension的区别"></a>Category和Extension的区别</h2><ol>
<li>作用：<ul>
<li>Category：为没有源码的类添加方法。</li>
<li>Extension：为自定义的类添加私有方法，属性等。</li>
</ul>
</li>
<li>格式：<ul>
<li>Category：定义一对.h和.m。</li>
<li>Extension：把代码写到原始类的.m文件中。</li>
</ul>
</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.cnblogs.com/mjios/" target="_blank" rel="external">M了个J的博客</a></p>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[【12】OC语法特性（三）：分类Category]]></title>
      <url>http://sanfordy.com/2016/08/30/%E3%80%96A%E3%80%97%E3%80%902-0%E3%80%91OC-%E8%AF%AD%E6%B3%95/%E3%80%9012%E3%80%91OC%E8%AF%AD%E6%B3%95%E7%89%B9%E6%80%A7%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%88%86%E7%B1%BBCategory/</url>
      <content type="html"><![CDATA[<blockquote>
<p>当我们不改变原有代码为一个类扩展其他功能时我们可以考虑继承这个类进行实现，但是这样一来使用时就必须定义成新实现的子类才能拥有扩展的新功能。如何在不改变原有类的情况下扩展新功能又可以在使用时不必定义新类型呢？</p>
</blockquote>
<a id="more"></a>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>当我们不改变原有代码为一个类扩展其他功能时我们可以考虑继承这个类进行实现，但是这样一来使用时就必须定义成新实现的子类才能拥有扩展的新功能。如何在不改变原有类的情况下扩展新功能又可以在使用时不必定义新类型呢？</p>
<p>利用分类我们就可以在OC中动态的为已有类添加新的方法，通过分类添加的方法会成为原类的一部分，从而达到拓展一个类功能的目的。</p>
<blockquote>
<p><strong>注意</strong>：分类主要为系统或框架中的类（即没有源码的类）拓展功能。</p>
</blockquote>
<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>创建分类：commang+n-&gt;Objective-C File-&gt;分别填写File（分类名），File Type（文件类型选择category），Class（作为哪个类的分类）。</p>
<h3 id="为系统类添加分类"><a href="#为系统类添加分类" class="headerlink" title="为系统类添加分类"></a>为系统类添加分类</h3><p>&lt; 代码示例 &gt;</p>
<p><em>NSString+Category.h</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSString</span> (<span class="title">Category</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)stringByTrim;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>NSString+Category.m</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"NSString+Category.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSString</span> (<span class="title">Category</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)stringByTrim&#123;</span><br><span class="line">    <span class="built_in">NSCharacterSet</span> *character = [<span class="built_in">NSCharacterSet</span> whitespaceCharacterSet];</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> stringByTrimmingCharactersInSet:character];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>main.m</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"NSString+Category.h"</span></span></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *name=<span class="string">@"    xiaoming    "</span>;</span><br><span class="line">        name=[name stringByTrim];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"I'm %@!"</span>,name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2015-12-29 18:10:34.077 55[60931:704008] I&apos;m xiaoming!</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<h3 id="为自定义类添加分类"><a href="#为自定义类添加分类" class="headerlink" title="为自定义类添加分类"></a>为自定义类添加分类</h3><p>&lt; 代码示例 &gt;</p>
<p><em>Person.h</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>Person.m</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Person.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>Person+Study.h</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Person.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> (<span class="title">Study</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)study;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>Person+Study.m</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Person+Study.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span> (<span class="title">Study</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)study&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"调用了person分类的study方法"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>main.m</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Person+Study.h"</span></span></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        Person *person = [[Person alloc] init];</span><br><span class="line">        <span class="comment">//  调用分类中的方法</span></span><br><span class="line">        [person study];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2015-12-29 18:17:21.867 55[61347:709115] 调用了person分类的study方法</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<h2 id="分类的使用注意"><a href="#分类的使用注意" class="headerlink" title="分类的使用注意"></a>分类的使用注意</h2><ol>
<li>分类一般只增加方法（包括类方法和对象方法），不增加成员变量。</li>
<li>在分类方法的实现中可以访问原来类中的成员变量。</li>
<li>分类中可以重新实现原来类中的方法，但是会覆盖掉原来的方法，导致原来的方法无法再使用（警告）。</li>
<li>方法调用的优先级：分类-&gt;原来的类-&gt;父类，若包含有多个分类，则最后参与编译的分类优先。</li>
<li>在很多的情况下，往往是给系统自带的类添加分类，如NSObject和NSString，因为有的时候，系统类可能并不能满足我们的要求。</li>
<li>在大规模的应用中，通常把相应的功能写成一个分类，可以有无限个分类，对原有类进行扩充，一般分模块写，一个模块一个分类。</li>
</ol>
<h2 id="分类和子类的区别"><a href="#分类和子类的区别" class="headerlink" title="分类和子类的区别"></a>分类和子类的区别</h2><p>分类：只能为类添加方法，新添加的方法会成为原始类的一部分，能被子类继承。</p>
<p>子类：既能为类添加方法也能为类添加变量，新添加的方法只有子类有，父类不具有。</p>
<h2 id="类的深入研究"><a href="#类的深入研究" class="headerlink" title="类的深入研究"></a>类的深入研究</h2><h3 id="类的本质"><a href="#类的本质" class="headerlink" title="类的本质"></a>类的本质</h3><p>类本身也是一个对象，是class类型的对象，简称“类对象”。</p>
<p>class类型的定义：Typedef struct obj class *class;</p>
<p>类名就代表着类对象，每个类只有一个类对象。</p>
<h3 id="获取内存中的类对象"><a href="#获取内存中的类对象" class="headerlink" title="获取内存中的类对象"></a>获取内存中的类对象</h3><p>获取内存中的类对象的方法：</p>
<p>&lt; 代码示例 &gt;</p>
<p><em>main.m</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Person"</span></span></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        Person *person = [[Person alloc] init];</span><br><span class="line">        <span class="comment">//　1.类对象发送class消息</span></span><br><span class="line">        Class c1 = [person class];</span><br><span class="line">        <span class="comment">//　2.类本身发送class消息</span></span><br><span class="line">        Class c2 = [Person class];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"c1类名-&gt;%@,c2类名-&gt;%@   c1类地址%p,c2类地址%p"</span>,c1,c2,c1,c2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="类的加载和初始化"><a href="#类的加载和初始化" class="headerlink" title="类的加载和初始化"></a>类的加载和初始化</h3><p>&lt; 代码示例 &gt;</p>
<p><em>main.m</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="comment">//  Person类的声明</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="comment">//  Person类的实现</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)load&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Person + load"</span>);</span><br><span class="line">&#125;</span><br><span class="line">+ (<span class="keyword">void</span>)initialize&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Person + initialize"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  Studnet类的声明</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Student</span> : <span class="title">Person</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="comment">//  Student类的实现</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Student</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)load&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Student + load"</span>);</span><br><span class="line">&#125;</span><br><span class="line">+ (<span class="keyword">void</span>)initialize&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Student + initialize"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="comment">//  第一次使用Person类创建对象</span></span><br><span class="line">        Person *person1 = [[Person alloc] init];</span><br><span class="line">        <span class="comment">//  第二次使用Person类创建对象</span></span><br><span class="line">        Person *person2 = [[Person alloc] init];</span><br><span class="line">        <span class="comment">//  第一次使用Student类创建对象</span></span><br><span class="line">        Student *student = [[Student alloc] init];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2015-12-29 18:49:53.070 66[63170:730841] Person + load</span><br><span class="line">2015-12-29 18:49:53.071 66[63170:730841] Student + load</span><br><span class="line">2015-12-29 18:49:53.072 66[63170:730841] Person + initialize</span><br><span class="line">2015-12-29 18:49:53.072 66[63170:730841] Student + initialize</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>当程序启动时，就会加载项目中所有的类和分类，而且加载后会调用每个类和分类的+load方法，只会调用一次。</li>
<li>当第一次使用某个类时，就会调用当前类的+initialize方法。</li>
<li>先加载父类，再加载子类（先调用父类的+load方法，再调用子类的+load方法，最后调用分类的+load方法），先初始化父类，再初始化子类（先调用父类的+initialize方法，再调用子类的+initialize方法）。</li>
<li>在初始化的时候，如果在分类中重写了+initialize方法，则会覆盖掉父类的。</li>
<li>重写+initialize方法可以监听类的使用情况。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.cnblogs.com/mjios/" target="_blank" rel="external">M了个J的博客</a></p>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[【11】OC语法特性（二）：块语法Block]]></title>
      <url>http://sanfordy.com/2016/08/30/%E3%80%96A%E3%80%97%E3%80%902-0%E3%80%91OC-%E8%AF%AD%E6%B3%95/%E3%80%9011%E3%80%91OC%E8%AF%AD%E6%B3%95%E7%89%B9%E6%80%A7%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%9D%97%E8%AF%AD%E6%B3%95Block/</url>
      <content type="html"><![CDATA[<blockquote>
<p>Block：块语法，本质上是匿名函数（没有名称的函数），苹果推荐的类型，效率高，用来封装和保存代码，Block可以在任何时候执行。</p>
</blockquote>
<a id="more"></a>
<h2 id="知识回顾"><a href="#知识回顾" class="headerlink" title="知识回顾"></a>知识回顾</h2><p>Block语法和函数指针很相似，首先让我们来复习一下函数的知识。</p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>在C语言中，函数是用来实现某一功能的代码片段，完整的函数包含<code>函数声明</code>、<code>函数实现</code>两部分：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  函数声明</span></span><br><span class="line"><span class="keyword">int</span> sum(<span class="keyword">int</span> x,<span class="keyword">int</span> y);</span><br><span class="line"></span><br><span class="line"><span class="comment">//  函数实现</span></span><br><span class="line"><span class="keyword">int</span> sum(<span class="keyword">int</span> x,<span class="keyword">int</span> y)&#123;</span><br><span class="line"> retrun x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h3><p>函数指针是存放函数地址（函数名）的指针变量：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (*p)(<span class="keyword">int</span> x,<span class="keyword">int</span> y) = sum;</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>函数指针类型：int (*)(int ,int ) ，即：指向两个整型参数，一个整型返回值函数的指针。</li>
<li>函数指针变量：p </li>
<li>函数指针的值：sum</li>
</ul>
<h2 id="Block的概念"><a href="#Block的概念" class="headerlink" title="Block的概念"></a>Block的概念</h2><p>Block：块语法，本质上是匿名函数（没有名称的函数），苹果推荐的类型，效率高，用来封装和保存代码，Block可以在任何时候执行。</p>
<p>标准C里面没有Block，C语言的后期扩展版本，加入了匿名函数，C++、JS、Swift等语言，有类似语法，叫做闭包。 </p>
<p>Block和函数的相似性：</p>
<ol>
<li>可以保存代码。</li>
<li>有返回值。</li>
<li>有形参。</li>
<li>调用方式一样。</li>
</ol>
<p>blcok通常作为参数使用进行回调：利用Block你可以将一个操作作为一个参数进行传递（是不是想起了C语言中的函数指针）。　　</p>
<p>Block变量的定义与函数指针变量的定义类似，唯一区别于函数指针变量的是变量名前通过脱字符<code>^</code>修饰。</p>
<h2 id="Block的语法"><a href="#Block的语法" class="headerlink" title="Block的语法"></a>Block的语法</h2><p><img src="http://images2015.cnblogs.com/blog/776348/201608/776348-20160830225134168-105359227.png" alt=""></p>
<ul>
<li>Block类型：<code>int (^)(int)</code></li>
<li>Block变量：<code>myBlock</code></li>
<li>Block值:<code>^ int (int num){ return num * mutiplier;}</code>，即：^ 返回值类型 (参数列表){函数体}，编译器可以根据block对象中的return语句，自动判断返回类型。所以可以忽略返回类型。 </li>
</ul>
<blockquote>
<p><strong>注意</strong>：Block变量在定义时具有变量定义的基本特征，赋值号右侧的匿名函数可以当做一个整体被赋值（红色部分），类似于int a = 5。</p>
</blockquote>
<h2 id="Block的使用"><a href="#Block的使用" class="headerlink" title="Block的使用"></a>Block的使用</h2><h3 id="Block的简单使用一"><a href="#Block的简单使用一" class="headerlink" title="Block的简单使用一"></a>Block的简单使用一</h3><p>&lt; 代码示例 &gt;</p>
<p><em>main.m</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="comment">//  block变量所赋的值是匿名函数，又兼具函数的特征，并且是唯一可以定义在某个函数实现内部的（C语言中认为函数是不能嵌套定义的，block是个特例）</span></span><br><span class="line">        <span class="keyword">int</span> (^sumBlock)(<span class="built_in">NSNumber</span> *,<span class="built_in">NSNumber</span> *) = ^(<span class="built_in">NSNumber</span> * num1,<span class="built_in">NSNumber</span> *num2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> [num1 intValue] + [num2 intValue];</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%i"</span>,sumBlock(@<span class="number">33</span>,@<span class="number">22</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2015-12-29 15:02:28.166 33[52958:611533] 55</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<h3 id="Block的简单使用二"><a href="#Block的简单使用二" class="headerlink" title="Block的简单使用二"></a>Block的简单使用二</h3><p>&lt; 代码示例 &gt;</p>
<p><em>main.m</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> (^myblock)(<span class="built_in">NSString</span> *) = ^(<span class="built_in">NSString</span> *string)&#123;</span><br><span class="line">    <span class="keyword">return</span> [string intValue];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%d"</span>,myblock(<span class="string">@"123"</span>) + <span class="number">22</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2015-12-29 15:06:31.110 33[53181:614255] 145</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<h3 id="Block进行typedef"><a href="#Block进行typedef" class="headerlink" title="Block进行typedef"></a>Block进行typedef</h3><p>&lt; 代码示例 &gt;</p>
<p><em>main.m</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="comment">//　新类型:BlockType</span></span><br><span class="line"><span class="comment">//　原类型:int (^)(int x,int y)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> (^BlockType)(<span class="keyword">int</span>,<span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="comment">//  使用新类型计算x+y</span></span><br><span class="line">        BlockType block1 = ^(<span class="keyword">int</span> x,<span class="keyword">int</span> y)&#123;</span><br><span class="line">            <span class="keyword">return</span> x + y;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%i"</span>,block1(<span class="number">5</span>,<span class="number">5</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//  使用原类型计算x+y</span></span><br><span class="line">        <span class="keyword">int</span>(^block2)(<span class="keyword">int</span>,<span class="keyword">int</span>) = ^(<span class="keyword">int</span> x,<span class="keyword">int</span> y)&#123;</span><br><span class="line">            <span class="keyword">return</span> x + y;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%i"</span>,block2(<span class="number">1</span>,<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2015-12-29 15:31:15.747 44[54586:631086] 10</span><br><span class="line">2015-12-29 15:31:15.747 44[54586:631086] 2</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<h3 id="Block作为方法参数实现回调"><a href="#Block作为方法参数实现回调" class="headerlink" title="Block作为方法参数实现回调"></a>Block作为方法参数实现回调</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"ViewController.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>(^BlockType)(<span class="built_in">UIColor</span> *color);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIButton</span> *testbtn;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="keyword">self</span>.testbtn = [<span class="built_in">UIButton</span> buttonWithType:<span class="built_in">UIButtonTypeSystem</span>];</span><br><span class="line">    <span class="keyword">self</span>.testbtn.frame = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">200</span>, <span class="number">200</span>, <span class="number">40</span>);</span><br><span class="line">    <span class="keyword">self</span>.testbtn.backgroundColor = [<span class="built_in">UIColor</span> greenColor];</span><br><span class="line">    [<span class="keyword">self</span>.view addSubview:<span class="keyword">self</span>.testbtn];</span><br><span class="line">    [<span class="keyword">self</span>.testbtn addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(testfunc) forControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  按钮方法</span></span><br><span class="line">- (<span class="keyword">void</span>)testfunc&#123;</span><br><span class="line">    <span class="comment">//  回调</span></span><br><span class="line">    [<span class="keyword">self</span> changecolor:^(<span class="built_in">UIColor</span> *color) &#123;<span class="comment">// 2.</span></span><br><span class="line">        <span class="keyword">self</span>.testbtn.backgroundColor = color;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">- (<span class="keyword">void</span>)changecolor:(BlockType)block&#123;</span><br><span class="line">    block([<span class="built_in">UIColor</span> redColor]);<span class="comment">// 1.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h2 id="Block与局部变量"><a href="#Block与局部变量" class="headerlink" title="Block与局部变量"></a>Block与局部变量</h2><p>&lt; 代码示例 &gt;</p>
<p><em>main.m</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="comment">//  blcok内部，可以使用外界的局部变量</span></span><br><span class="line">        <span class="keyword">int</span> num1 = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//  __block修饰后可以修改局部变量</span></span><br><span class="line">        __block <span class="keyword">int</span> num2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">void</span>(^addNum)() = ^()&#123;</span><br><span class="line">            <span class="keyword">int</span> c = num1 *<span class="number">10</span>;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%d"</span>,c);</span><br><span class="line"><span class="comment">//            num1++;会报错，内部不能修改外届的局部变量</span></span><br><span class="line">            num2++;<span class="comment">//   不会报错，内部可以修改外界的局部变量</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%d"</span>,num2);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//  调用block</span></span><br><span class="line">        addNum();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2015-12-29 15:49:26.263 44[55605:643879] 10</span><br><span class="line">2015-12-29 15:49:26.264 44[55605:643879] 2</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<h2 id="Block与全局变量"><a href="#Block与全局变量" class="headerlink" title="Block与全局变量"></a>Block与全局变量</h2><p>&lt; 代码示例 &gt;</p>
<p><em>main.m</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">200</span>;</span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="comment">//  在Blcok块语法中访问全局变量</span></span><br><span class="line">        <span class="keyword">void</span>(^addNum)(<span class="keyword">void</span>) = ^(<span class="keyword">void</span>)&#123;</span><br><span class="line">          <span class="comment">//  可以访问到全局变量，并且可以修改全局变量</span></span><br><span class="line">            count++;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%d"</span>,count);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//  调用</span></span><br><span class="line">        addNum();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2015-12-29 15:47:49.677 44[55508:642595] 201</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<h2 id="Block与数组排序"><a href="#Block与数组排序" class="headerlink" title="Block与数组排序"></a>Block与数组排序</h2><p>&lt; 代码示例 &gt;</p>
<p><em>main.m</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSArray</span> *array = @[@<span class="number">1</span>,@<span class="number">16</span>,@<span class="number">8</span>,@<span class="number">10</span>,@<span class="number">12</span>];</span><br><span class="line">    <span class="comment">//  1.第一种排序（降序）</span></span><br><span class="line">    <span class="built_in">NSComparator</span> sortBlock = ^(<span class="keyword">id</span> obj1,<span class="keyword">id</span> obj2)&#123;</span><br><span class="line">        <span class="keyword">return</span> [obj2 compare: obj1];</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//  在这一行调用了sortBlock比较器,在此之前，sortBlock比较器只是被编译了。</span></span><br><span class="line">    <span class="built_in">NSArray</span> *resultArray1 = [array sortedArrayUsingComparator:sortBlock];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,resultArray1);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  2.第二种排序（升序）</span></span><br><span class="line">    <span class="built_in">NSArray</span> *resultArray2 = [array sortedArrayUsingComparator:^<span class="built_in">NSComparisonResult</span>(<span class="keyword">id</span> obj1, <span class="keyword">id</span> obj2) &#123;</span><br><span class="line">        <span class="keyword">return</span> [obj1 compare:obj2];</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,resultArray2);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">2015-12-29 16:10:17.172 OC10[56842:657123] (</span><br><span class="line">    16,</span><br><span class="line">    12,</span><br><span class="line">    10,</span><br><span class="line">    8,</span><br><span class="line">    1</span><br><span class="line">)</span><br><span class="line">2015-12-29 16:10:17.173 OC10[56842:657123] (</span><br><span class="line">    1,</span><br><span class="line">    8,</span><br><span class="line">    10,</span><br><span class="line">    12,</span><br><span class="line">    16</span><br><span class="line">)</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<h2 id="ARC-amp-MRC下循环引用问题"><a href="#ARC-amp-MRC下循环引用问题" class="headerlink" title="ARC&amp;MRC下循环引用问题"></a>ARC&amp;MRC下循环引用问题</h2><p>循环引用是另一个使用Block时常见的问题。</p>
<h3 id="ARC"><a href="#ARC" class="headerlink" title="ARC"></a>ARC</h3><p>在ARC下，由于<code>__block</code>抓取的变量一样会被Block retain，所以必须用弱引用才可以解决循环引用问题，iOS 5之后可以直接使用<code>__weak</code>，之前则只能使用<code>__unsafe_unretained</code>了，<code>__unsafe_unretained</code>缺点是指针释放后自己不会置空：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line"><span class="keyword">self</span>.myBlock = ^(<span class="keyword">int</span> paramInt)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//使用weakSelf访问self成员</span></span><br><span class="line">    [weakSelf anotherFunc];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="MRC"><a href="#MRC" class="headerlink" title="MRC"></a>MRC</h3><p>在非ARC下，显然无法使用弱引用，这里就可以直接使用<code>__block</code>来修饰变量，它不会被Block所retain的，参考代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__block <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line"><span class="keyword">self</span>.myBlock = ^(<span class="keyword">int</span> paramInt)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//使用weakSelf访问self成员</span></span><br><span class="line">    [weakSelf anotherFunc];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.cnblogs.com/mjios/" target="_blank" rel="external">M了个J的博客</a></p>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[【10】OC语法特性（一）：协议protocol]]></title>
      <url>http://sanfordy.com/2016/08/30/%E3%80%96A%E3%80%97%E3%80%902-0%E3%80%91OC-%E8%AF%AD%E6%B3%95/%E3%80%9010%E3%80%91OC%E8%AF%AD%E6%B3%95%E7%89%B9%E6%80%A7%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%8D%8F%E8%AE%AEprotocol/</url>
      <content type="html"><![CDATA[<blockquote>
<p>协议是一套标准（一堆方法的声明），只有.h文件。就像一张任务清单，上面写了一堆需要处理的事，清单交给谁，谁就要去完成清单上规定的任务。</p>
</blockquote>
<a id="more"></a>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ol>
<li>协议是一套标准（一堆方法的声明），只有.h文件。就像一张任务清单，上面写了一堆需要处理的事，清单交给谁，谁就要去完成清单上规定的任务。</li>
<li>协议在声明的时候以关键字@protocol开始，以@end结束，类似于类的声明。</li>
<li>只要某个类遵守了这个协议，就拥有了这个协议中的所有方法声明。</li>
<li>只要父类遵守了某个协议，那么子类也遵守。</li>
<li>一个类不能继承于多个类（单继承）但是能够遵守多个协议。继承(:)，遵守协议（&lt; &gt;）</li>
<li>基协议：<nsobject>是基协议，是最根本最基本的协议，其中声明了很多最基本的方法。</nsobject></li>
<li>协议可以拓展协议，一个协议拓展了另一个协议，就可以拥有另一份协议中的方法声明。</li>
</ol>
<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><h3 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h3><p>首先创建一个protocol的头文件：command+n -&gt; Source -&gt; Objective-C File -&gt; File Type -&gt; Protocol。</p>
<p>&lt; 代码示例 &gt;</p>
<p><em>main.m</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"MyClass.h"</span></span></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//  创建MyClass实例</span></span><br><span class="line">        MyClass *obj = [[MyClass alloc] init];</span><br><span class="line">        <span class="comment">//  MyClass实例调用自己已经实现了的方法</span></span><br><span class="line">        [obj printA];</span><br><span class="line">        [obj printB];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>Myprotocol.h</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  Myprotocol协议，这个协议遵守了基协议&lt;NSObject&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">Myprotocol</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  @required关键字，要求接受协议的类必须实现该方法。</span></span><br><span class="line"><span class="keyword">@required</span></span><br><span class="line">- (<span class="keyword">void</span>)printA;</span><br><span class="line"><span class="comment">//  @optional关键字，接受协议的类没必要实现该方法</span></span><br><span class="line"><span class="keyword">@optional</span></span><br><span class="line">- (<span class="keyword">void</span>)printB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>MyClass.h</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Myprotocol.h"</span>//   在类的声明中引入协议的头文件才可以遵守该协议</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  MyClass继承与NSObject类并遵守了Myprotocol协议，那么Myclass就必须实现Myprotocol中@required的方法</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyClass</span> : <span class="title">NSObject</span>&lt;<span class="title">Myprotocol</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>MyClass.m</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"MyClass.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyClass</span></span></span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)printA&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"AAAAAA"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  该方法没要求必须实现</span></span><br><span class="line">- (<span class="keyword">void</span>)printB&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"BBBBBB"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2016-01-25 21:20:39.189 协议[30474:1955287] AAAAAA</span><br><span class="line">2016-01-25 21:20:39.192 协议[30474:1955287] BBBBBB</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<h3 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h3><p>下面以男孩接受女孩定的结婚协议来用代码实现：</p>
<p>&lt; 代码示例 &gt;</p>
<p><em>main.m</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Boy.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Girl.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span><br><span class="line">&#123;</span><br><span class="line">    Boy *aBoy = [[Boy alloc] init];</span><br><span class="line">    aBoy.name = <span class="string">@"小明"</span>;</span><br><span class="line">    <span class="comment">//  判断协议里的washCloshs方法是否被响应，如果响应成功，就可以调用这个方法。</span></span><br><span class="line">    <span class="keyword">if</span> ([aBoy respondsToSelector:<span class="keyword">@selector</span>(washCloths:)])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *cloths = <span class="string">@"内裤"</span>;</span><br><span class="line">        [aBoy washCloths:cloths];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Girl *aGirl = [[Girl alloc] init];</span><br><span class="line">    aGirl.name = <span class="string">@"凤姐"</span>;</span><br><span class="line">    <span class="comment">//  产生代理关系的重点，就是让委托方知道自己的代理对象是谁</span></span><br><span class="line">    aGirl.husband = aBoy;</span><br><span class="line">    [aGirl notifyHusband];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>Girl.h</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="comment">/*</span><br><span class="line"> 注意：这里我们没有把协议单独写成一个.h文件，而是写入了委托方的.h文件里，以后这是非常常见的</span><br><span class="line"> </span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  一般情况下，协议都是扩展自NSObject协议（可以将NSObject理解为协议模板）</span></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">MarryProtocol</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"><span class="comment">//  定义的协议方法，一旦被遵守就必须要实现(默认的关键字)</span></span><br><span class="line"><span class="keyword">@required</span></span><br><span class="line"><span class="comment">//  挣钱方法（如果协议方法有返回值，表示代理对象主动给委托方传值）</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)makeMoney;</span><br><span class="line"><span class="comment">//  定义的协议方法可以实现也可以不实现，表示可选的</span></span><br><span class="line"><span class="keyword">@optional</span></span><br><span class="line"><span class="comment">//  洗衣服方法（如果协议方法有参数，表示委托方主动给代理对象传值）</span></span><br><span class="line">- (<span class="keyword">void</span>)washCloths:(<span class="built_in">NSString</span> *)cloths;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Girl</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,retain ) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="comment">//  id&lt;协议名&gt;遵守该协议的对象的名字,这个类型一般是限定代理对象是某一个id类型的遵守指定协议的属性husband</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">assign</span>) <span class="keyword">id</span> &lt; MarryProtocol &gt;husband;</span><br><span class="line"><span class="comment">//  通知自己的老公</span></span><br><span class="line">- (<span class="keyword">void</span>)notifyHusband;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>Girl.m</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Girl.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Girl</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)notifyHusband</span><br><span class="line">&#123;   <span class="comment">//当委托方发起通知，让代理对象执行方法时，首先需要判断自己的代理对象是否存在，并且需要判断代理对象是否能够响应指定的协议方法，如果条件同时成立，才可以让代理对象执行协议方法。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.husband &amp;&amp;[<span class="keyword">self</span>.husband respondsToSelector:<span class="keyword">@selector</span>(makeMoney)]) &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *money = [<span class="keyword">self</span>.husband makeMoney];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@收到了%@块钱"</span>,<span class="keyword">self</span>.name,money);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.husband &amp;&amp;[<span class="keyword">self</span>.husband respondsToSelector:<span class="keyword">@selector</span>(washCloths:)])&#123;</span><br><span class="line">        </span><br><span class="line">        [<span class="keyword">self</span>.husband washCloths:<span class="string">@"胸罩"</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>Boy.h</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Girl.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  Boy类的声明，这个类继承与NSObject类，并且遵守了MarryProtocol协议</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Boy</span> : <span class="title">NSObject</span>&lt;<span class="title">MarryProtocol</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,retain) <span class="built_in">NSString</span> * name;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>Boy.m</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Boy.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Boy</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - MarrayProtocol </span></span><br><span class="line">- (<span class="built_in">NSString</span> *)makeMoney</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@在赚钱"</span>,<span class="keyword">self</span>.name);</span><br><span class="line">    <span class="built_in">NSString</span> *money = <span class="string">@"100"</span>;</span><br><span class="line">    <span class="keyword">return</span> money;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)washCloths:(<span class="built_in">NSString</span> *)cloths</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@在洗%@"</span>,<span class="keyword">self</span>.name,cloths);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2015-12-08 17:19:16.984 OC1[96797:1916149] 小明在洗内裤</span><br><span class="line">2015-12-08 17:19:16.985 OC1[96797:1916149] 小明在赚钱</span><br><span class="line">2015-12-08 17:19:16.986 OC1[96797:1916149] 凤姐收到了100块钱</span><br><span class="line">2015-12-08 17:19:16.986 OC1[96797:1916149] 小明在洗胸罩</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<h2 id="协议的使用注意"><a href="#协议的使用注意" class="headerlink" title="协议的使用注意"></a>协议的使用注意</h2><ol>
<li>一个协议可以扩展自另一个协议，例如上面MarryProtocol就扩展自NSObject，如果需要扩展多个协议中间使用逗号分隔。</li>
<li>协议中定义的方法不一定是必须实现的，我们可以通过关键字进行@required和@optional进行设置，如果不设置则默认是@required（注意OC是弱语法，即使不实现必选方法编译运行也不会报错）。</li>
<li>协议通过&lt;&gt;进行实现，一个类可以同时实现多个协议，中间通过逗号分隔。</li>
<li>协议的实现只能在类的声明上，不能放到类的实现上（也就是说必须写成@interface Person:NSObject<marryprotocol>而不能写成@implementation Person<marryprotocol>）。</marryprotocol></marryprotocol></li>
<li>协议中一般不能声明属性，只声明方法。</li>
<li>事实上在OC中协议的更多作用是用于约束一个类必须实现某些方法，而面向对象的角度而言这个类跟接口并不一定存在某种自然关系，可能是两个完全不同意义上的事物，这种模式我们称之为代理模式（Delegation）。在Cocoa框架中大量采用这种模式实现数据和UI的分离，而且基本上所有的协议名都是以Delegate结尾。</li>
<li>协议本身写在.h头文件中，但也可以定义在任何地方。当这个协议只有这个类使用遵守时，一般把协议写在这个类里边，当这个协议需要多个类去实现时，就写在外边单独的文件中。 </li>
<li>使用代理设置模式能够松耦合。</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.cnblogs.com/mjios/" target="_blank" rel="external">M了个J的博客</a></p>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[【09】OC面向对象特性（三）：多态]]></title>
      <url>http://sanfordy.com/2016/08/30/%E3%80%96A%E3%80%97%E3%80%902-0%E3%80%91OC-%E8%AF%AD%E6%B3%95/%E3%80%9009%E3%80%91OC%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%89%B9%E6%80%A7%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%A4%9A%E6%80%81/</url>
      <content type="html"><![CDATA[<blockquote>
<p>不同类型对象在响应同一个方法时的不同实现叫做多态。意思就是假设生物类（life）都用有一个相同的方法-eat;那人类属于生物，猪也属于生物，都继承了life后，实现各自的eat，但是调用是我们只需调用各自的eat方法。也就是不同的对象以 自己的方式响应了相同的消息（响应了eat这个选择器）。</p>
</blockquote>
<a id="more"></a>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>不同类型对象在响应同一个方法时的不同实现叫做多态。意思就是假设生物类（life）都用有一个相同的方法-eat;那人类属于生物，猪也属于生物，都继承了life后，实现各自的eat，但是调用是我们只需调用各自的eat方法。也就是不同的对象以 自己的方式响应了相同的消息（响应了eat这个选择器）。</p>
<p>多态在代码中的体现是父类指针指向其子类对象，即为多种形态，必须要有继承，没有继承就没有多态。</p>
<p>在使用多态时，会进行动态检测，以调用真实的对象方法。</p>
<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p><em>Animal.h</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="comment">//  声明一个Animal类，该类继承自 NSObject</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Animal</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  Animal类中声明一个eat的对象方法</span></span><br><span class="line">- (<span class="keyword">void</span>)eat;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>Animal.m</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Animal.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="comment">//  eat对象方法的实现</span></span><br><span class="line">- (<span class="keyword">void</span>)eat&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"动物吃东西"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>Dog.h</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Animal.h"</span></span></span><br><span class="line"><span class="comment">//  Dog类继承自Animal类，拥有了Animal类中的所有属性和方法</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Dog</span> : <span class="title">Animal</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  在子类中声明了父类中已经有的eat方法，这称之为方法的重写</span></span><br><span class="line">- (<span class="keyword">void</span>)eat;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>Dog.m</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Dog.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Dog</span></span></span><br><span class="line"><span class="comment">//  重写eat类</span></span><br><span class="line">- (<span class="keyword">void</span>)eat&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"狗吃东西"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>main.m</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Dog.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Animal.h"</span></span></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="comment">//  Dog类型的指针指向了Dog类型的对象</span></span><br><span class="line">        Dog *dog = [[Dog alloc] init];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//  Dog类对象调用对象方法</span></span><br><span class="line">        [dog eat];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//  多态，父类指针指向了子类对象</span></span><br><span class="line">        Animal *animal1 = [[Dog alloc] init];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//  请问这里调用的是哪个方法?</span></span><br><span class="line">        [animal1 eat];<span class="comment">//    动态检测-调用方法时会检测对象的真实类型</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//  Animal类型的指针指向了Animal类型的对象</span></span><br><span class="line">        Animal *animal2 = [[Animal alloc] init];</span><br><span class="line">        [animal2 eat];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//  下面都是多态的体现</span></span><br><span class="line">        <span class="built_in">NSObject</span> *n1 = [[Dog alloc] init];</span><br><span class="line"><span class="comment">//        [n1 eat];不能这样调用</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSObject</span> *n2 = [[Animal alloc] init];</span><br><span class="line"><span class="comment">//        [n2 eat];不能这样调用</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2015-12-29 09:59:14.272 22[38583:433631] 狗吃东西</span><br><span class="line">2015-12-29 09:59:14.273 22[38583:433631] 狗吃东西</span><br><span class="line">2015-12-29 09:59:14.273 22[38583:433631] 动物吃东西</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<h2 id="多态的使用注意"><a href="#多态的使用注意" class="headerlink" title="多态的使用注意"></a>多态的使用注意</h2><h3 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h3><p>&lt; 代码示例 &gt;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  动物是一条狗？语义正确吗？</span></span><br><span class="line">Dog *d=[[Animal  alloc] init];</span><br><span class="line"></span><br><span class="line"><span class="comment">//  狗是一个字符串？正确吗？</span></span><br><span class="line"><span class="built_in">NSString</span> *str=[Dog  new];</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>OC语言是一门弱语法的语言，编译的时候并不会报错，所以这就要求我们在实际的开发过程中一定要按照既定的规范来写代码，不要出现狗是一个字符串这样的问题。</li>
</ul>
<h3 id="多态的好处"><a href="#多态的好处" class="headerlink" title="多态的好处"></a>多态的好处</h3><p>父类指针可以使用父类和子类共同有用的方法（即子类从父类继承来的方法），当父类调用子类继承过去的方法时，会进行动态检测，以调用真实的对象方法。</p>
<p>假如需要一个新的函数专门用来喂狗，如果这个时候也需要喂猫：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  喂狗</span></span><br><span class="line"> Void feed(Dog *d)&#123;</span><br><span class="line">   [d  eat];</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//  喂猫</span></span><br><span class="line"> Void feed(Cat *c)&#123;</span><br><span class="line">   [c  eat];</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>而狗和猫实际上都继承自动物这个类，在这里就可以使用多态来简化代码了。这里只需要把函数的参数写成是Animal *类型的，那么Dog和Cat类型的对象就都可以传入进来。调用的时候直接改变参数就可以了：</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Void feed(Animal *a)&#123;</span><br><span class="line">  <span class="comment">//  喂猫或喂狗</span></span><br><span class="line">  [a  eat];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多态的局限性"><a href="#多态的局限性" class="headerlink" title="多态的局限性"></a>多态的局限性</h3><p>父类类型的指针变量不能直接调用子类特有的方法：</p>
<p>&lt; 代码示例 &gt;</p>
<p><em>Animal.h</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Animal</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>Animal.m</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Animal.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Animal</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>Dog.h</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Animal.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Dog</span> : <span class="title">Animal</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)run;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>Dog.m</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Dog.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Dog</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)run&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"狗狗跑"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>main.m</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Dog.h"</span></span></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        Animal *dogA= [[Dog alloc] init];</span><br><span class="line">        <span class="comment">//  在Animal类中没有run方法，这里调用了狗对象的方法，这种消息发送是错误的。</span></span><br><span class="line"><span class="comment">//        [dogA run];</span></span><br><span class="line">        <span class="comment">//  解决方法：可以将Animal*强制转换为Dog*类型的变量，这里dogA和dogB指向的是同一个狗对象</span></span><br><span class="line">        Dog *dogB = (Dog*)dogA;</span><br><span class="line">        <span class="comment">//  这样便可以编译成功</span></span><br><span class="line">        [dogB run];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2015-12-08 03:38:41.709 Animal[53775:1468180] 狗狗跑</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<h2 id="多态使用总结"><a href="#多态使用总结" class="headerlink" title="多态使用总结"></a>多态使用总结</h2><ol>
<li>没有继承就没有多态。</li>
<li>代码的体现：父类类型的指针指向子类对象。</li>
<li>好处：如果方法参数中使用的是父类类型，则可以传入父类和子类对象，而不用再去定义多个函数来和相应的类进行匹配了。</li>
<li>局限性：父类类型的变量不能直接调用子类特有的方法，如果必须要调用，则必须强制转换为子类特有的方法。</li>
<li>允许在多个类中定义同一个消息接口。 </li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.cnblogs.com/mjios/" target="_blank" rel="external">M了个J的博客</a></p>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[【8】OC面向对象特性（二）：继承]]></title>
      <url>http://sanfordy.com/2016/08/30/%E3%80%96A%E3%80%97%E3%80%902-0%E3%80%91OC-%E8%AF%AD%E6%B3%95/%E3%80%9008%E3%80%91OC%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%89%B9%E6%80%A7%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E7%BB%A7%E6%89%BF/</url>
      <content type="html"><![CDATA[<blockquote>
<p>程序的世界和人类的“对象”世界在思想上是没有设么区别的，富二代继承了父母，自然就拥有了父母拥有的所有资源，既然OC是面向对象语言，当然同样支持继承，子类继承了父类同样就拥有了父类所有的方法和属性（成员变量）。</p>
</blockquote>
<a id="more"></a>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>程序的世界和人类的“对象”世界在思想上是没有设么区别的，富二代继承了父母，自然就拥有了父母拥有的所有资源，既然OC是面向对象语言，当然同样支持继承，子类继承了父类同样就拥有了父类所有的方法和属性（成员变量）。</p>
<p>一个类继承了另一个类，那么就拥有了父类的所有成员变量和方法，注意所有的成员变量它都拥有（包括@private），只是有的它不能直接访问。</p>
<p>在这里动物是猫类和狗类的父类，黑猫和白猫类是猫类的子类：</p>
<p><img src="http://images2015.cnblogs.com/blog/776348/201608/776348-20160830120007324-1608673101.png" alt=""></p>
<p>继承的好处：</p>
<ol>
<li>抽取了重复的代码。</li>
<li>建立了类和类之间的联系。</li>
</ol>
<p>继承的缺点：耦合性太强。</p>
<p>继承的单向性：继承是单向的，不能相互继承。</p>
<p>继承的内容：所有的成员变量和方法。</p>
<p>在OC中，基本上所有类的根类都是NSObject类。</p>
<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>既然OC是面向对象语言，当然同样支持继承。事实上前面定义的Person类本身就继承于NSObject，下面再简单看一个例子，这里部分假设我们还有一个Student类继承于Person类，而且这个类有一个分数（score）属性：</p>
<p>&lt; 代码示例 &gt;</p>
<p><em>Person.h</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span>&#123;</span><br><span class="line">    <span class="keyword">@protected</span></span><br><span class="line">    <span class="built_in">NSString</span> *_nation;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">assign</span>) <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">copy</span>) <span class="built_in">NSString</span> *nation;</span><br><span class="line"></span><br><span class="line">-(<span class="keyword">id</span>)initWithName:(<span class="built_in">NSString</span> *)name andAge:(<span class="keyword">int</span> )age;</span><br><span class="line">+(<span class="keyword">id</span>)personWithName:(<span class="built_in">NSString</span> *)name andAge:(<span class="keyword">int</span> )age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>Person.m</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Person.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line">-(<span class="keyword">id</span>)initWithName:(<span class="built_in">NSString</span> *)name andAge:(<span class="keyword">int</span>)age&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">self</span>=[<span class="keyword">super</span> init])&#123; <span class="comment">//super代表父类</span></span><br><span class="line">        <span class="keyword">self</span>.name=name;</span><br><span class="line">        <span class="keyword">self</span>.age=age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+(<span class="keyword">id</span>)personWithName:(<span class="built_in">NSString</span> *)name andAge:(<span class="keyword">int</span>)age&#123;</span><br><span class="line">    Person *p=[[Person alloc]initWithName:name andAge:age];</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(<span class="built_in">NSString</span> *)description&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"&#123;name:%@,age:%i&#125;"</span>,<span class="keyword">self</span>.name,<span class="keyword">self</span>.age];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>Student.h</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Person.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Student</span> : <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">assign</span>) <span class="keyword">float</span> score;</span><br><span class="line"></span><br><span class="line">-(<span class="keyword">id</span>)initWithName:(<span class="built_in">NSString</span> *)name andAge:(<span class="keyword">int</span> )age andScore:(<span class="keyword">float</span>)score;</span><br><span class="line">+(<span class="keyword">id</span>)studentWithName:(<span class="built_in">NSString</span> *)name andAge:(<span class="keyword">int</span> )age andScore:(<span class="keyword">float</span>)score;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>Student.m</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Student.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Student</span></span></span><br><span class="line"></span><br><span class="line">-(<span class="keyword">id</span>)initWithName:(<span class="built_in">NSString</span> *)name andAge:(<span class="keyword">int</span> )age andScore:(<span class="keyword">float</span>)score&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">self</span>=[<span class="keyword">super</span> initWithName:name andAge:age])&#123; <span class="comment">//注意这里访问了父类的方法</span></span><br><span class="line">        <span class="keyword">self</span>.score=score;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+(<span class="keyword">id</span>)studentWithName:(<span class="built_in">NSString</span> *)name andAge:(<span class="keyword">int</span>)age andScore:(<span class="keyword">float</span>)score&#123;</span><br><span class="line">    Student *s=[[Student alloc]initWithName:name andAge:age andScore:score];</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(<span class="built_in">NSString</span> *)description&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"&#123;name:%@,age:%i,nation:%@,scroe:%.2f&#125;"</span>,<span class="keyword">self</span>.name,<span class="keyword">self</span>.age,<span class="keyword">self</span>-&gt;_nation,<span class="keyword">self</span>.score]; <span class="comment">//注意这里访问了父类的属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>main.m</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Person.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Student.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    </span><br><span class="line">    Person *p=[Person personWithName:<span class="string">@"Kenshin"</span> andAge:<span class="number">28</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"p=%@"</span>,p);</span><br><span class="line">    </span><br><span class="line">    Student *stu=[Student studentWithName:<span class="string">@"Kaoru"</span> andAge:<span class="number">27</span> andScore:<span class="number">100</span>];</span><br><span class="line">    stu.nation=<span class="string">@"henan"</span>;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"stu=%@"</span>,stu);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="继承的使用注意"><a href="#继承的使用注意" class="headerlink" title="继承的使用注意"></a>继承的使用注意</h2><ol>
<li>编译器从上往下执行，所以在子类前面至少应该要有父类的声明。</li>
<li>OC中不允许子类和父类拥有相同名称的成员变量名。</li>
<li>OC中的子类可以拥有和父类相同名称的方法，在子类调用时，优先去自己的内部寻找，如果没有则一层一层的往上找。</li>
<li>重写即子类重新实现了父类中的某个方法，覆盖了父类以前的实现。</li>
<li>示意图：一共有三个类，Person类继承了NSObject类，Student类继承了Person类：<br><img src="http://images2015.cnblogs.com/blog/776348/201608/776348-20160830120012668-1004872303.png" alt=""><br>创建一个Student *s=[[Student alloc] init];此时会把Student类和这个类的父类加载进内存。<code>每个类中都有一个super class指针，该指针指向自己的父类。对象中有一个isa指针，该指针指向调用该对象的类。</code></li>
</ol>
<h2 id="继承和组合"><a href="#继承和组合" class="headerlink" title="继承和组合"></a>继承和组合</h2><p>继承：###是xxx，如狗是动物，可以让狗继承动物类。</p>
<p>组合：###拥有xxx，如学生有书，可以让书这个类作为学生类的属性。</p>
<p>继承的适用场合：</p>
<ol>
<li>当两个类拥有相同的属性和方法时，就可以将相同的属性和方法抽取到一个父类中。</li>
<li>当A类完全拥有B类中的部分属性和方法时，可以考虑让B类继承A类（考虑），在这种情况下，也可以考虑使用组合。</li>
</ol>
<h2 id="super"><a href="#super" class="headerlink" title="super"></a>super</h2><p>super是编译器指令，并非对象。</p>
<p>super的作用：</p>
<ol>
<li>直接调用父类中的某一个方法。</li>
<li>给super发送消息，可以执行父类中实现的方法，super处在对象方法中，那么就会调用父类的对象方法；super处于类方法中，那么就会调用父类的类方法。</li>
</ol>
<p>super的使用场景：子类在重写父类方法时，想要保留父类的一些行为。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.cnblogs.com/mjios/" target="_blank" rel="external">M了个J的博客</a></p>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[【07】OC面向对象特性（一）：封装]]></title>
      <url>http://sanfordy.com/2016/08/30/%E3%80%96A%E3%80%97%E3%80%902-0%E3%80%91OC-%E8%AF%AD%E6%B3%95/%E3%80%9007%E3%80%91OC%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%89%B9%E6%80%A7%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%B0%81%E8%A3%85/</url>
      <content type="html"><![CDATA[<blockquote>
<p>封装是对象和类概念的主要特性。它是隐藏内部实现，稳定外部接口，可以看作是“包装”。</p>
</blockquote>
<a id="more"></a>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>封装是对象和类概念的主要特性。它是隐藏内部实现，稳定外部接口，可以看作是“包装”。</p>
<p>好处：使用更加简单，变量更加安全，可以隐藏内部实现细节。</p>
<p>在OC语言中，使用<code>@interface</code>和<code>@implementation</code>来处理类。<code>@interface</code>就好像暴露在外面的时钟表面，像外界提供展示以及接口。<code>@implementation</code>就好像隐藏在时钟内部的构造实现，把具体的实现封装了起来：</p>
<p><img src="http://images2015.cnblogs.com/blog/776348/201608/776348-20160830114001011-2105887168.png" alt=""></p>
<p>属性封装了成员变量，方法封装了具体的实现代码， 类封装了属性和方法。子类可以继承父类中的方法，还可以重写（override）父类的方法。</p>
<h2 id="Set方法"><a href="#Set方法" class="headerlink" title="Set方法"></a>Set方法</h2><p>在开发过程中，考虑到安全性要求，我们一般不在成员变量名前面使用<code>@public</code>、<code>@protected</code>等关键字修饰，而是使用Set方法来为对象提供成员变量的值。在set方法的内部也可以对一些不合理的赋值进行筛选过滤。</p>
<p>Set方法的作用：为外界提供一个设置成员变量值的方法。</p>
<h3 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h3><ol>
<li>方法名必须以set开头。</li>
<li>Set后面跟上成员变量的名称，首字母大写。</li>
<li>返回值一定是void。</li>
<li>一定要接收一个参数，而且参数类型需要和成员变量的类型一致。</li>
<li>形参名不能和成员变量名一样（苹果官方推荐成员变量名前加_以示区分）。</li>
</ol>
<h3 id="Set方法的好处"><a href="#Set方法的好处" class="headerlink" title="Set方法的好处"></a>Set方法的好处</h3><ol>
<li>不让数据暴露在外，保证了数据的安全性。</li>
<li>设置的数据进行过滤。</li>
</ol>
<h3 id="Set方法使用示例"><a href="#Set方法使用示例" class="headerlink" title="Set方法使用示例"></a>Set方法使用示例</h3><p>&lt; 代码示例 &gt;</p>
<p><em>Person.h</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span>&#123;</span><br><span class="line">    <span class="comment">//  这里不再使用@public关键字</span></span><br><span class="line">    <span class="keyword">int</span> _age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  set方法的声明，接受一个参数</span></span><br><span class="line">- (<span class="keyword">void</span>)setAge:(<span class="keyword">int</span>)age;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)print;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>Person.m</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Person.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  set方法的实现</span></span><br><span class="line">- (<span class="keyword">void</span>)setAge:(<span class="keyword">int</span>)age&#123;</span><br><span class="line">    _age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)print&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"age = %d"</span>,_age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>main.m</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Person.h"</span></span></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        Person *aperson = [[Person alloc] init];</span><br><span class="line">        <span class="comment">//  使用set方法设置person类对象age成员变量的值为10</span></span><br><span class="line">        [aperson setAge:<span class="number">10</span>];</span><br><span class="line">        [aperson print];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Get方法"><a href="#Get方法" class="headerlink" title="Get方法"></a>Get方法</h2><p>Get方法的作用：为调用者返回对象内部的成员变量。</p>
<h3 id="命名规范-1"><a href="#命名规范-1" class="headerlink" title="命名规范"></a>命名规范</h3><ol>
<li>一定有返回值，返回值的类型和成员变量的类型一致。</li>
<li>方法名和成员变量名一样。</li>
<li>不需要接收任何参数。</li>
</ol>
<h3 id="Get方法使用示例"><a href="#Get方法使用示例" class="headerlink" title="Get方法使用示例"></a>Get方法使用示例</h3><p>&lt; 代码示例 &gt;</p>
<p><em>Person.h</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span>&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *_name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  set方法的声明，接受一个参数</span></span><br><span class="line">- (<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)name;</span><br><span class="line"><span class="comment">//  get方法的声明</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>Person.m</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Person.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  set方法的实现</span></span><br><span class="line">- (<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)name&#123;</span><br><span class="line">    _name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)name&#123;</span><br><span class="line">    <span class="keyword">return</span> _name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>main.m</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Person.h"</span></span></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        Person *aperson = [[Person alloc] init];</span><br><span class="line">        <span class="comment">//  使用set方法为成员变量设置一个值</span></span><br><span class="line">        [aperson setName:<span class="string">@"xiaoming"</span>];</span><br><span class="line">        <span class="comment">//  使用get方法获取成员变量的值</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[aperson name]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：在实际的开发中，不一定set和get方法都会提供，如果内部的成员变量比如学生的学号这样的数据只允许外界读取，但是不允许修改的情况，则通常只提供get方法而不提供set方法。</p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.cnblogs.com/mjios/" target="_blank" rel="external">M了个J的博客</a></p>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[【06】内存管理]]></title>
      <url>http://sanfordy.com/2016/08/25/%E3%80%96A%E3%80%97%E3%80%902-0%E3%80%91OC-%E8%AF%AD%E6%B3%95/%E3%80%9006%E3%80%91%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
      <content type="html"><![CDATA[<blockquote>
<p>由于移动设备的内存极其有限，所以每个app所占的内存也是有限制的，当app所占用的内存较多时，系统就会发出内存警告，这时需要回收一些不需要再继续使用的内存空间，比如回收一些不再使用的对象和变量等。</p>
</blockquote>
<a id="more"></a>
<h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><h3 id="为什么要进行内存管理"><a href="#为什么要进行内存管理" class="headerlink" title="为什么要进行内存管理"></a>为什么要进行内存管理</h3><p>由于移动设备的内存极其有限，所以每个app所占的内存也是有限制的，当app所占用的内存较多时，系统就会发出内存警告，这时需要回收一些不需要再继续使用的内存空间，比如回收一些不再使用的对象和变量等。</p>
<p>当代码块结束时这个代码块中涉及的所有局部变量会被回收，指向对象的指针也被回收，此时对象已经没有指针指向，但依然存在于堆内存中并占用大量内存，造成内存泄露。</p>
<h3 id="常见内存问题"><a href="#常见内存问题" class="headerlink" title="常见内存问题"></a>常见内存问题</h3><p>内存问题主要体现在三个方面：内存泄露、内存溢出、野指针异常。</p>
<ol>
<li>内存泄露：其实说白了就是该内存空间使用完毕之后未回收导致内存越用越少。</li>
<li>内存溢出：应用程序所占的内存大小超过了系统给定的内存上限称为内存溢出。iOS给每个应用程序提供了一定的内存，用于程序的运行，比如Phone 5S 提供80M左右。一旦超出内存上限，程序就会Crash。 </li>
<li>野指针异常：对象内存空间已经被系统回收，仍然使用指针操作这块内存。野指针异常是程序crash的主要原因。</li>
</ol>
<h3 id="内存管理的范围"><a href="#内存管理的范围" class="headerlink" title="内存管理的范围"></a>内存管理的范围</h3><p>内存管理对任何继承NSObject的对象有效，对基本数据类型无效。本质原因是因为对象和基本数据类型在系统中的存储空间不一样。在CO中对象的本质就是栈中的指针指向堆中的内存，而对象存储的内容就在堆中的内存中，所以可以这么说：对象是存储在堆中的，系统并不会自动释放堆中的内存而是有我们自己管理堆内存。基本数据类型不是存在于栈（局部变量）就是存在于静态存储区（全局或static修饰的局部变量），而这两个内存区都由系统管理，我们无需做更多地操作。</p>
<h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><p>C语言中，使用malloc和free，进行堆内存的创建和释放。堆内存只有正在使⽤和销毁两种状态。实际开发中可能会遇到两个以上的指针使用同一块内存，C语言无法记录内存使用者的个数。 </p>
<p>OC采用引用计数机制管理内存，当一个新的引用（指针）指向对象（对象所占的内存）时，引用计数器就递增，当去掉一个引用（指针）时，引用计数就递减。当引用计数到零时，该对象所在占的内存就会被释放。</p>
<p>一个比较形象的比喻，假设我们有一条狗和几个用绳子牵着这条狗的人，那么不到最后一个人松掉手中的绳子，这只狗是不能获得自由的。而持有计数的作用就是记录了到底有多少个人牵着绳子。 </p>
<h3 id="对象的基本结构"><a href="#对象的基本结构" class="headerlink" title="对象的基本结构"></a>对象的基本结构</h3><p>每个OC对象都有自己的引用计数器，是一个整数表示对象当前被引用的个数，即现在有多少东西在使用这个对象。对象刚被创建时，默认计数器值为1，当计数器的值变为0时，则对象销毁。</p>
<p>在每个OC对象内部，都专门有4个字节的存储空间来存储引用计数器。</p>
<blockquote>
<p><strong>注意</strong>：判断对象要不要销毁的唯一依据就是计数器是否为0，若为0则对象销毁，否则不销毁。</p>
</blockquote>
<h3 id="对象的销毁"><a href="#对象的销毁" class="headerlink" title="对象的销毁"></a>对象的销毁</h3><p>当一个对象的引用计数器为0时，那么它将被销毁，其占用的内存被系统回收。</p>
<p>当对象被销毁时，系统会自动向对象发送一条dealloc消息，一般会重写dealloc方法，在这里释放相关的资源，dealloc就像是对象的“临终遗言”。一旦重写了dealloc方法就必须调用[super dealloc]，并且放在代码块的最后调用（不能直接调用dealloc方法）。</p>
<p>一旦对象被回收了，那么他所占据的存储空间就不再可用，坚持使用会导致程序崩溃（野指针错误）。</p>
<h2 id="内存管理原则（MRC）"><a href="#内存管理原则（MRC）" class="headerlink" title="内存管理原则（MRC）"></a>内存管理原则（MRC）</h2><ol>
<li>如果你通过alloc，new，copy来创建了一个对象或给对象发送了retain消息，那么你就必须调用release或者autorelease方法。</li>
<li>当要你想使用这个对象时，那么就应该手动通过retain让这个对象的引用计数器+1。</li>
<li>当你不想使用这个对象时，那么就应该手动通过release让这个对象的引用计数器-1。</li>
<li>引用计数的增加和减少应该相等，有加就应该有减。曾经让某个对象计数器加1，就应该让其在最后-1，当引用计数降为0之后，调用对象的dealloc方法进行回收，我们不应该再使用这块内存空间。</li>
<li>判断对象会不会被回收的唯一依据就是引用计数是否为0。</li>
</ol>
<h2 id="内存管理的操作（MRC）"><a href="#内存管理的操作（MRC）" class="headerlink" title="内存管理的操作（MRC）"></a>内存管理的操作（MRC）</h2><h3 id="alloc"><a href="#alloc" class="headerlink" title="+alloc"></a>+alloc</h3><p>开辟内存空间，让被开辟的内存空间的引⽤计数变为1，这是由0到1的过程。 </p>
<h3 id="retain"><a href="#retain" class="headerlink" title="-retain"></a>-retain</h3><p>引用计数加1，如果内存空间之前引用计数为1，ratain之 后变为2，该方法返回对象本身。</p>
<h3 id="copy"><a href="#copy" class="headerlink" title="-copy"></a>-copy</h3><p>使用copy功能的前提：需要遵守NSCopying协议（系统类大部分都遵守了），实现copyWithZone：方法（系统类大部分都实现了）。</p>
<p>copy的结果是返回一个<code>不可变</code>对象。</p>
<p>copy对系统类的可变对象是深拷贝（即把内容拷贝至新内存并返回新内存地址）：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//  可变字符串</span></span><br><span class="line">    <span class="built_in">NSMutableString</span> *mString = [<span class="built_in">NSMutableString</span> stringWithString:<span class="string">@"可变字符串"</span>];</span><br><span class="line">    [[mString <span class="keyword">copy</span>]appendString:<span class="string">@"1"</span>];<span class="comment">// error：Attempt to mutate immutable object with appendString，原因是[mString copy]是一个不可变字符串，不能用appendString方法改变其值。</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"mString-&gt;%@:%p,[mString copy]-&gt;%@:%p"</span>,mString,mString,[mString <span class="keyword">copy</span>],[mString <span class="keyword">copy</span>]);</span><br><span class="line">    <span class="comment">//  输出：mString-&gt;可变字符串:0x7fba13f14310,[mString copy]-&gt;可变字符串:0x7fba13f0ef80</span></span><br><span class="line">    <span class="comment">//  可以发现，mString和[mString copy]指向的是不同的内存区域，此时是深拷贝。</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  可变数组</span></span><br><span class="line">    <span class="built_in">NSMutableArray</span> *mArray = [<span class="built_in">NSMutableArray</span> arrayWithObjects:<span class="string">@"a"</span>,<span class="string">@"b"</span>,<span class="string">@"c"</span>, <span class="literal">nil</span>];</span><br><span class="line"><span class="comment">//    [[mArray copy] addObject:@"d"];// error:unrecognized selector sent to instance 0x7fc43ad0c7a0'，因为[mArray copy]返回的是一个不可变数组</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"mArray-&gt;%@:%p,[mArray copy]-&gt;%@:%p"</span>,mArray,mArray,[mArray <span class="keyword">copy</span>],[mArray <span class="keyword">copy</span>]);</span><br><span class="line">    <span class="comment">/*输出：mArray-&gt;(</span><br><span class="line">     a,</span><br><span class="line">     b,</span><br><span class="line">     c</span><br><span class="line">     ):0x7fd5cbd030f0,[mArray copy]-&gt;(</span><br><span class="line">     a,</span><br><span class="line">     b,</span><br><span class="line">     c</span><br><span class="line">     ):0x7fd5cbd0f6f0*/</span></span><br><span class="line">    <span class="comment">//  可以发现，mArray和[mArray copy]指向的是不同的内存区域，此时是深拷贝。</span></span><br></pre></td></tr></table></figure>
<p>对系统的不可变对象是浅拷贝（即拷贝指针并返回指针）：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  不可变字符串</span></span><br><span class="line"><span class="built_in">NSString</span> *string = <span class="string">@"不可变字符串"</span>;</span><br><span class="line"><span class="comment">//  copy：拷贝string对象的地址并赋值给stringCopy</span></span><br><span class="line"><span class="built_in">NSString</span> *stringCopy = [string <span class="keyword">copy</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"string-&gt;%@:%p,stringCopy-&gt;%@:%p"</span>,string,string,stringCopy,stringCopy);</span><br><span class="line"><span class="comment">//  输出：string-&gt;origion:0x109533050,stringCopy-&gt;origion:0x109533050</span></span><br><span class="line"><span class="comment">//  可以发现，string和stringCopy指向的是同一块内存区域，此时stringCopy的引用计数和string的一样都为２</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  不可变数组</span></span><br><span class="line"><span class="built_in">NSArray</span> *array = [<span class="built_in">NSArray</span> arrayWithObjects:<span class="string">@"a"</span>,<span class="string">@"b"</span>,<span class="string">@"c"</span>,<span class="literal">nil</span>];</span><br><span class="line"><span class="comment">//  copy：拷贝array对象的地址并赋值给arrayCopy</span></span><br><span class="line"><span class="built_in">NSArray</span> *arrayCopy = [array <span class="keyword">copy</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"array-&gt;%@:%p,arrayCopy-&gt;%@:%p"</span>,array,array,arrayCopy,arrayCopy);</span><br><span class="line"><span class="comment">/*输出：array-&gt;(</span><br><span class="line"> a,</span><br><span class="line"> b,</span><br><span class="line"> c</span><br><span class="line"> ):0x7feaa361afa0,arrayCopy-&gt;(</span><br><span class="line"> a,</span><br><span class="line"> b,</span><br><span class="line"> c</span><br><span class="line"> ):0x7feaa361afa0*/</span></span><br><span class="line"><span class="comment">//  可以发现，array和arrayCopy指向的是同一块内存空间。</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：容器类对象的深拷贝指的是单层深拷贝，即仅仅是拷贝容器这个对象，容器内部的元素仍然是指针拷贝。</p>
</blockquote>
<h3 id="mutableCopy"><a href="#mutableCopy" class="headerlink" title="-mutableCopy"></a>-mutableCopy</h3><p>使用mutableCopy功能的前提：需要遵守NSMutableCopying协议（系统类大部分都遵守了），实现mutableCopyWithZone:方法（系统类大部分都实现了）。</p>
<p>mutableCopy的结果是返回一个<code>可变</code>对象。</p>
<p>mutableCopy对系统的可变对象和不可变对象都是深拷贝（即把内容拷贝至新内存并返回新内存地址）：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  不可变字符串</span></span><br><span class="line"><span class="built_in">NSString</span> *string = <span class="string">@"不可变字符串"</span>;</span><br><span class="line"><span class="comment">//  mutableCopy，返回一个可变字符串</span></span><br><span class="line"><span class="built_in">NSMutableString</span> *mString = [string mutableCopy];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"string-&gt;%@:%p,mString-&gt;%@:%p"</span>,string,string,mString,mString);</span><br><span class="line"><span class="comment">//  输出：string-&gt;不可变字符串:0x101873050,mString-&gt;不可变字符串:0x7f9c83c20d20</span></span><br><span class="line"><span class="comment">//  可以发现，string和mString指向了不同的内存空间</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  可变字符串</span></span><br><span class="line"><span class="built_in">NSMutableString</span> *mString1 = [<span class="built_in">NSMutableString</span> stringWithString:<span class="string">@"可变字符串"</span>];</span><br><span class="line"><span class="built_in">NSMutableString</span> *mString2 = [mString1 mutableCopy];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"mString1-&gt;%@:%p,mString2-&gt;%@:%p"</span>,mString1,mString1,mString2,mString2);</span><br><span class="line"><span class="comment">//  输出：mString1-&gt;可变字符串:0x7fe9a370d540,mString2-&gt;可变字符串:0x7fe9a370c530</span></span><br><span class="line"><span class="comment">//  可以发现：mString1和mString指向了不同的内存空间</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  不可变数组</span></span><br><span class="line"><span class="built_in">NSArray</span> *array = [<span class="built_in">NSArray</span> arrayWithObjects:<span class="string">@"a"</span>,<span class="string">@"b"</span>,<span class="string">@"c"</span>, <span class="literal">nil</span>];</span><br><span class="line"><span class="comment">//  mutableCopy，返回一个可变数组</span></span><br><span class="line"><span class="built_in">NSMutableArray</span> *mArray = [array mutableCopy];</span><br><span class="line">[mArray addObject:<span class="string">@"d"</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"array-&gt;%@:%p,mArray-&gt;%@:%p"</span>,array,array,mArray,mArray);</span><br><span class="line"><span class="comment">/*输出：array-&gt;(</span><br><span class="line"> a,</span><br><span class="line"> b,</span><br><span class="line"> c</span><br><span class="line"> ):0x7fec0bc52f50,mArray-&gt;(</span><br><span class="line"> a,</span><br><span class="line"> b,</span><br><span class="line"> c,</span><br><span class="line"> d</span><br><span class="line"> ):0x7fec0bc52c40*/</span></span><br><span class="line"><span class="comment">//  可以发现，array和mArray指向了不同的内存空间</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  可变数组</span></span><br><span class="line"><span class="built_in">NSMutableArray</span> *mArray1 = [<span class="built_in">NSMutableArray</span> arrayWithObjects:<span class="string">@"a"</span>,<span class="string">@"b"</span>,<span class="string">@"c"</span>, <span class="literal">nil</span>];</span><br><span class="line"><span class="comment">//  mutableCopy，返回一个可变数组</span></span><br><span class="line"><span class="built_in">NSMutableArray</span> *mArray2 = [mArray1 mutableCopy];</span><br><span class="line">[mArray2 addObject:<span class="string">@"d"</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"mArray1-&gt;%@:%p,mArray2-&gt;%@:%p"</span>,mArray1,mArray1,mArray2,mArray2);</span><br><span class="line"><span class="comment">/*输出：mArray1-&gt;(</span><br><span class="line"> a,</span><br><span class="line"> b,</span><br><span class="line"> c</span><br><span class="line"> ):0x7faa23404c10,mArray2-&gt;(</span><br><span class="line"> a,</span><br><span class="line"> b,</span><br><span class="line"> c,</span><br><span class="line"> d</span><br><span class="line"> ):0x7faa23460910*/</span></span><br><span class="line"><span class="comment">//  可以发现，mArray1和mArray2指向了不同的内存空间</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：容器类对象的深拷贝指的是单层深拷贝，即仅仅是拷贝容器这个对象，容器内部的元素仍然是指针拷贝。</p>
</blockquote>
<h3 id="release"><a href="#release" class="headerlink" title="-release"></a>-release</h3><p>引用计数减1，如果内存空间之前引用计数为4，release之后变为3，release之后变为0内存被系统回收。</p>
<h3 id="autorelease"><a href="#autorelease" class="headerlink" title="-autorelease"></a>-autorelease</h3><p>未来的某一时刻引用计数减1。如果内存之前引用计数为4，autorelease之后仍然为4，未来某个时刻会变为3。</p>
<h4 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h4><ol>
<li>会将对象放到一个自动释放池中。</li>
<li>当自动释放池被销毁时，会对池子里的所有对象做一次release。</li>
<li>会返回对象本身。</li>
<li>调用完autorelease方法后，对象的计数器不受影响（销毁时影响）。</li>
</ol>
<h4 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h4><ol>
<li>不需要再关心对象释放的时间。</li>
<li>不需要再关心什么时候调用release。</li>
</ol>
<h4 id="使用注意"><a href="#使用注意" class="headerlink" title="使用注意"></a>使用注意</h4><ol>
<li>占用内存较大的对象，不要随便使用autorelease，应该使用release来精确控制。</li>
<li>占用内存较小的对象使用autorelease，没有太大的影响。</li>
</ol>
<h4 id="自动释放池"><a href="#自动释放池" class="headerlink" title="自动释放池"></a>自动释放池</h4><ol>
<li>在ios程序运行过程中，会创建无数个池子，这些池子都是以栈结构（先进后出）存在的。</li>
<li>当一个对象调用autorelease时，会将这个对象放到位于栈顶的释放池中。</li>
</ol>
<h4 id="自动释放池的创建方式"><a href="#自动释放池的创建方式" class="headerlink" title="自动释放池的创建方式"></a>自动释放池的创建方式</h4><p>ios 5.0以前的创建方式：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">　　　　　　<span class="built_in">NSAutoreleasePool</span> *pool=[[<span class="built_in">NSAutoreleasePool</span> alloc] init];</span><br><span class="line">　　　　　　<span class="comment">//......  //</span></span><br><span class="line">　　　　　　[pool  release];<span class="comment">//[pool drain];用于mac</span></span><br></pre></td></tr></table></figure>
<p>Ios5.0以后的创建方式：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">　　　　　　<span class="keyword">@autoreleasepool</span>&#123;<span class="comment">//开始代表创建自动释放池</span></span><br><span class="line"></span><br><span class="line">　　　　　　·······</span><br><span class="line"></span><br><span class="line">　　　　　　&#125;<span class="comment">//结束代表销毁自动释放池</span></span><br></pre></td></tr></table></figure>
<h4 id="Autorelease注意"><a href="#Autorelease注意" class="headerlink" title="Autorelease注意"></a>Autorelease注意</h4><ol>
<li>系统自带的方法中，如果不包含alloc new copy等，则这些方法返回的对象都是autorelease的，如[NSDate  date]。</li>
<li>开发中经常会写一些类方法来快速创建一个autorelease对象，创建对象时不要直接使用类名，而是使用self。</li>
</ol>
<h4 id="retainCount"><a href="#retainCount" class="headerlink" title="-retainCount"></a>-retainCount</h4><p>获得对象当前的引用计数器值。</p>
<h4 id="dealloc"><a href="#dealloc" class="headerlink" title="-dealloc"></a>-dealloc</h4><p>是继承自父类的方法，当对象引用计数为0的时候，则系统会自动调用这个对象的dealloc方法来销毁这个对象。 </p>
<p>dealloc是NSObject的一个实例方法，与alloc对应，用于回收开辟的内存空间。</p>
<p>dealloc方法的代码规范：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  通常我们在dealloc中释放该类setter方法泄露的成员变量</span></span><br><span class="line">[_name release];</span><br><span class="line"><span class="comment">//  一定要[super dealloc]，而且要放到最后，是因为你所创建的每个类都是从父类，根类继承来的，有很多成员变量也会继承过来，这部分成员变量有时候会在你的程序内使用，它们不会自动释放内存，这需要调用父类的 dealloc方法来释放，然而在此之前你需要先把自己所写类中的成员变量内存先释放掉，否则就会造成你本类中的内存积压，造成泄漏。</span></span><br><span class="line">[<span class="keyword">super</span> dealloc];</span><br></pre></td></tr></table></figure>
<h2 id="内存管理代码示例"><a href="#内存管理代码示例" class="headerlink" title="内存管理代码示例"></a>内存管理代码示例</h2><p>&lt; 代码示例 &gt;</p>
<p><em>Person.h</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">assign</span>) <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>Person.m</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Person.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark 重写dealloc方法，在这个方法中通常进行成员变量释放操作</span></span><br><span class="line">-(<span class="keyword">void</span>)dealloc&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Invoke Person's dealloc method."</span>);</span><br><span class="line">    [<span class="keyword">super</span> dealloc];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>main.m</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Person.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Test1()&#123;</span><br><span class="line">    Person *p=[[Person alloc]init]; <span class="comment">//调用alloc，引用计数器+1</span></span><br><span class="line">    p.name=<span class="string">@"Kenshin"</span>;</span><br><span class="line">    p.age=<span class="number">28</span>;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"retainCount=%lu"</span>,[p retainCount]);</span><br><span class="line">    <span class="comment">//结果：retainCount=1</span></span><br><span class="line">    [p release];</span><br><span class="line">    <span class="comment">//结果：Invoke Person's dealloc method.</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//上面调用过release方法，p指向的对象就会被销毁，但是此时变量p中还存放着Person对象的地址，</span></span><br><span class="line">    <span class="comment">//如果不设置p=nil，则p就是一个野指针，它指向的内存已经不属于这个程序，因此是很危险的</span></span><br><span class="line">    p=<span class="literal">nil</span>;</span><br><span class="line">    <span class="comment">//如果不设置p=nil，此时如果再调用对象release会报错，但是如果此时p已经是空指针了，</span></span><br><span class="line">    <span class="comment">//则在OC中给空指针发送消息是不会报错的</span></span><br><span class="line">    [p release];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Test2()&#123;</span><br><span class="line">    Person *p=[[Person alloc]init];</span><br><span class="line">    p.name=<span class="string">@"Kenshin"</span>;</span><br><span class="line">    p.age=<span class="number">28</span>;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"retainCount=%lu"</span>,[p retainCount]);</span><br><span class="line">    <span class="comment">//结果：retainCount=1</span></span><br><span class="line">    </span><br><span class="line">    [p retain];<span class="comment">//引用计数器+1</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"retainCount=%lu"</span>,[p retainCount]);</span><br><span class="line">    <span class="comment">//结果：retainCount=2</span></span><br><span class="line">    </span><br><span class="line">    [p release];<span class="comment">//调用1次release引用计数器-1</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"retainCount=%lu"</span>,[p retainCount]);</span><br><span class="line">    <span class="comment">//结果：retainCount=1</span></span><br><span class="line">    [p release];</span><br><span class="line">    <span class="comment">//结果：Invoke Person's dealloc method.</span></span><br><span class="line">    p=<span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> Test3()&#123;</span><br><span class="line">    Person *p1 = [[Person alloc] init];</span><br><span class="line">    <span class="comment">//  这时候p2和p1指向了同一块内存空间，这时候就需要我们手动添加retain了，如果我们不手动添加retain，这块内存空间的引用计数还是为1</span></span><br><span class="line">    Person *p2 = p1;<span class="comment">//  其实这种做法是错误的</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%lu,%lu"</span>,[p1 retainCount],[p2 retainCount]);</span><br><span class="line">    <span class="comment">//结果：1,1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这种做法才对，因为我们让p3也指向了p1指向的内存，所以需要我们手动让p1指向内存的引用计数+1</span></span><br><span class="line">    Person *p3 = [p1 retain];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%lu,%lu,"</span>[p1 retainCount],[p3 retainCount]);</span><br><span class="line">    <span class="comment">//结果：2,2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        Test1();</span><br><span class="line">        Test2();</span><br><span class="line">        Test3();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>在上面的代码中我们可以通过dealloc方法来查看是否一个对象已经被回收，如果没有被回收则有可能造成内存泄露。如果一个对象被释放之后，那么最后引用它的变量我们手动设置为nil，否则可能造成野指针错误，而且需要注意在OC中给空对象发送消息是不会引起错误的。</li>
<li>野指针错误形式在Xcode中通常表现为：Thread 1：EXC_BAD_ACCESS(code=EXC_I386_GPFLT)错误。因为你访问了一块已经不属于你的内存。</li>
</ul>
<h2 id="内存的相关概念"><a href="#内存的相关概念" class="headerlink" title="内存的相关概念"></a>内存的相关概念</h2><h3 id="野指针"><a href="#野指针" class="headerlink" title="野指针"></a>野指针</h3><p>野指针指向了一块垃圾内存（已经被回收的，不可用的内存），野指针是非常危险的。</p>
<p>自定义Student类，在main函数中添加下列代码：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Student *stu = [[Student alloc] init];</span><br><span class="line"></span><br><span class="line">[stu setAge:<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">[stu release];</span><br><span class="line"></span><br><span class="line">[stu setAge:<span class="number">10</span>];</span><br></pre></td></tr></table></figure>
<p>&lt; CRASH &gt;</p>
<p><img src="http://images2015.cnblogs.com/blog/776348/201608/776348-20160829114938558-306622190.png" alt=""></p>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>执行完第1行代码后，内存中有个指针变量stu，指向了Student对象（即Student创建的对象）：<br><img src="http://images2015.cnblogs.com/blog/776348/201608/776348-20160829115217777-1123017812.png" alt=""><br>假设Student对象的地址为0xff43，指针变量stu的地址为0xee45，stu中存储的是Student对象的地址0xff43。即指针变量stu指向了这个Student对象。</li>
<li>第3行代码的意思是：给stu所指向的Student对象发送一条setAge:消息，即调用这个Student对象的setAge:方法。目前来说，这个Student对象仍存在于内存中，所以这句代码没有任何问题。</li>
<li>第5行代码的意思是：给stu指向的Student对象发送一条release消息。在这里，Student对象接收到release消息后，会马上被销毁，所占用的内存会被回收：<br><img src="http://images2015.cnblogs.com/blog/776348/201608/776348-20160829115223668-286487842.png" alt=""><br>Student对象被销毁了，地址为0xff43的内存就变成了”垃圾内存”，然而，指针变量stu仍然指向这一块内存，这时候，stu就称为了野指针！</li>
<li>第7行代码的意思仍然是： 给stu所指向的Student对象发送一条setAge:消息。但是在执行完第5行代码后，Student对象已经被销毁了，它所占用的内存已经是垃圾内存，如果你还去访问这一块内存，那就会报野指针错误。这块内存已经不可用了，也不属于你了，你还去访问它，肯定是不合法的。所以，这行代码报错了！</li>
<li>如果改动一下代码，就不会报错：</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Student *stu = [[Student alloc] init];</span><br><span class="line"></span><br><span class="line">[stu setAge:<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">[stu release];</span><br><span class="line"><span class="comment">//  stu变成了空指针，stu就不再指向任何内存了</span></span><br><span class="line">stu = <span class="literal">nil</span>;</span><br><span class="line"><span class="comment">//  因为stu是个空指针，没有指向任何对象，因此setAge:消息是发不出去的，不会造成任何影响。当然，肯定也不会报错。</span></span><br><span class="line">[stu setAge:<span class="number">10</span>];</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>总结</strong>：利用野指针发消息是很危险的，会报错。也就是说，如果一个对象已经被回收了，就不要再去操作它，不要再尝试给它发消息；利用空指针发消息是没有任何问题的。</p>
</blockquote>
<h3 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h3><p>空指针没有指向任何东西的指针（存储的东西是0,null，nil），给空指针发送消息不会报错：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="literal">nil</span> setAge:<span class="number">10</span>];</span><br></pre></td></tr></table></figure>
<h3 id="僵尸对象"><a href="#僵尸对象" class="headerlink" title="僵尸对象"></a>僵尸对象</h3><p>僵尸对象是指所占内存已经被回收的对象，僵尸对象不能再被使用：</p>
<p><img src="http://images2015.cnblogs.com/blog/776348/201608/776348-20160829115246449-2140660921.png" alt=""></p>
<blockquote>
<p><strong>注意</strong>：不能使用[p retaion]让僵尸对象起死复生。</p>
</blockquote>
<h2 id="便利构造器的内存管理"><a href="#便利构造器的内存管理" class="headerlink" title="便利构造器的内存管理"></a>便利构造器的内存管理</h2><p>在OC中通常如果一个静态方法返回一个对象本身的话，在静态方法中我们需要调用autorelease方法，因为按照内存释放原则，在外部使用时不会进行alloc操作也就不需要再调用release或者autorelase，因为这个操作已经放到静态方法内部完成了：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">id</span>)personWithName:(<span class="built_in">NSString</span> *)name&#123;</span><br><span class="line">  Person *p =[[Person alloc] initWithName:name];</span><br><span class="line">  <span class="keyword">return</span> [p autorelease];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>第3行return [p autorelease];是最完美的解决方案，既不会内存泄露，也不会产生野指针。</li>
</ul>
<h2 id="collection的内存管理"><a href="#collection的内存管理" class="headerlink" title="collection的内存管理"></a>collection的内存管理</h2><p>collection就是NSArray，NSDictionary，NSSet…等容器类。</p>
<p>collection会自主管理自己内部的元素：</p>
<ol>
<li>加入collection中的对象会被retain。</li>
<li>移除出collection的对象会被release。</li>
<li>collection被释放会对内部所有对象release。</li>
</ol>
<h2 id="property的参数（MRC）"><a href="#property的参数（MRC）" class="headerlink" title="@property的参数（MRC）"></a>@property的参数（MRC）</h2><p>@property的参数分为三类，也就是说参数最多可以有三个，中间用逗号分隔。如果不进行设置或者只设置其中一类参数，程序会使用三类中的各个默认参数。</p>
<blockquote>
<p><strong>注意</strong>：本文基于MRC进行介绍，ARC下的情况不同，例如ARC下基本数据类型默认的属性参数为（atomic,readwrite,assign），对象类型默认的属性参数为（atomic,readwrite,strong）。</p>
</blockquote>
<h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><h4 id="atomic"><a href="#atomic" class="headerlink" title="atomic"></a>atomic</h4><p>低性能（默认），如果在多线程开发中一个属性可能会被两个及两个以上的线程同时访问，建议使用atomic，加锁，效率低。</p>
<h4 id="nonatomic"><a href="#nonatomic" class="headerlink" title="nonatomic"></a>nonatomic</h4><p>高性能，如果在多线程开发中一个属性不会被两个及两个以上的线程同时访问，建议使用nonatomic，不加锁，效率较高。</p>
<h3 id="读写属性"><a href="#读写属性" class="headerlink" title="读写属性"></a>读写属性</h3><h4 id="readwrite"><a href="#readwrite" class="headerlink" title="readwrite"></a>readwrite</h4><p>读写（默认），同时生成setter和getter的声明和实现。</p>
<h4 id="readonly"><a href="#readonly" class="headerlink" title="readonly"></a>readonly</h4><p>只读，只会生成getter的声明和实现。</p>
<h3 id="内存处理"><a href="#内存处理" class="headerlink" title="内存处理"></a>内存处理</h3><h4 id="assign"><a href="#assign" class="headerlink" title="assign"></a>assign</h4><p>直接赋值（适用于基本数据类型）：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  setter</span></span><br><span class="line">- (<span class="keyword">void</span>)setAge:(<span class="built_in">NSString</span> *)age&#123;</span><br><span class="line">     _age = age;<span class="comment">//基本数据类型：直接复制</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//  getter</span></span><br><span class="line">- (<span class="keyword">int</span>)age&#123;</span><br><span class="line">  <span class="keyword">return</span> _age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="retain-1"><a href="#retain-1" class="headerlink" title="retain"></a>retain</h4><p>release旧值，retain新值（适用于除copy外的OC对象类型）：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  setter  </span></span><br><span class="line">- (<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)name&#123;</span><br><span class="line">    <span class="comment">//1.先判断是不是新传进来的对象</span></span><br><span class="line">    <span class="keyword">if</span>(_name != name)&#123;</span><br><span class="line">       <span class="comment">//2.对旧对象做一次release,若没有旧对象，则没有影响</span></span><br><span class="line">        [_name release];</span><br><span class="line">       <span class="comment">//3.对新对象做一次retain</span></span><br><span class="line">        _name = [name retain]; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//  getter</span></span><br><span class="line"> - (<span class="built_in">NSString</span> *)name&#123;</span><br><span class="line">     <span class="keyword">return</span> [[_name retain]autorelease];</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h4 id="copy-1"><a href="#copy-1" class="headerlink" title="copy"></a>copy</h4><p>release旧值，copy新值（适用于NSStrig、NSArray、NSDictionary、block）：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  setter </span></span><br><span class="line">- (<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)name&#123; </span><br><span class="line">     <span class="comment">//1.先判断是不是新传进来的对象</span></span><br><span class="line">     <span class="keyword">if</span>(_name != name)&#123;</span><br><span class="line">    <span class="comment">//2.对旧对象做一次release,若没有旧对象，则没有影响</span></span><br><span class="line">     [_name release];</span><br><span class="line">   <span class="comment">//3.对新对象做一次copy</span></span><br><span class="line">     _name = [name <span class="keyword">copy</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  getter</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)name&#123;</span><br><span class="line">  <span class="keyword">return</span> [[_name retain]autorelease];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="set和get方法的名称"><a href="#set和get方法的名称" class="headerlink" title="set和get方法的名称"></a>set和get方法的名称</h3><p>修改set和get方法的名称，主要用于布尔类型。因为返回布尔类型的方法名一般以is开头，修改名称一般用在布尔类型中的getter：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@propery(setter=setAbc,getter=isRich) <span class="built_in">BOOL</span> rich;</span><br></pre></td></tr></table></figure>
<h2 id="自动释放池-1"><a href="#自动释放池-1" class="headerlink" title="自动释放池"></a>自动释放池</h2><p>在ios程序运行过程中，会创建无数个池子，这些池子都是以栈结构（先进后出）存在的，当一个对象调用autorelease时，会将这个对象放到位于栈顶的释放池中，当自动释放池被销毁时，会对池子里的所有对象做一次release。这样一来就起到了自动释放的作用，同时对象的销毁过程也得到了延迟（统一调用release方法）。看下面的代码：</p>
<p>&lt; 代码示例 &gt;</p>
<p><em>Person.h</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"></span><br><span class="line">-(Person *)initWithName:(<span class="built_in">NSString</span> *)name;</span><br><span class="line">+(Person *)personWithName:(<span class="built_in">NSString</span> *)name;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>Person.m</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Person.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark 带参数的构造函数</span></span><br><span class="line">-(Person *)initWithName:(<span class="built_in">NSString</span> *)name&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">self</span>=[<span class="keyword">super</span> init])&#123;</span><br><span class="line">        <span class="keyword">self</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#pragma mark 取得一个对象（静态方法）</span></span><br><span class="line">+(Person *)personWithName:(<span class="built_in">NSString</span> *)name&#123;</span><br><span class="line">    Person *p=[[[Person alloc]initWithName:name] autorelease];<span class="comment">//注意这里调用了autorelease</span></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#pragma mark 重写dealloc方法</span></span><br><span class="line">-(<span class="keyword">void</span>)dealloc&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Invoke Person(%@) dealloc method."</span>,<span class="keyword">self</span>.name);</span><br><span class="line">    [<span class="keyword">super</span> dealloc];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>main.m</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Person.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        Person *person1=[[Person alloc]init];</span><br><span class="line">        <span class="comment">//  调用了autorelease方法后面就不需要手动调用release方法了</span></span><br><span class="line">        [person1 autorelease];</span><br><span class="line">        <span class="comment">//  由于autorelease是延迟释放，所以这里仍然可以使用person1</span></span><br><span class="line">        person1.name=<span class="string">@"Kenshin"</span>;</span><br><span class="line">        <span class="comment">//  调用了autorelease方法</span></span><br><span class="line">        Person *person2=[[[Person alloc]initWithName:<span class="string">@"Kaoru"</span>] autorelease];</span><br><span class="line">        <span class="comment">//  内部已经调用了autorelease，所以不需要手动释放，这也符合内存管理原则，因为这里并没有alloc所以不需要release或者autorelease</span></span><br><span class="line">        Person *person3=[Person personWithName:<span class="string">@"rosa"</span>];</span><br><span class="line">        </span><br><span class="line">        Person *person4=[Person personWithName:<span class="string">@"jack"</span>];</span><br><span class="line">        [person4 retain];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*结果：</span><br><span class="line">     Invoke Person(rosa) dealloc method.</span><br><span class="line">     Invoke Person(Kaoru) dealloc method.</span><br><span class="line">     Invoke Person(Kenshin) dealloc method.</span><br><span class="line">     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li><code>main.m</code>：当上面@autoreleaespool代码块执行完之后，三个对象都得到了释放，但是person4并没有释放，原因很简单，由于我们手动retain了一次，当自动释放池释放后调用四个对的release方法，当调用完person4的release之后它的引用计数器为1，所有它并没有释放（这是一个反例，会造成内存泄露）；autorelase方法将一个对象的内存释放延迟到了自动释放池销毁的时候，因此上面person1，调用完autorelase之后它还存在，因此给name赋值不会有任何问题。</li>
<li>在OC中通常如果一个静态方法返回一个对象本身的话，在静态方法中我们需要调用autorelease方法，因为按照内存释放原则，在外部使用时不会进行alloc操作也就不需要再调用release或者autorelase，所以这个操作需要放到静态方法内部完成。</li>
<li>出了大括号，⾃动释放池才向各个对象统一发送release消息。 </li>
</ul>
<p>对于自动内存释放简单总结一下：</p>
<ol>
<li>autorelease方法不会改变对象的引用计数，只是将这个对象放到自动释放池中。</li>
<li>自动释放池本质上是一个stack，扔到pool中的对象等价于入栈。当自动释放池销毁后调用对象的release方法，不一定就能销毁对象（例如如果一个对象的引用计数器&gt;1则此时就无法销毁）。</li>
<li>由于自动释放池最后统一销毁对象，因此如果一个操作比较占用内存（对象比较多或者对象占用资源比较多），最好不要放到自动释放池或者考虑放到多个自动释放池。</li>
<li>OC中类库中的静态方法一般都不需要手动释放，内部已经调用了autorelease方法。</li>
</ol>
<h2 id="ARC内存管理机制"><a href="#ARC内存管理机制" class="headerlink" title="ARC内存管理机制"></a>ARC内存管理机制</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>ARC是自iOS 5之后增加的新特性，完全消除了手动管理内存的烦琐，编译器会自动在适当的地方插入适当的retain、release、autorelease语句。你不再需要担心内存管理，因为编译器为你处理了一切。</p>
<blockquote>
<p><strong>注意</strong>：ARC 是编译器特性，而不是 iOS 运行时特性（除了weak指针系统），它也不是类似于其它语言中的垃圾收集器。因此 ARC 和手动内存管理性能是一样的，有时还能更加快速，因为编译器还可以执行某些优化。</p>
</blockquote>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>ARC 的规则非常简单：只要还有一个指针指向对象，对象就会保持在内存中。当指针指向新值，或者指针不再存在时，相关联的对象就会自动释放。这条规则对于成员变量、synthesize属性、局部变量都是适用的。</p>
<h3 id="strong指针"><a href="#strong指针" class="headerlink" title="strong指针"></a>strong指针</h3><p>控制器中有个文本输入框框属性：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UITextField</span> *nameField;</span><br></pre></td></tr></table></figure>
<p>如果用户在文本框中输入mj这个字符串，那么就可以说，nameField的text属性是NSString对象的指针，也就是拥有者，该对象保存了文本输入框的内容：</p>
<p><img src="http://images2015.cnblogs.com/blog/776348/201608/776348-20160829225656824-1310872121.png" alt=""></p>
<p>如果执行了如下代码：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *name = <span class="keyword">self</span>.nameField.text;</span><br></pre></td></tr></table></figure>
<p>一个对象可以有多个拥有者,在上面代码中,name变量同样也是这个NSString对象的拥有者,也就是有两个指针指向同一个对象：</p>
<p><img src="http://images2015.cnblogs.com/blog/776348/201608/776348-20160829225708668-1476578082.png" alt=""></p>
<p>随后用户改变了输入框的内容，比如输入“mike”，此时nameFeild的text属性就指向了新的NSString对象。但原来的NSString对象仍然还有一个所有者(name变量)，因此会继续保留在内存中：</p>
<p><img src="http://images2015.cnblogs.com/blog/776348/201608/776348-20160829225720980-611397820.png" alt=""></p>
<p>当name变量获得新值,或者不再存在时（如局部变量方法返回时、实例变量对象释放时）,原先的NSString对象就不再拥有任何所有者,retain计数降为0,这时对象会被释放。如，给name变量赋予一个新值“Jake”：</p>
<p><img src="http://images2015.cnblogs.com/blog/776348/201608/776348-20160829225726980-1147773046.png" alt=""></p>
<p>我们称name和nameField.text指针为”strong指针”，因为它们能够保持对象的生命。默认所有实例变量和局部变量都是strong指针。</p>
<h3 id="weak指针"><a href="#weak指针" class="headerlink" title="weak指针"></a>weak指针</h3><p>weak型的指针变量仍然可以指向一个对象，但不属于对象的拥有者。</p>
<p>执行下面的代码：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__<span class="keyword">weak</span> <span class="built_in">NSString</span> *name = <span class="keyword">self</span>.nameField.text;</span><br></pre></td></tr></table></figure>
<p>name变量和nameField.text属性都指向同一个NSString对象,但name不是拥有者：</p>
<p><img src="http://images2015.cnblogs.com/blog/776348/201608/776348-20160829225732621-647918422.png" alt=""></p>
<p>如果文本框的内容发生变化,则原先的NSString对象就没有拥有者,会被释放,此时name变量会自动变成nil,称为空指针：</p>
<p><img src="http://images2015.cnblogs.com/blog/776348/201608/776348-20160829225738090-382980942.png" alt=""></p>
<p>weak型的指针变量自动变为nil是非常方便的，这样阻止了weak指针继续指向已释放对象，避免了野指针的产生，不然会导致非常难于寻找的Bug，空指针消除了类似的问题。</p>
<p>weak指针主要用于阻止所有权循环，典型例子是delegate模式，你的ViewController通过strong指针（self.view）拥有一个UITableView，UITableView的dataSource和delegate都是weak指针，指向你的ViewController：</p>
<p><img src="http://images2015.cnblogs.com/blog/776348/201608/776348-20160829225743199-540920695.png" alt=""></p>
<h3 id="strong和weak的使用注意"><a href="#strong和weak的使用注意" class="headerlink" title="strong和weak的使用注意"></a>strong和weak的使用注意</h3><p>下面代码是有问题的:</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">__<span class="keyword">weak</span> <span class="built_in">NSString</span> *str = [[<span class="built_in">NSString</span> alloc] initWithFormat:<span class="string">@"1234"</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, str); <span class="comment">// 打印出来是"(null)"</span></span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>str是个weak指针，所以NSString对象没有拥有者，在创建之后就会被立即释放。Xcode还会给出警告（”Warning: Assigning retained object to weak variable; object will be released after assignment”）。</li>
</ul>
<p>一般的指针变量默认就是strong类型的，因此一般我们对于strong变量不加__strong修饰，以下两行代码是等价的：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *name = <span class="keyword">self</span>.nameField.text;</span><br><span class="line">__<span class="keyword">strong</span> <span class="built_in">NSString</span> *name = <span class="keyword">self</span>.nameField.text;</span><br></pre></td></tr></table></figure>
<p>属性可以是strong或weak，写法如下：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">id</span> delegate;</span><br></pre></td></tr></table></figure>
<p>以下代码在ARC之前是可能会行不通的，因为在手动内存管理中，从NSArray中移除一个对象时，这个对象会发送一条release消息，可能会被立即释放。随后NSLog()打印该对象就会导致应用崩溃：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> obj = [array objectAtIndex:<span class="number">0</span>];</span><br><span class="line">[array removeObjectAtIndex:<span class="number">0</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, obj);</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>在ARC中这段代码是完全合法的，因为obj变量是一个strong指针，它成为了对象的拥有者，从NSArray中移除该对象也不会导致对象被释放。</li>
</ul>
<h3 id="ARC小结"><a href="#ARC小结" class="headerlink" title="ARC小结"></a>ARC小结</h3><ol>
<li>有了ARC,我们的代码可以清晰很多，你不再需要考虑什么时候retain或release对象。唯一需要考虑的是对象之间的关联，也就是哪个对象拥有哪个对象。</li>
<li>ARC也有一些限制：<ul>
<li>首先ARC只能工作于OC对象，如果应用使用了Core Foundation或malloc()/free()，此时还是需要你来手动管理内存。</li>
<li>此外ARC还有其它一些更为严格的语言规则，以确保ARC能够正常地工作。</li>
</ul>
</li>
<li>虽然ARC管理了retain和release，但并不表示你完全不需要关心内存管理的问题。因为strong指针会保持对象的生命，某些情况下你仍然需要手动设置这些指针为nil，否则可能导致应用内存不足。无论何时你创建一个新对象时，都需要考虑谁拥有该对象，以及这个对象需要存活多久。</li>
<li>ARC还能很好地结合C++使用，这对游戏开发是非常有帮助的。</li>
</ol>
<h3 id="ARC使用注意总结"><a href="#ARC使用注意总结" class="headerlink" title="ARC使用注意总结"></a>ARC使用注意总结</h3><ol>
<li>不能直接调用dealloc方法，不能调用retain，release，autorelease，retainCount方法，包括@selector(retain)的方式也不行。　　</li>
<li>允许重写dealloc，可以用dealloc方法来管理一些资源，不能用来释放实例变量。不允许调用[super dealloc]，在ARC下父类的dealloc同样由编译器来自动完成。</li>
<li>Core Foundation类型的对象仍然可以用CFRetain，CFRelease这些方法。</li>
<li>不能在C结构体中使用对象指针，如果有类似功能可以创建一个OC类来管理这些对象。</li>
<li>在id和void＊之间没有简便的转换方法，同样在OC和Core Foundation类型之间的转换都需要使用编译器制定的转换函数。</li>
<li>不能再使用NSAutoreleasePool对象，ARC提供了@autoreleasepool块来代替它，这样更有效率。</li>
<li>不能使用内存存储区（不能再使用NSZone）。</li>
<li>不能以new为开头给一个属性命名。</li>
<li>声明IBOutlet时一般应当使用weak，除了对StoryBoard这样nib中间的顶层对象要用strong</li>
<li>weak相当于老版本的assign，strong相当于retain。</li>
<li>只要没有强指针指向对象，对象就会被释放。</li>
</ol>
<h3 id="property修饰符小结"><a href="#property修饰符小结" class="headerlink" title="@property修饰符小结"></a>@property修饰符小结</h3><ol>
<li><code>strong</code>（修饰对象用__strong，适用于OC对象）: 强引用，相当于原来的retain，每次赋值引用计数器加1，只要指针引用这个对象，这个对象就不会被销毁。</li>
<li><code>weak</code>（修饰对象用__weak，适用于OC对象）: 弱引用，相当于原来的assign，该属性所声明的变量将没有对象的所有权，并且当对象被释放之后，对象将被自动赋值nil，记住IBOutlet应该使用weak。</li>
<li><code>unsafe_unretained</code>（修饰对象用__unsafe_unretained，适用于OC对象）:和weak类似并没有对象的所有权，区别就是如果对象释放后它不会像weak一样自动将指针设置为nil，有可能出现野指针，iOS5之前的系统用该属性代替weak来使用。</li>
<li><code>copy</code>（只能做修饰符不能直接修饰对象，适用于OC对象）: 和之前的copy一样，适用于NSString、NSArray、NSDictionary、Block。</li>
<li><code>assign</code>（只能做修饰符不能直接修饰对象，适用于基本数据类型）: 对象不能使用assign。</li>
</ol>
<h3 id="autoreleasing"><a href="#autoreleasing" class="headerlink" title="__autoreleasing"></a>__autoreleasing</h3><p><code>__autoreleasing</code>（只能修饰变量不能修饰属性）：修饰一个对象在使用完之后自动释放，通常用于延迟释放内存，同在MRC下和调用对象的autorelease方法是等效的。</p>
<p><code>__autoreleasing</code>主要用于函数参数是OC对象指针的情况下（也就是参数”NSObject **obj”类型，指针的指针），典型的应用就是NSError的使用。在这种情况下，经常需要在函数内部重新创建一个对象给传入的参数赋值（修改参数内容），如果使用<code>__autorelesing</code>关键字编译器在处理内部函数时会使用自动释放池，即保证内部对象能够正常释放又可以修改外部变量。之所以很多时候使用NSError作为参数传递到一些方法中没有将变量声明为<code>__autoreleasing</code>是因为编译器已经自动做了处理（因此，如果考虑到性能推荐还是加上此关键字）。</p>
<h2 id="内存管理中的循环引用问题以及解决"><a href="#内存管理中的循环引用问题以及解决" class="headerlink" title="内存管理中的循环引用问题以及解决"></a>内存管理中的循环引用问题以及解决</h2><p>不能使用#import的方式相互包含，这就形成了循环引用。当存在循环依赖时（A类使用B类，B类使用A类），内存将无法释放从而造成内存泄露，可以用<code>@class</code>防止循环导入。</p>
<p>新的关键字<code>@class</code>能够解决循环引用问题，提高性能。</p>
<p>@class的作用：声明一个类，告诉编译器某个名称是一个类。</p>
<p>开发中引用一个类的规范：</p>
<ol>
<li>在.h文件中使用@class来声明类。</li>
<li>在.m文件中真正要使用到的时候，使用#import来包含类中的所有东西。</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.cnblogs.com/mjios/" target="_blank" rel="external">M了个J的博客</a></p>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[【05】构造方法和description方法]]></title>
      <url>http://sanfordy.com/2016/08/25/%E3%80%96A%E3%80%97%E3%80%902-0%E3%80%91OC-%E8%AF%AD%E6%B3%95/%E3%80%9005%E3%80%91%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E5%92%8Cdescription%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<blockquote>
<p>默认的构造方法，也就是init方法，它是不接收任何参数的。因此，在实际开发中，为了方便，会经常自定义构造方法。</p>
</blockquote>
<a id="more"></a>
<h2 id="知识回顾"><a href="#知识回顾" class="headerlink" title="知识回顾"></a>知识回顾</h2><p>在前面中已经介绍了如何定义类和创建并初始化对象，比如有Student这个类：</p>
<p>&lt; 代码示例 &gt;</p>
<p><em>Student.h</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Student</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> _age;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)setAge:(<span class="keyword">int</span>)age;</span><br><span class="line">- (<span class="keyword">int</span>)age;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>Student.m</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Student.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Student</span></span></span><br><span class="line">- (<span class="keyword">void</span>)setAge:(<span class="keyword">int</span>)age &#123;</span><br><span class="line">    _age = age;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">int</span>)age &#123;</span><br><span class="line">    <span class="keyword">return</span> _age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>main.m</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Student.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        Student *stu = [[Student alloc] init];</span><br><span class="line">        </span><br><span class="line">        stu.age = <span class="number">10</span>;</span><br><span class="line">        </span><br><span class="line">        [stu release];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li><code>main.m</code>：在第7行调用Student的alloc方法分配内存，然后再调用init方法初始化对象，像init这样用来初始化对象的方法，我们可以称为”构造方法”。</li>
</ul>
<h2 id="自定义构造方法"><a href="#自定义构造方法" class="headerlink" title="自定义构造方法"></a>自定义构造方法</h2><p>默认的构造方法，也就是init方法，它是不接收任何参数的。因此，在实际开发中，为了方便，会经常自定义构造方法。</p>
<h3 id="自定义构造方法的规范"><a href="#自定义构造方法的规范" class="headerlink" title="自定义构造方法的规范"></a>自定义构造方法的规范</h3><ol>
<li>一定是对象方法，以减号开头</li>
<li>返回值一般是id类型</li>
<li>方法名一般以initWith开头</li>
</ol>
<p>接下来，自定义一个构造方法，可以传入一个age参数来初始化Student对象：</p>
<p>&lt; 代码示例 &gt;</p>
<p><em>Student.h</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  在Student.h中添加方法声明，构造方法的方法名一般都会以init开头，返回值跟init方法一样为id类型，id可以代表任何OC对象。这个构造方法接收一个int类型的age参数，目的是在初始化Student对象时，顺便设置成员变量_age的值。</span></span><br><span class="line">- (<span class="keyword">id</span>)initWithAge:(<span class="keyword">int</span>)age;</span><br></pre></td></tr></table></figure>
<p><em>Student.m</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)initWithAge:(<span class="keyword">int</span>)age &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> != <span class="literal">nil</span>) &#123;</span><br><span class="line">        _age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li><code>Student.m</code>：在第2行调用了父类的init方法，它会初始化Student对象所拥有的父类成员变量并返回初始化好的Student对象，这里把返回值赋值给了self，self代表Student对象本身。</li>
<li><code>Student.m</code>：第3~5行的意思是：如果self不为nil，也就是父类init成功，就初始化Student对象自己所拥有的成员变量。</li>
<li><code>Student.m</code>：最后返回一个初始化完成的对象，整个构造方法就结束了。</li>
<li><code>Student.m</code>：由于C语言和OC的语法特性，我们可以对构造方法进行简化：</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)initWithAge:(<span class="keyword">int</span>)age &#123;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="keyword">self</span> = [<span class="keyword">super</span> init] ) &#123;</span><br><span class="line">        _age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="调用自定义构造方法"><a href="#调用自定义构造方法" class="headerlink" title="调用自定义构造方法"></a>调用自定义构造方法</h3><p>&lt; 代码示例 &gt;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Student *stu = [[Student alloc] initWithAge:<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"age is %i"</span>, stu.age);</span><br><span class="line"></span><br><span class="line">[stu release];</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2015-12-6 03:24:47.880 构造方法[448:303] age is 10</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>在第1行调用了构造方法initWithAge:，并传入10作为参数，因此Student对象的成员变量_age会变为10。</li>
</ul>
<h3 id="自定义构造方法使用注意"><a href="#自定义构造方法使用注意" class="headerlink" title="自定义构造方法使用注意"></a>自定义构造方法使用注意</h3><ol>
<li>子类拥有的成员变量包括自己的成员变量以及从父类继承而来的成员变量，在重写构造方法的时候应该首先对从父类继承而来的成员变量进行初始化，即先调用父类的构造方法[super init];对从父类继承而来的成员变量进行初始化，再进行子类内部成员变量的初始化。</li>
<li>重写构造方法的目的：为了让对象方法一创建出来，成员变量就会有一些固定的值。</li>
</ol>
<h3 id="自定义构造方法的完整代码示例"><a href="#自定义构造方法的完整代码示例" class="headerlink" title="自定义构造方法的完整代码示例"></a>自定义构造方法的完整代码示例</h3><p>&lt; 代码示例 &gt;</p>
<p><em>Person.h</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@property</span> <span class="keyword">int</span> no;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  声明了两个接受参数的自定义构造方法</span></span><br><span class="line">- (<span class="keyword">id</span>)initWithName:(<span class="built_in">NSString</span> *)name;</span><br><span class="line">- (<span class="keyword">id</span>)initWithName:(<span class="built_in">NSString</span> *)name</span><br><span class="line">             andNo:(<span class="keyword">int</span>)no;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>Person.m</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Person.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - 自定义构造方法</span></span><br><span class="line"><span class="comment">//  接受一个参数的构造方法</span></span><br><span class="line">- (<span class="keyword">id</span>)initWithName:(<span class="built_in">NSString</span> *)name&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        _name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  接受两个参数的构造方法</span></span><br><span class="line">- (<span class="keyword">id</span>)initWithName:(<span class="built_in">NSString</span> *)name andNo:(<span class="keyword">int</span>)no&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        _name = name;</span><br><span class="line">        _no = no;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>Student.h</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Person.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  Student继承与Person</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Student</span> : <span class="title">Person</span></span></span><br><span class="line"><span class="keyword">@property</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  声明一个接受三个参数的自定义构造方法</span></span><br><span class="line">- (<span class="keyword">id</span>)initWithName:(<span class="built_in">NSString</span> *)name</span><br><span class="line">             andNo:(<span class="keyword">int</span>)no</span><br><span class="line">            andAge:(<span class="keyword">int</span>)age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>Student.m</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Student.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Student</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  接受三个参数的自定义构造方法</span></span><br><span class="line">- (<span class="keyword">id</span>)initWithName:(<span class="built_in">NSString</span> *)name andNo:(<span class="keyword">int</span>)no andAge:(<span class="keyword">int</span>)age&#123;</span><br><span class="line">    <span class="comment">//  调用父类的构造方法初始化从父类继承过来的两个成员变量：_name,_age</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> initWithName:name andNo:no]) &#123;</span><br><span class="line">        <span class="comment">//  初始化自己的成员变量</span></span><br><span class="line">        _age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  返回初始化好的对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>main.m</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Student.h"</span></span></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="comment">//  调用接受一个参数的自定义构造方法</span></span><br><span class="line">        Person *personA = [[Person alloc] initWithName:<span class="string">@"A"</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"personA.name-&gt;%@"</span>,personA.name);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//  调用接受两个参数的自定义构造方法</span></span><br><span class="line">        Person *personB = [[Person alloc] initWithName:<span class="string">@"B"</span> andNo:<span class="number">10086</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"personB.name-&gt;%@  personB.no-&gt;%d"</span>,personB.name,personB.no);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//  调用接受三个参数的自定义构造方法</span></span><br><span class="line">        Student *student = [[Student alloc] initWithName:<span class="string">@"C"</span> andNo:<span class="number">10001</span> andAge:<span class="number">18</span>];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"student.name-&gt;%@  student.no-&gt;%d  student.age-&gt;%d"</span>,student.name,student.no,student.age);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2015-12-08 12:34:25.561 自定义构造方法[81570:1731250] personA.name-&gt;A</span><br><span class="line">2015-12-08 12:34:25.563 自定义构造方法[81570:1731250] personB.name-&gt;B  personB.no-&gt;10086</span><br><span class="line">2015-12-08 12:34:25.563 自定义构造方法[81570:1731250] student.name-&gt;C  student.no-&gt;10001  student.age-&gt;18</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<h2 id="便利构造器"><a href="#便利构造器" class="headerlink" title="便利构造器"></a>便利构造器</h2><p>便利构造器是在自定义构造方法的基础上进步了一小步：封装了对象创建的过程，使用起来更方便。</p>
<p>便利构造器是”+”（静态）方法，返回本类型的实例对象，方法名以类名开头：</p>
<p><em>main.m</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Person.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    </span><br><span class="line">    Person *p=[[Person alloc]initWithName:<span class="string">@"Kenshin"</span> andAge:<span class="number">28</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"name=%@,age=%i"</span>,p.name,p.age);</span><br><span class="line">    <span class="comment">//结果：name=Kenshin,age=28</span></span><br><span class="line">    </span><br><span class="line">    Person *p2=[Person personWithName:<span class="string">@"Kaoru"</span> andAge:<span class="number">27</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"name=%@,age=%i"</span>,p2.name,p2.age);</span><br><span class="line">    <span class="comment">//结果：name=Kaoru,age=27</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>Person.h</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@property</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">-(<span class="keyword">id</span>)initWithName:(<span class="built_in">NSString</span> *)name andAge:(<span class="keyword">int</span> )age;</span><br><span class="line"></span><br><span class="line">+(<span class="keyword">id</span>)personWithName:(<span class="built_in">NSString</span> *)name andAge:(<span class="keyword">int</span> )age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>Person.m</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Person.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义构造方法</span></span><br><span class="line">-(<span class="keyword">id</span>)initWithName:(<span class="built_in">NSString</span> *)name andAge:(<span class="keyword">int</span>)age&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">self</span>=[<span class="keyword">super</span> init])&#123; <span class="comment">//super代表父类</span></span><br><span class="line">        <span class="keyword">self</span>.name=name;</span><br><span class="line">        <span class="keyword">self</span>.age=age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过静态方法获得一个对象</span></span><br><span class="line">+(<span class="keyword">id</span>)personWithName:(<span class="built_in">NSString</span> *)name andAge:(<span class="keyword">int</span>)age&#123;</span><br><span class="line">    Person *p=[[Person alloc]init];</span><br><span class="line">    p.name = name;</span><br><span class="line">    p.age = age;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h2 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>Literals (字面量)，是一种简易表示值的方法，OC提供了一些字面量语法，简化创建过程。</p>
<p>字面量创建的对象是便利构造的，且是不可变的。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>未使用字面量：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *str1 = [<span class="built_in">NSString</span> stringWithUTF8String:<span class="string">"Hello World"</span>];</span><br></pre></td></tr></table></figure>
<p>使用字面量：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *str2 = <span class="string">@"Hello World"</span>;</span><br></pre></td></tr></table></figure>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>未使用字面量：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *array1 = [<span class="built_in">NSArray</span> arrayWithObjects:<span class="string">@"a"</span>,<span class="string">@"b"</span>,<span class="string">@"c"</span>, <span class="literal">nil</span>];</span><br><span class="line">[array1 objectAtIndex:<span class="number">1</span>];</span><br></pre></td></tr></table></figure>
<p>使用字面量：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *array2 = @[<span class="string">@"a"</span>,<span class="string">@"b"</span>,<span class="string">@"c"</span>];</span><br><span class="line">array2[<span class="number">1</span>];</span><br></pre></td></tr></table></figure>
<h4 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h4><p>未使用字面量：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSDictionary</span> *dict1 = [<span class="built_in">NSDictionary</span> dictionaryWithObjectsAndKeys:p1,v2,p2,v2, <span class="literal">nil</span>];</span><br><span class="line">[dict1 valueForKey:v2];</span><br></pre></td></tr></table></figure>
<p>使用字面量：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSDictionary</span> *dict2 = @&#123;p1:v1,p2:v2&#125;;</span><br><span class="line">dict2[p1];</span><br></pre></td></tr></table></figure>
<h2 id="description方法"><a href="#description方法" class="headerlink" title="description方法"></a>description方法</h2><h3 id="NSLog回顾"><a href="#NSLog回顾" class="headerlink" title="NSLog回顾"></a>NSLog回顾</h3><p>众所周知，我们可以用NSLog函数来输出字符串和一些基本数据类。其实，除了可以输出基本数据类型，NSLog函数还可以输出任何OC对象：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Student *stu = [[Student alloc] initWithAge:<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, stu);</span><br><span class="line"></span><br><span class="line">[stu release];</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2015-04-19 14:46:49.896 构造方法[492:303] &lt;Student: 0x100109910&gt;</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>在第3行用NSLog函数输出stu对象，注意左边的格式符%@，以后想输出OC对象，就得用%@这个格式符。NSLog函数一旦发现用%@输出某个OC对象时，就会调用这个对象的description方法（这个方法返回值是NSString类型，是OC中的字符串类型），并且将description方法返回的字符串代替%@的位置进行输出。description方法的默认实现是返回这样的格式：&lt;类名: 对象的内存地址&gt;。</li>
<li>%@只能用于输出OC对象，不能输出结构体等其他类型。</li>
</ul>
<h3 id="NSLog相关补充"><a href="#NSLog相关补充" class="headerlink" title="NSLog相关补充"></a>NSLog相关补充</h3><p>&lt; 代码示例 &gt;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  1.打印对象地址</span></span><br><span class="line">Person *aperson = [[Person alloc]init];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%p"</span>,aperson);</span><br><span class="line"><span class="comment">//  2.打印当前代码行号</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%d"</span>,__LINE__);</span><br><span class="line"><span class="comment">//  3.打印当前文件路径</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%s"</span>,__FILE__);</span><br><span class="line"><span class="comment">//  4.打印所属方法或函数名</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%s"</span>,__func__);</span><br></pre></td></tr></table></figure>
<h3 id="重写description方法"><a href="#重写description方法" class="headerlink" title="重写description方法"></a>重写description方法</h3><p>description方法的默认实现是返回类名和对象的内存地址，这样的话，使用NSLog输出OC对象，意义就不是很大，因为我们并不关心对象的内存地址，比较关心的是对象内部的一些成变量的值。因此，会经常重写description方法，覆盖description方法的默认实现。</p>
<p>比如，重写Person的description方法，返回成员变量_name，_age的值：</p>
<p>&lt; 代码示例 &gt;</p>
<p><em>Person.h</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"> <span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line"> <span class="keyword">@property</span> <span class="built_in">NSString</span> *name;</span><br><span class="line"> <span class="keyword">@property</span> <span class="keyword">int</span> age; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>Person.m</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Person.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line">-(<span class="built_in">NSString</span> *)description&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"&#123;name:%@,age:%i&#125;"</span>,<span class="keyword">self</span>.name,<span class="keyword">self</span>.age];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>main.m</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Person.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line"></span><br><span class="line">    Person *p=[[Person alloc]init];</span><br><span class="line">    p.name=<span class="string">@"Kenshin"</span>;</span><br><span class="line">    p.age=<span class="number">28</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,p);<span class="comment">//此时会调用对象description方法返回对应的描述信息</span></span><br><span class="line">    <span class="comment">/*结果：</span><br><span class="line">     name:Kenshin,age:28&#125;</span><br><span class="line">     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="description方法的陷阱"><a href="#description方法的陷阱" class="headerlink" title="description方法的陷阱"></a>description方法的陷阱</h3><p>千万不要在description方法中同时使用%@和self，下面的写法是错误的：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSString</span> *)description &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@"</span>, <span class="keyword">self</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>第2行同时使用了%@和self，代表要调用self的description方法，因此最终会导致程序陷入死循环，循环调用description方法。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.cnblogs.com/mjios/" target="_blank" rel="external">M了个J的博客</a></p>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[【04】关键字self、点语法]]></title>
      <url>http://sanfordy.com/2016/08/25/%E3%80%96A%E3%80%97%E3%80%902-0%E3%80%91OC-%E8%AF%AD%E6%B3%95/%E3%80%9004%E3%80%91%E5%85%B3%E9%94%AE%E5%AD%97self%E3%80%81%E7%82%B9%E8%AF%AD%E6%B3%95/</url>
      <content type="html"><![CDATA[<blockquote>
<p>在C#、Java中都有一个关键字this用于表示当前方法的调用者，其实在OC中也有一个类似的关键字self（self是一个指针），只是self不仅可以表示当前对象还可以表示类本身，也就是说它既可以用在静态方法中又可以用在动态方法中。</p>
</blockquote>
<a id="more"></a>
<h2 id="关键字self"><a href="#关键字self" class="headerlink" title="关键字self"></a>关键字self</h2><p>在C#、Java中都有一个关键字this用于表示当前方法的调用者，其实在OC中也有一个类似的关键字self（self是一个指针），只是self不仅可以表示当前对象还可以表示类本身，也就是说它既可以用在静态方法中又可以用在动态方法中：</p>
<p>&lt; 代码示例 &gt;</p>
<p><em>Person.h</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@property</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)name andAge:(<span class="keyword">int</span>)age;</span><br><span class="line"></span><br><span class="line">+(<span class="keyword">void</span>)showMessage;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>Person.m</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Person.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line">-(<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)name andAge:(<span class="keyword">int</span>)age&#123;</span><br><span class="line"><span class="comment">//    _name=name;</span></span><br><span class="line"><span class="comment">//    _age=age;</span></span><br><span class="line">    <span class="keyword">self</span>.name=name;</span><br><span class="line">    <span class="keyword">self</span>.age=age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+(<span class="keyword">void</span>)printInfo&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Hello,World!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+(<span class="keyword">void</span>)showMessage&#123;</span><br><span class="line">    [<span class="keyword">self</span> printInfo];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>main.m</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Person.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line"></span><br><span class="line">    Person *p=[[Person alloc]init];</span><br><span class="line">    [p setName:<span class="string">@"Kenshin"</span> andAge:<span class="number">28</span>];</span><br><span class="line">    [Person showMessage];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>在上面代码中可以看到setName: andAge:方法是一个动态方法，此时self就代表调用对象。而在showMessage方法中self调用了类的静态方法printInfo，此时self代表调用的类。因此可以总结出<code>self</code>代表着当前方法的调用者。</li>
</ul>
<h2 id="点语法"><a href="#点语法" class="headerlink" title="点语法"></a>点语法</h2><h3 id="点语法的作用"><a href="#点语法的作用" class="headerlink" title="点语法的作用"></a>点语法的作用</h3><p>OC设计点语法的目的，是为了让其他语言的开发者可以很快的上手OC语言开发，使用点语法，让它和其他面向对象的语言如java很像。</p>
<h3 id="点语法的本质"><a href="#点语法的本质" class="headerlink" title="点语法的本质"></a>点语法的本质</h3><p>点语法的本质是方法的调用，而不是访问成员变量，当使用点语法时，编译器会自动展开成相应的方法。切记点语法的本质是转换成相应的set和get方法，如果没有set和get方法，则不能使用点语法。</p>
<p>编译器如何知道是set方法还是get方法？主要是看赋值：</p>
<ol>
<li>Stu.age=10;展开为：[stu setAge:10];</li>
<li>int  a=stu.age;展开为：[stu age];</li>
</ol>
<blockquote>
<p><strong>注意</strong>：在OC中访问成员变量只有一种方式即使用-&gt; 如stu-&gt;age，这种情况要求在@public的前提下。</p>
</blockquote>
<h3 id="传统的get方法和set方法"><a href="#传统的get方法和set方法" class="headerlink" title="传统的get方法和set方法"></a>传统的get方法和set方法</h3><p>在正式学习OC的点语法之前，先来看一下传统的get方法和set方法。定义一个Student类，拥有一个成员变量age和对应的get\set方法：</p>
<p>&lt; 代码示例 &gt;</p>
<p><em>Student.h</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Student</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="comment">//  定义了一个成员变量age，是@protected权限的，所以外界不能直接访问它。</span></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  声明了age变量的set方法。</span></span><br><span class="line">- (<span class="keyword">void</span>)setAge:(<span class="keyword">int</span>)newAge;</span><br><span class="line"><span class="comment">//  声明了age变量的get方法。</span></span><br><span class="line">- (<span class="keyword">int</span>)age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>Student.m</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Student.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Student</span></span></span><br><span class="line"><span class="comment">//  实现了set方法</span></span><br><span class="line">- (<span class="keyword">void</span>)setAge:(<span class="keyword">int</span>)newAge &#123;</span><br><span class="line">    age = newAge;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  实现了get方法</span></span><br><span class="line">- (<span class="keyword">int</span>)age &#123;</span><br><span class="line">    <span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>main.m</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Student.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="comment">//  创建Student对象</span></span><br><span class="line">        Student *stu = [[Student alloc] init];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 调用set方法设置age的值</span></span><br><span class="line">        [stu setAge:<span class="number">10</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 调用get方法获取age的值</span></span><br><span class="line">        <span class="keyword">int</span> age = [stu age];</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"age is %i"</span>, age);</span><br><span class="line">        <span class="comment">//  释放Student对象</span></span><br><span class="line">        [stu release];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2015-12-06 01:03:19.002 点语法[6164:303] age is 10</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>这就是OC传统的get方法和set方法的简单使用，对初学者来说，这个语法比较奇怪，因为它的方法调用是用方括号[ ]完成的。因此，OC最终引入了点语法。</li>
</ul>
<h3 id="使用点语法代替传统的set和get方法"><a href="#使用点语法代替传统的set和get方法" class="headerlink" title="使用点语法代替传统的set和get方法"></a>使用点语法代替传统的set和get方法</h3><p>上面演示了OC传统get\set方法的简单用法，接下来使用点语法来代替，前面main.m中main函数的代码可以改为：</p>
<p>&lt; 代码示例 &gt;</p>
<p><em>main.m</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        Student *stu = [[Student alloc] init];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置age的值</span></span><br><span class="line">        stu.age = <span class="number">10</span>; <span class="comment">// 等价于[stu setAge:10];</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 取出age的值</span></span><br><span class="line">        <span class="keyword">int</span> age = stu.age; <span class="comment">// 等价于int age = [stu age];</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"age is %i"</span>, age);</span><br><span class="line">        </span><br><span class="line">        [stu release];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2015-12-06 01:03:19.002 点语法[6164:303] age is 10</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>注意第7行代码，把原来的[stu setAge:10]替换成了stu.age = 10。这两种写法是完全等价的。即这里的stu.age并不是代表直接访问stu对象的成员变量age，而是编译器遇到stu.age = 10的时候会自动将代码展开成[stu setAge:10]<br><img src="http://images2015.cnblogs.com/blog/776348/201608/776348-20160825153645351-1838771832.png" alt=""></li>
<li>因此，OC中点语法的含义跟Java是完全不一样的，OC点语法的本质是方法调用，不是直接访问成员变量。至于这个点语法代表的是get方法还是set方法，那就取决于你是取值还是设值，取值就是get方法(如第10行代码)，设值就是set方法(如第7行代码)。 </li>
<li>如果你想验证点语法是不是方法调用的话，有很多方法。比如你可以在Student.m的set方法和get方法内部用NSLog加一些打印信息，如果程序运行后有输出打印信息，说明的确是调用了get方法或者set方法：</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Student.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Student</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setAge:(<span class="keyword">int</span>)newAge &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"调用了setAge方法"</span>);</span><br><span class="line">    age = newAge;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">int</span>)age &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"调用了age方法"</span>);</span><br><span class="line">    <span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h2 id="点语法和self的陷阱"><a href="#点语法和self的陷阱" class="headerlink" title="点语法和self的陷阱"></a>点语法和self的陷阱</h2><p>&lt; 代码示例 &gt;</p>
<p><em>Person.h</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@property</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>Person.m</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Person.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line"> - (<span class="keyword">void</span>)setAge:(<span class="keyword">int</span>)newAge &#123;</span><br><span class="line">     <span class="keyword">self</span>.age = newAge;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li><code>Person.m</code>：第6行中的self代表着当前调用setAge:方法的对象。但是第6行代码是绝对错误的，会造成死循环。因为前面已经说过了，OC点语法的本质是方法调用，所以5-7行的代码相当于：</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  很明显，会造成循环调用setAge:方法，程序就这样崩溃了</span></span><br><span class="line">- (<span class="keyword">void</span>)setAge:(<span class="keyword">int</span>)newAge &#123;</span><br><span class="line">    [<span class="keyword">self</span> setAge:newAge];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="一点小建议"><a href="#一点小建议" class="headerlink" title="一点小建议"></a>一点小建议</h2><p>如果是第一次接触OC的点语法，你可能会真的以为stu.age的意思是直接访问stu对象的成员变量age（其实不是，前面提过访问对象的成员变量只能通过-&gt;）。其实，有一部分原因是因为我这里定义的Student类的成员变量名就叫做age。为了更好地区分点语法和成员变量访问，一般我们定义的成员变量会以下划线 _ 开头。比如叫做 _age 。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.cnblogs.com/mjios/" target="_blank" rel="external">M了个J的博客</a></p>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[【03】方法和属性]]></title>
      <url>http://sanfordy.com/2016/08/24/%E3%80%96A%E3%80%97%E3%80%902-0%E3%80%91OC-%E8%AF%AD%E6%B3%95/%E3%80%9003%E3%80%91%E6%96%B9%E6%B3%95%E5%92%8C%E5%B1%9E%E6%80%A7/</url>
      <content type="html"><![CDATA[<blockquote>
<p>通常一个成员变量的访问不会直接通过成员变量而是通过属性暴漏给外界。在OC中属性定义方式是通过对应的setter和getter方法进行实现。没错，上面setName其实就是属性的setter方法，但是在OC中gettter方法通常使用变量名，而不加”get”。</p>
</blockquote>
<a id="more"></a>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="方法的概念"><a href="#方法的概念" class="headerlink" title="方法的概念"></a>方法的概念</h3><p>&lt; 代码示例 &gt;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[person sayHi];</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>在OC中没有person调用”sayHi”这种表述，而是使用消息发送机制：<code>[receiver message];</code></li>
<li>正确表述：给person对象发送sayHi消息，person接收到sayHi消息，person找到sayHi方法并执行。</li>
</ul>
<p>在OC中方法分为类（静态）方法和对象（动态）方法两种：</p>
<ol>
<li>- 表示对象方法（动态方法），对象方法只能由对象来调用。<code>对象方法中可以访问当前对象的成员变量，因为成员变量存储于对象的内存空间中</code>。</li>
<li>+ 表示类方法（静态方法），类方法只能由类来调用。<code>类方法中不能访问成员变量，因为类并没有创建内存空间来存储类中的成员变量</code>。</li>
</ol>
<blockquote>
<p><strong>注意</strong>：如果一个方法在.h中有声明则该方法是公共方法，如果没有在.h中声明直接在.m中定义则该方法是私有方法，外部无法访问。</p>
</blockquote>
<h3 id="方法名"><a href="#方法名" class="headerlink" title="方法名"></a>方法名</h3><h4 id="不带参数的方法"><a href="#不带参数的方法" class="headerlink" title="不带参数的方法"></a>不带参数的方法</h4><p>声明：</p>
<p><img src="http://images2015.cnblogs.com/blog/776348/201608/776348-20160824175036667-1382470729.png" alt=""></p>
<p>调用：</p>
<p><img src="http://images2015.cnblogs.com/blog/776348/201608/776348-20160824175044058-1682041607.png" alt=""></p>
<h4 id="带参数的方法"><a href="#带参数的方法" class="headerlink" title="带参数的方法"></a>带参数的方法</h4><p>声明：</p>
<p><img src="http://images2015.cnblogs.com/blog/776348/201608/776348-20160824175049808-92091325.png" alt=""></p>
<p>调用：</p>
<p><img src="http://images2015.cnblogs.com/blog/776348/201608/776348-20160824175104058-1189198860.png" alt=""></p>
<blockquote>
<p><strong>注意</strong>：冒号也是方法名的一部分。</p>
</blockquote>
<h3 id="方法的定义"><a href="#方法的定义" class="headerlink" title="方法的定义"></a>方法的定义</h3><p>假设现在需要一个对象方法去设置用户姓名，还需一个类方法打印一些信息：</p>
<p>&lt; 代码示例 &gt;</p>
<p><em>Person.h</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span>&#123;</span><br><span class="line">    <span class="keyword">@private</span></span><br><span class="line">    <span class="built_in">NSString</span> *_name;<span class="comment">//在OC中推荐成员变量名以_开头</span></span><br><span class="line">    <span class="keyword">int</span> _age;</span><br><span class="line">    <span class="keyword">@protected</span></span><br><span class="line">    <span class="built_in">NSString</span> *_nation;</span><br><span class="line">    <span class="keyword">@public</span></span><br><span class="line">    <span class="keyword">float</span> _height;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  声明一个动态方法，没有返回值</span></span><br><span class="line">-(<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)name;</span><br><span class="line"><span class="comment">//  声明一个静态方法，没有返回值</span></span><br><span class="line">+(<span class="keyword">void</span>)showMessage:(<span class="built_in">NSString</span> *)info;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>Person.m</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Person.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//实现一个动态方法</span></span><br><span class="line">-(<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)name&#123;</span><br><span class="line">    _name=name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现一个静态方法</span></span><br><span class="line">+(<span class="keyword">void</span>)showMessage:(<span class="built_in">NSString</span> *)info&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,info);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>在OC中方法的参数类型、返回值类型需要放到（）中，而且参数前必须使用”:”，并且此时”:”是方法名的一部分。当然，上面的方法只有一个参数，假设现在有一个方法可以同时设置年龄和籍贯，可以写成如下形式：</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  其中andNation可以省略不写，当然为了保证方法名更有意义建议书写时加上。</span></span><br><span class="line">-(<span class="keyword">void</span>)setAge:(<span class="keyword">int</span>)age andNation:(<span class="built_in">NSString</span> *)nation&#123;</span><br><span class="line">    _age=age;</span><br><span class="line">    _nation=nation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>通常一个成员变量的访问不会直接通过成员变量而是通过属性暴漏给外界。在OC中属性定义方式是通过对应的setter和getter方法进行实现。没错，上面setName其实就是属性的setter方法，但是在OC中gettter方法通常使用变量名，而不加”get”。</p>
<p>如果一个成员变量是<code>int age;</code>或者<code>int _age</code>;setter和getter的书写格式如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  setter：即set+首字母大写的成员变量名（忽略下划线）。</span></span><br><span class="line">-(<span class="keyword">void</span>)setAge:(<span class="keyword">int</span>)age;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  getter：即返回值类型和变量类型一致，方法名和成员变量名相同（忽略下划线）。</span></span><br><span class="line">-(<span class="keyword">int</span>)age;</span><br></pre></td></tr></table></figure>
<p>下面就看一下age属性的实现：</p>
<p>&lt; 代码示例 &gt;</p>
<p><em>Person.h</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span>&#123;</span><br><span class="line">    <span class="keyword">@private</span></span><br><span class="line">    <span class="built_in">NSString</span> *_name;<span class="comment">//在OC中推荐变量名以_开头</span></span><br><span class="line">    <span class="keyword">int</span> _age;</span><br><span class="line">    <span class="keyword">@protected</span></span><br><span class="line">    <span class="built_in">NSString</span> *_nation;</span><br><span class="line">    <span class="keyword">@public</span></span><br><span class="line">    <span class="keyword">float</span> _height;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//声明一个动态方法，没有返回值</span></span><br><span class="line">-(<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)name;</span><br><span class="line"><span class="comment">//声明一个静态方法，没有返回值</span></span><br><span class="line">+(<span class="keyword">void</span>)showMessage:(<span class="built_in">NSString</span> *)info;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明age的setter、getter方法</span></span><br><span class="line">-(<span class="keyword">int</span>)age;</span><br><span class="line">-(<span class="keyword">void</span>)setAge:(<span class="keyword">int</span>)age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>Person.m</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Person.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//实现一个动态方法</span></span><br><span class="line">-(<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)name&#123;</span><br><span class="line">    _name=name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//私有方法</span></span><br><span class="line">-(<span class="keyword">void</span>)setAge:(<span class="keyword">int</span>)age andNation:(<span class="built_in">NSString</span> *)nation&#123;</span><br><span class="line">    _age=age;</span><br><span class="line">    _nation=nation;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现一个静态方法</span></span><br><span class="line">+(<span class="keyword">void</span>)showMessage:(<span class="built_in">NSString</span> *)info&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,info);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现age的setter、getter方法</span></span><br><span class="line">-(<span class="keyword">int</span>)age&#123;</span><br><span class="line">    <span class="keyword">return</span> _age;</span><br><span class="line">&#125;</span><br><span class="line">-(<span class="keyword">void</span>)setAge:(<span class="keyword">int</span>)age&#123;</span><br><span class="line">    _age=age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h2 id="方法和属性的调用"><a href="#方法和属性的调用" class="headerlink" title="方法和属性的调用"></a>方法和属性的调用</h2><p>&lt; 代码示例 &gt;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Person.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        Person *p=[Person alloc];</span><br><span class="line">        p=[p init];</span><br><span class="line">        <span class="comment">//上面两句代码可以直接写成：Person *p=[[Person alloc] init];</span></span><br><span class="line">        <span class="comment">//还可以写成：Person *p=[Person new];</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//成员变量调用</span></span><br><span class="line">        p-&gt;_height=<span class="number">1.72</span>;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"height=%.2f"</span>,p-&gt;_height);<span class="comment">//结果：height=1.72</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//方法调用</span></span><br><span class="line">        [p setName:<span class="string">@"Kenshin"</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//属性调用</span></span><br><span class="line">        p.age=<span class="number">28</span>; <span class="comment">//等价于：[p setAge:28];</span></span><br><span class="line">        <span class="keyword">int</span> age=p.age;<span class="comment">//等价于：age=[p age];</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"age=%i"</span>,age); <span class="comment">//结果：age=28</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>关于方法的调用在这里不着重介绍了，我们可以看到p.age的调用方式，这就是OC中的点语法。其实点语法的本质还是调用对应的方法进行处理，这么做的目的只是为了开发人员书写方便而已（这就是语法糖的目的）。至于p.age是调用get方法还是调用set方法完全取决于当前操作是赋值操作还是读取操作。点语法具体见下篇。</li>
</ul>
<h2 id="property、-synthesize-关键字"><a href="#property、-synthesize-关键字" class="headerlink" title="@property、@synthesize 关键字"></a>@property、@synthesize 关键字</h2><p>通过上面的程序我们可以看到如果要定义一个属性，首先需要在.h中声明其次还要在.m中实现，而定义属性的代码基本都是类似的，那么有没有简单的方法呢？其实在OC中可以通过声明@property，同时通过@synthesize自动生成getter、setter方法（在xcode4.4后甚至都不用通过@synthesize只声明就可以使用）。</p>
<h3 id="关键字的使用"><a href="#关键字的使用" class="headerlink" title="关键字的使用"></a>关键字的使用</h3><p>xcode4.4之前：</p>
<p>&lt; 代码示例 &gt;</p>
<p><em>main.m</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Person.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        Person *aperson = [[Person alloc] init];</span><br><span class="line">        [aperson setAge:<span class="number">10</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//  使用点语法，打印成员变量的值以验证</span></span><br><span class="line">        <span class="comment">//  点语法的本质是调用了set和get方法</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"age = %d"</span>,aperson.age);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>Person.h</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  使用@property关键字实现_age成员变量的set和get方法的声明</span></span><br><span class="line"><span class="keyword">@property</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>Person.m</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Person.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  使用@synthesize关键字自动完成了_age成员变量的set和get方法的实现，并生成了一个_age成员变量。</span></span><br><span class="line"><span class="keyword">@synthesize</span> age = _age;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2015-12-28 19:09:16.540 22[19602:219033] age = 10</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<p>xcode4.4之后：</p>
<p>&lt; 代码示例 &gt;</p>
<p><em>main.m</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Person.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        Person *aperson = [[Person alloc] init];</span><br><span class="line">        [aperson setAge:<span class="number">10</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//  使用点语法为_age成员变量赋值</span></span><br><span class="line">        aperson.age = <span class="number">22</span>;</span><br><span class="line">        <span class="comment">//  使用set方法为成员变量赋值</span></span><br><span class="line">        [aperson setName:<span class="string">@"xiaoming"</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//  使用点语法，本质调用get方法</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"age = %d, name = %@"</span>,aperson.age,aperson.name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>Person.h</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span>&#123;</span><br><span class="line">    <span class="comment">//  类的成员变量，这样的方式默认为protected</span></span><br><span class="line">    <span class="comment">//  如果这里不写成员变量，那么使用属性会自动生成成员变量，但是默认为private的</span></span><br><span class="line">    <span class="keyword">int</span> _age;</span><br><span class="line">    <span class="built_in">NSString</span> *_name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  使用@property关键字生成成员变量的set和get方法的声明和实现</span></span><br><span class="line"><span class="keyword">@property</span> <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSString</span> *name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>Person.m</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Person.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  从xcode4.4之后，@property关键字独揽了三个功能，所以这里不用再写@synthesize</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2015-12-28 19:19:06.788 22[20135:225229] age = 22, name = xiaoming</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<h3 id="关键字使用注意"><a href="#关键字使用注意" class="headerlink" title="关键字使用注意"></a>关键字使用注意</h3><p>自从xcode 4.4后，@property就独揽了@property和@synthesize的功能，<code>@property int age;</code>这句话完成了3个功能：</p>
<p>&lt; 代码示例 &gt;</p>
<p><em>.h</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span>&#123;</span><br><span class="line">     <span class="comment">//  （2）在&#123;&#125;中生成一个@private的_age的成员变量。</span></span><br><span class="line">     <span class="keyword">@private</span></span><br><span class="line">     <span class="keyword">int</span> _age;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// （1）在@interface  @end中完成了_age成员变量set和get方法的声明。</span></span><br><span class="line">-(<span class="keyword">void</span>)setAge;</span><br><span class="line">-(<span class="keyword">int</span>)age;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>.m</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  （3）在@implementation  @end中完成了_age成员变量set和get方法的实现：</span></span><br><span class="line">- (<span class="keyword">void</span>)setAge:(<span class="keyword">int</span>)age&#123;</span><br><span class="line">    _age = age;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">int</span>)age&#123;</span><br><span class="line">    <span class="keyword">return</span> _age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>当然自己也可以手动写属性的实现方法：</p>
<ol>
<li>如果手动实现了set方法，那么编译器（@synthesize）就只生成get方法和成员变量。</li>
<li>如果手动实现了get方法，那么编译器（@synthesize）就只生成set方法和成员变量。</li>
<li>如果set和get方法都是手动实现的，那么编译器（@synthesize）将不会生成成员变量。</li>
</ol>
<h3 id="生成成员变量的注意事项"><a href="#生成成员变量的注意事项" class="headerlink" title="生成成员变量的注意事项"></a>生成成员变量的注意事项</h3><ol>
<li>只使用@property，不使用@synthesize：<ul>
<li>即使不使用@synthesize也会默认会在.m生成@synthersize property = _property;</li>
<li>编译器会自动生成一个名为_property的私有成员变量（对照自定义的成员变量列表，名字重复则用自定义[作用域由自己决定]，不重复则生成[作用域为私有]），并生成property属性的setter、getter方法的声明和实现。</li>
</ul>
</li>
<li>既使用@property，也使用@syntheszie（相当于重写系统默认的@synthersize）：<ul>
<li><code>@synthesize property;</code>：编译器会自动生成一个名为property的私有成员变量（对照自定义的成员变量列表，名字重复则用自定义[作用域由自己决定]，不重复则生成[作用域为私有]），并生成属性property的setter、getter方法的声明和实现。</li>
<li><code>@synthesize properyty = memberName;</code>（成员变量的名字一般使用下划线加属性名，比如这里：_property）：编译器会生成一个名为memberName的成员变量，（对照自定义的成员变量列表，名字重复则用自定义[作用域由自己决定]，不重复则生成[作用域为私有]），并生成属性property的setter、getter方法的声明和实现。</li>
</ul>
</li>
</ol>
<blockquote>
<p><strong>注意</strong>：有时候生成的成员变量跟自定义成员变量名字稍有差异（比如下划线），如果名字不一样则生成新的成员变量，如果名字一样则使用自定义成员变量，新的成员变量（比如_property）和自定义中名字相似的成员变量（比如property）是两个不同的成员变量。</p>
<p><strong>总结</strong>：现在一般直接使用@property，除非需要我们会重写@synthesize，@synthesize才是生成成员变量的关键，当生成成员变量后编译器会对照自定义的成员变量列表，如果生成的成员变量和自定义成员变量有冲突，则使用自定义的成员变量而不生成额外的成员变量。</p>
</blockquote>
<h2 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>懒加载——也称为延迟加载，即在需要的时候才加载（效率低，占用内存小）。所谓懒加载，写的是其get方法。</p>
<blockquote>
<p><strong>注意</strong>：如果是懒加载的话则一定要注意先判断是否已经有了，如果没有那么再去进行实例化</p>
</blockquote>
<h3 id="使用懒加载的好处"><a href="#使用懒加载的好处" class="headerlink" title="使用懒加载的好处"></a>使用懒加载的好处</h3><ol>
<li>不必将创建对象的代码全部写在viewDidLoad方法中，代码的可读性更强。</li>
<li>每个控件的getter方法中分别负责各自的实例化处理，代码彼此之间的独立性强，松耦合。</li>
<li>通过重写属性的getter方法可以完成lazyloading（懒加载）模式，使用lazyloding可以将代码按照模块封装，同时提高类的灵活度，也可以在一定时期内节省内存的使用。</li>
</ol>
<h2 id="SEL"><a href="#SEL" class="headerlink" title="SEL"></a>SEL</h2><h3 id="基本简介"><a href="#基本简介" class="headerlink" title="基本简介"></a>基本简介</h3><p>SEL：全称Selector，表示方法的地址。</p>
<p>下面演示一下寻找方法的过程：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person *p=[[Person alloc] init];</span><br><span class="line">　　[p test];</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>方法在内存中是这么存储的：<br><img src="http://images2015.cnblogs.com/blog/776348/201608/776348-20160830111935808-1922086063.png" alt=""></li>
<li>首先把test这个方法名包装成SEL类型的数据（SEL数据存放着方法的地址）；沿着isa找到本类，根据SEL数据在本类及所有父类中找到相同的方法地址；根据方法地址调用相应的方法。</li>
<li>在这个操作过程中有缓存，第一次找的时候是一个一个的找，非常耗性能，之后再用到的时候就直接使用。</li>
<li>SEL其实是对方法的一种包装，将方法包装成一个SEL类型的数据，去寻找对应的方法地址，找到方法地址后就可以调用方法。这些都是运行时特性，发消息就是发送SEL，然后根据SEL找到地址，调用方法。</li>
</ul>
<h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><ol>
<li>SEL 变量名 = @selector(方法名字);</li>
<li>SEL 变量名 = NSSelectorFromString(方法名字的字符串);</li>
<li>NSString *变量名 = NSStringFromSelector(SEL变量);</li>
<li>[对象　performSelector:SEL变量　withObject:参数];<ul>
<li>这样的机制大大的增加了我们的程序的灵活性，我们可以通过给一个方法传递SEL变量，让这个方法动态的执行某一个方法。我们也可以通过配置文件指定需要执行的方法，程序读取配置文件之后把方法的字符串翻译成为SEL变量然后给相应的对象发送这个消息。</li>
<li>从效率的角度上来说，执行的时候不是通过方法名字而是方法地址也就是一个整数来查找方法，由于整数的查找和匹配比字符串要快得多，所以这样可以在某种程度上提高执行的效率。</li>
</ul>
</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.cnblogs.com/mjios/" target="_blank" rel="external">M了个J的博客</a></p>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[【02】类和对象、成员变量]]></title>
      <url>http://sanfordy.com/2016/08/22/%E3%80%96A%E3%80%97%E3%80%902-0%E3%80%91OC-%E8%AF%AD%E6%B3%95/%E3%80%9002%E3%80%91%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E3%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F/</url>
      <content type="html"><![CDATA[<blockquote>
<p>OC相对于C语言多了面向对象特性，因此它也有类、对象、静态\动态方法、成员变量的概念。但是OC又没有其他面向对象语言那么多语法特性，OC本身对面向对象进行了精简。</p>
</blockquote>
<a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前面已经简单介绍过OC的基础知识，让大家对OC有个大致的印象，今天将重点解释OC面向对象的特性。OC相对于C语言多了面向对象特性，因此它也有类、对象、静态\动态方法、成员变量的概念。但是OC又没有其他面向对象语言那么多语法特性，OC本身对面向对象进行了精简。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ol>
<li>类的定义：具有相同特征和行为的事物的抽象。</li>
<li>类和对象是面向对象的核心。</li>
<li>对象是类的实例。类是对象的类型。</li>
<li>类是模板，对象是具体表现，任何对象都要占⽤内存空间。创建对象分两步：<ul>
<li>分配内存空间：根据类中声明的成员变量为对象分配内存，将所有成员变量置为默认值0，并返回首地址。</li>
<li>初始化：为对象的成员变量设置初始值。</li>
</ul>
</li>
<li>万事万物皆对象，例如：一只猫，一个饼干，一张火车票， 一个水杯，⼀个订单等。 </li>
<li>面向对象编程中使用对象完成程序。</li>
<li>开发中先创建类，再创建对象，然后使用对象。创建类包含接口部分和实现部分两部分：<ul>
<li>接口部分:对外声明类的特征和⾏为（类似于说明书）。</li>
<li>实现部分:对内实现行为（内部的具体实现）。</li>
</ul>
</li>
<li>指针存储对象的地址，代指对象。OC中使用指针代指对象，进⾏操作。 </li>
<li>抽象类的概念：抽象类是不完整的，它只能用作基类 。在面向对象编程中，抽象类主要用来进行类型隐藏和充当全局变量的角色。在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息（所以说它是不完整的）来描绘一个具体的对象，这样的类就是抽象类。比如，圆、 三角形这样一些具体概念，它们是不同的，但是它们又都属于形状这样一个概念 ， 形状这个概念在问题领域并不是直接存在的，它就是一个抽象概念 。而正是因为抽象的概念在问题领域没有对应的具体概念 ，所以用以表征抽象概念的抽象类是不能够实例化的。</li>
</ol>
<h2 id="类的创建"><a href="#类的创建" class="headerlink" title="类的创建"></a>类的创建</h2><p>在C#、Java等其他高级语言中定义一个类是相当简单点的，直接一个关键字class加一对大括号基本就完成了，但是在OC中类的定义相对变化比较大。现在假设需要定义一个Person类。</p>
<p>在Xcode中添加文件，选择Cocoa Class：</p>
<p><img src="http://images2015.cnblogs.com/blog/776348/201608/776348-20160821112138261-1295824583.png" alt=""></p>
<p>输入类名Person（一般使用类名命名文件，通常类名的第一个字母大写，且不能有下划线，如果有多个单词则使用驼峰标识，⽂件和类本质没有关系），并选择父类为NSObject：</p>
<p><img src="http://images2015.cnblogs.com/blog/776348/201608/776348-20160821112148761-533158696.png" alt=""></p>
<p>默认生成如下两个文件（在OC中定义一个类需要两个文件.h和.m）：</p>
<p>&lt; 代码示例 &gt;</p>
<p><em>Person.h</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><em>Person.m</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Person.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li><code>Person.h</code>：.h文件称为接口文件或头文件。放类的声明，包括成员变量、属性和方法声明。.h中的方法只是做一个声明，并不对方法进行实现。也就是说，只是说明一下方法名、方法的返回值类型、方法接收的参数类型而已，并不会编写方法内部的代码。</li>
<li><code>Person.h</code>：关键字@interface声明一个类，同时它必须以@end结束，在这两个关键字中间声明相关成员。</li>
<li><code>Person.h</code>：类名Person后面的冒号”:”表示继承，即第3行代码的意思是Student继承自NSObject。NSObject是OC的基类，所有的类最终都继承于这个类（但是需要注意OC中的基类并不只有一个，例如NSProxy也是OC的基类）。</li>
<li><code>Person.h</code>：因为NSObject被声明在Foundation.h中，所以导入了<foundation foundaton.h="">（这么描述的意思是导入Foundation框架中的Foundation.h声明文件）</foundation></li>
<li><code>Person.m</code>：.m称为实现⽂件。放属性、方法的具体实现。</li>
<li><code>Person.m</code>：关键字@implementation来实现一个类，@implementation后面紧跟的类名，表示究竟要实现哪一个类，同时必须以@end结尾。</li>
<li><code>Person.m</code>：在这两个关键字中间实现具体的属性、方法；由于.m中使用了Person类，所以需要导入声明文件“Person.h”。</li>
</ul>
<h2 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h2><p>假设在Person类中包含人员姓名（name）、年龄（age）、民族（nation）、身高（height）四个成员变量，同时姓名和年龄两个成员变量是私有的，身高是公开的，民族则限制为只有子类可以访问：</p>
<p>&lt; 代码示例 &gt;</p>
<p><em>Person.h</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span>&#123;</span><br><span class="line">    <span class="keyword">@private</span></span><br><span class="line">    <span class="comment">//  在OC中推荐成员变量名以_开头</span></span><br><span class="line">    <span class="built_in">NSString</span> *_name;</span><br><span class="line">    <span class="keyword">int</span> _age;</span><br><span class="line">    <span class="keyword">@protected</span></span><br><span class="line">    <span class="built_in">NSString</span> *_nation;</span><br><span class="line">    <span class="keyword">@public</span></span><br><span class="line">    <span class="keyword">float</span> _height;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>成员变量定义在.h文件中，同时必须定义在类后面的{}内。成员的可访问性通过四个关键字声明：（1）<code>@private</code>私有的，成员变量只有在当前类内部可以操作（所谓的内部，指的是响应类的􏰴􏰕􏰗􏰵􏰶􏰝􏰕@implementation和@end之间􏰷􏰸 ）。（2）<code>@protected</code>受保护的，成员变量只有当前类或子类可以操作（如果没有添加任何修饰则默认为@protected）。（3）<code>@public</code>公共的，所有类均可操作（对公共成员的操作使用“-&gt;”操作符 ）。（4）<code>@package</code>框架级别的，它类似于C#中的internal在框架内是公共的，但是框架外是私有的（也就是只能在一个框架内可以访问）。</li>
</ul>
<p>成员变量作用域的注意事项：</p>
<ol>
<li>在类的实现即.m文件中也可以声明成员变量，但是因为在其他文件中通常都只是包含头文件而不会包含实现文件，所以在这里声明的成员变量是@private的。在.m中定义的成员变量不能和它的头文件.h中的成员变量同名，在这期间使用@public等关键字也是徒劳的。</li>
<li>一个类继承了另一个类，那么就拥有了父类的所有成员变量和方法，注意所有的成员变量它都拥有，只是有的它不能直接访问。</li>
<li>为什么不推荐使用@public？答：使用@public关键字暴露了类内部的细节，不符合面向对象语言的三大特性之封装性。</li>
</ol>
<h2 id="对象的使用"><a href="#对象的使用" class="headerlink" title="对象的使用"></a>对象的使用</h2><p>那么既然身高是公共的，外界怎么访问呢？</p>
<p>&lt; 代码示例 &gt;</p>
<p><em>main.m</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Person.h"</span></span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">     <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">         Person *p=[Person alloc];</span><br><span class="line">         p=[p init];</span><br><span class="line">         <span class="comment">//上面两句代码可以直接写成：Person *p=[[Person alloc] init];</span></span><br><span class="line">         <span class="comment">//还可以写成：Person *p=[Person new];</span></span><br><span class="line">        p-&gt;_height=<span class="number">1.72</span>;</span><br><span class="line">        [p release];</span><br><span class="line">        <span class="comment">//结果：height=1.72</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"height=%.2f"</span>,p-_&gt;height);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>OC中使用[]进行方法调用，在OC中方法调用的本质就是给这个对象或类发送一个消息。</li>
<li>OC中所有的对象类型的变量都必须加上”*“，在OC中对象其实就是一个指针（例如之前看到的NSString也是如此，但是基本类型不用加”*”）。</li>
<li>在OC中类的实例化需要两个步骤：（1）分配内存：+ (id)alloc; +表示这个方法属于类，只能类执行。id返回值类型，表示任意类型的对象，即创建好的对象。（2）初始化：- (id)init; -表示这个方法属于对象，只能对象执行。id返回值类型,表示初始化完成的对象。</li>
<li>类的初始化调用了父类的init方法，如果使用默认初始化方法进行初始化（没有参数），内存分配和初始化可以简写成[Person new]。</li>
<li>由于OC不支持垃圾回收，因此当不再使用某个对象时，需要调用对象的release方法释放此对象。我们在第11行销毁了p对象。这个release方法在这里调用一次即可，不要觉得多调用多几次，对象就会释放地干净一点，这样做会很危险，容易造成野指针错误。</li>
<li>前面我们调用了Person的alloc、init方法，但是你会发现Person.h中并没有声明这些方法，为什么能够调用呢？原因很简单，这些方法都是父类NSObject的，子类当然可以调用父类的方法。</li>
</ul>
<h2 id="简单的内存分析"><a href="#简单的内存分析" class="headerlink" title="简单的内存分析"></a>简单的内存分析</h2><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>类本身也是一个对象，在OC中被定义为一个结构体，该结构体包含以下内容：</p>
<ol>
<li><code>Class isa</code>：isa指针指向类的元类，元类中存放着类的类方法列表（即这张表中存放着类中所有的类方法名，而方法名也就是方法的地址），[NSObject alloc]当给类发送这样消息时，runtime会根据类的isa指针找到类的元类，从元类及元类父类的类方法列表中找到alloc方法并执行。因为OC的类的本身也是一个对象，为了处理这个关系runtime就创造了元类，每个类都有对应的元类，每个元类也有父类（其实就是类的父类的元类），最终所有的元类会分别通过自己的isa指向NSObject的元类。</li>
<li><code>Class super_class</code>：super_class指针指向了类的父类。</li>
<li><code>const char *name</code>：本类的类名。</li>
<li><code>long version</code>：类的版本信息，默认为0。</li>
<li><code>long info</code>：类信息，供运行期使用的一些位标识。</li>
<li><code>long instance_size</code>：该类的成员变量大小。</li>
<li><code>struct objc_ivar_list *ivars</code>：该类的成员变量列表（只是列表，成员变量本身并不存在于类中而是存在于对象中）。</li>
<li><code>struct objc_method_list **methodLists</code>：类的对象的方法列表（其实这是一个指向结构体指针的指针，最终访问到的结构体中存放着该类的所有对象方法名，而方法名也就是方法的地址）。</li>
<li><code>struct objc_cache *cache</code>：方法缓存，对象接到一个消息会根据isa指针在本类及父类的methodLists中遍历，如果找到便会cache，再次调用同样的方法时就能够提高调用的效率。</li>
<li><code>struct objc_protocol_list *protocols</code>：协议列表。</li>
</ol>
<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>每个对象都有相同的结构，如下图所示：</p>
<p><img src="http://images2015.cnblogs.com/blog/776348/201608/776348-20160821112158573-327676209.png" alt=""></p>
<p>从上到下依次是：</p>
<ol>
<li>ISA指针.</li>
<li>根类的实例变量（根类就是NSobject，它的superclass指针指向nil）。</li>
<li>倒数第二层父类的实例变量。</li>
<li>….</li>
<li>父类的实例变量。</li>
<li>类的实例变量</li>
</ol>
<p>可以看出，在对象中有一个isa指针指向了本类，并且对象包含了本类及所有父类的成员变量。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>类既然称为对象，那它也是一个实例。类对象中也有一个isa指针指向它的元类（meta class），即类对象是元类的实例。元类内部存放的是类方法列表，根元类的isa指针指向自己，superclass指针指向NSObject类。如下图所示：</p>
<p><img src="http://images2015.cnblogs.com/blog/776348/201608/776348-20160821112258558-1102035295.png" alt=""></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.cnblogs.com/mjios/" target="_blank" rel="external">M了个J的博客</a></p>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[【01】第一个OC程序解析]]></title>
      <url>http://sanfordy.com/2016/08/22/%E3%80%96A%E3%80%97%E3%80%902-0%E3%80%91OC-%E8%AF%AD%E6%B3%95/%E3%80%9001%E3%80%91%E7%AC%AC%E4%B8%80%E4%B8%AAOC%E7%A8%8B%E5%BA%8F%E8%A7%A3%E6%9E%90/</url>
      <content type="html"><![CDATA[<blockquote>
<p>NSLog是标准输出函数，类似于C语言中的printf()函数，但是它会自动换行，当然它同样支持格式输出（例如%i表示输出整形数据，%f输出浮点型数据），这个函数在Fundation.h中声明。</p>
</blockquote>
<a id="more"></a>
<h2 id="创建程序"><a href="#创建程序" class="headerlink" title="创建程序"></a>创建程序</h2><ol>
<li>打开Xcode，创建一个新项目<br><img src="http://images2015.cnblogs.com/blog/776348/201608/776348-20160821102959933-926120850.png" alt=""></li>
<li>选择命令行程序<br><img src="http://images2015.cnblogs.com/blog/776348/201608/776348-20160821103006386-344731754.png" alt=""></li>
<li>选择程序语言为Ojbective-C并输入项目名称<br><img src="http://images2015.cnblogs.com/blog/776348/201608/776348-20160821103024120-2107595196.png" alt=""></li>
<li>选择保存目录<br><img src="http://images2015.cnblogs.com/blog/776348/201608/776348-20160821103032855-631290928.png" alt=""></li>
<li>默认生成一个基本的项目结构<br><img src="http://images2015.cnblogs.com/blog/776348/201608/776348-20160821103045620-1717099193.png" alt=""></li>
<li>上面是通过Xcode创建的第一个OC程序，这是一个经典的“Hello,World！”。运行结果如下：<br><img src="http://images2015.cnblogs.com/blog/776348/201608/776348-20160821103053870-1257989906.png" alt=""></li>
</ol>
<h2 id="解析程序"><a href="#解析程序" class="headerlink" title="解析程序"></a>解析程序</h2><p>程序源代码：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// insert code here...</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Hello, World!"</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="import"><a href="#import" class="headerlink" title="#import"></a>#import</h3><p>#import是一个预处理指令，作用跟C语言的#include类似，都是包含（拷贝）某个文件的内容到预处理指令所在的位置。</p>
<p>在C\C++中，我们用#include来包含头文件，缺点就是同一个头文件可能被包含多次。为了解决这个问题，一般会这样写头文件：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _TEST_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _TEST_H_</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*.....*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>我们在OC中，就使用#import来包含头文件，优点是可以自动防止同一个头文件被包含多次（即使文件被多次包含，也只拷贝一份）。</li>
</ul>
<p>与#include类似，导入系统类库使用&lt;…&gt;，导入自定义类库使用”…”。<code>#import &lt;Foundation/Foundation.h&gt;</code>表示包含Foundation框架中的Foundation.h文件到当前位置。Foundation框架中包含了很多常用的类和函数，比如字符串处理类NSString、日志输出函数NSLog。Foundation.h是Foundation框架中的头文件，这是OC中的一个基础类库，基本上后面我们用到的所有OC的代码都需要引入这个类库。.h称为头文件，一般用来声明一些函数，想要使用这些函数，就必须用#import包含函数所在的头文件。我们在第9行中使用的NSLog函数存在于Foundation.h文件中，因此要先包含Foundation.h文件才能使用NSLog函数。</p>
<h3 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h3><p>跟C程序一样，OC程序的入口点依然是main函数。在main.m的第3行已定义了一个main函数。</p>
<h3 id="autoreleasepool"><a href="#autoreleasepool" class="headerlink" title="@autoreleasepool"></a>@autoreleasepool</h3><p>@autoreleasepool是OC的关键字，它的作用是对包含在这个关键字后面大包括内的程序会自动进行内存回收，不需要开发人员手动释放无用的对象；当然表面上看起来这有点类似于C#和Java的内存垃圾回收机制，但是事实上他们的原理完全不同，以后再做具体解释。你只需要记住：以后的OC代码都写在@autoreleasepool的{}内部。</p>
<h3 id="NSLog"><a href="#NSLog" class="headerlink" title="NSLog"></a>NSLog</h3><p>NSLog是标准输出函数，类似于C语言中的printf()函数，但是它会自动换行，当然它同样支持格式输出（例如%i表示输出整形数据，%f输出浮点型数据），这个函数在Fundation.h中声明。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.cnblogs.com/mjios/" target="_blank" rel="external">M了个J的博客</a></p>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[【00】Objective-C简介]]></title>
      <url>http://sanfordy.com/2016/08/22/%E3%80%96A%E3%80%97%E3%80%902-0%E3%80%91OC-%E8%AF%AD%E6%B3%95/%E3%80%9000%E3%80%91Objective-C%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[<blockquote>
<p>目前来说，Objective-C(简称OC)是iOS开发的核心语言，在开发过程中也会配合着使用C语言、C++，OC主要负责UI界面，C语言、C++可用于图形处理。 </p>
</blockquote>
<a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>目前来说，Objective-C(简称OC)是iOS开发的核心语言，在开发过程中也会配合着使用C语言、C++，OC主要负责UI界面，C语言、C++可用于图形处理。</p>
<h2 id="OC简介"><a href="#OC简介" class="headerlink" title="OC简介"></a>OC简介</h2><h3 id="基于C语言"><a href="#基于C语言" class="headerlink" title="基于C语言"></a>基于C语言</h3><p>C语言是一门面向过程的语言，OC是在C语言的基础上，增加了一层最小的面向对象语法，为什么说是最小的面向对象语法呢？因为OC把一些比较复杂的面向对象语法都去掉了，剩下的都是面向对象的精华，因此OC是一门面向对象的语言，而且会比C++简单很多。因为OC是基于C语言的，所以完全兼容C语言，也就是说我们在开发iOS程序过程中，可以在OC代码中混入C语言代码，甚至是C++代码。</p>
<h3 id="OC的特点"><a href="#OC的特点" class="headerlink" title="OC的特点"></a>OC的特点</h3><ol>
<li>C语言的超集，允许在OC中使用C语言代码或C++代码，编译器兼容C、C++。</li>
<li>具备完善的面向对象特性。<ul>
<li>面向对象的三大特性：封装、继承和多态。</li>
<li>面向对象的核心：类和对象。</li>
</ul>
</li>
<li>包含一个运行时系统。</li>
<li>类库丰富。</li>
</ol>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>我们可以使用OC开发Mac OS X平台和iOS平台的应用程序。</p>
<p>这里简单说明一下Mac OS X和iOS：</p>
<ol>
<li>Mac OS X是苹果公司为Mac系列产品开发的专属操作系统，目前搭载这款操作系统的设备有：MacBook、iMac、Mac mini。</li>
<li>iOS是由苹果公司开发的手持设备操作系统，目前搭载这款操作系统的设备有：iPhone、iPad、iPod touch、iPad mini。</li>
</ol>
<h3 id="拓展名"><a href="#拓展名" class="headerlink" title="拓展名"></a>拓展名</h3><p>c语言-&gt;.c ，OC语言-&gt;.m  ，兼容C++-&gt;.cpp。</p>
<h2 id="OC语法预览"><a href="#OC语法预览" class="headerlink" title="OC语法预览"></a>OC语法预览</h2><h3 id="没有包名的概念"><a href="#没有包名的概念" class="headerlink" title="没有包名的概念"></a>没有包名的概念</h3><p>在Java中，为了防止两个类名相同的类冲突，你可以将这2个类放在不同的包里面。OC中并没有”包”的概念，取而代之的是开发人员给类名加上前缀，使用前缀可以有效的防止类名冲突。比如NSString（OC中的字符串类）、NSArray（OC的数组类），它们的前缀都是NS。</p>
<blockquote>
<p><strong>说明</strong>：NS其实是NeXTSTEP缩写，是乔布斯离开苹果后在NeXT公司所开发的系统，这个操作系统在当时虽然没有获得广泛认同，但是却为后面Mac OX奠定了基础。</p>
</blockquote>
<h3 id="关键字以-开头"><a href="#关键字以-开头" class="headerlink" title="关键字以@开头"></a>关键字以@开头</h3><p>我在前面说到，OC代码中是可以混入C语言、C++代码的，而C语言和C++作为一门编程语言，都有自己的关键字。为了防止跟C语言、C++关键字冲突，OC基本上所有的关键字都是以@开头的，少部分没有以@开头，如id，_cmd等。下面列举一些常见的关键字，看一眼就行了：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span>，@<span class="title">implementation</span>，@<span class="title">end</span></span></span><br><span class="line"><span class="keyword">@public</span>、<span class="keyword">@protected</span>、<span class="keyword">@private</span>，<span class="keyword">@selector</span></span><br><span class="line"><span class="keyword">@try</span>、<span class="keyword">@catch</span>、<span class="keyword">@throw</span>、<span class="keyword">@finally</span> </span><br><span class="line"><span class="class"><span class="keyword">@protocol</span>，@<span class="title">class</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// OC 2.0中引入的新关键字有</span></span><br><span class="line"><span class="keyword">@property</span>，<span class="keyword">@synthesize</span></span><br><span class="line"><span class="keyword">@optional</span>，<span class="keyword">@required</span>，<span class="keyword">@dynamic</span></span><br></pre></td></tr></table></figure>
<h3 id="字符串以-开头"><a href="#字符串以-开头" class="headerlink" title="字符串以@开头"></a>字符串以@开头</h3><p>为了与C语言中的字符串做区别，OC中的字符串也必须加上@，比如@”Hello”是OC中的字符串，而”Hello”则是C语言中的字符串。</p>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>在OC中的数据类型除了C语言中的char、int、float、double之外还有：</p>
<ol>
<li>BOOL类型，包含两个值YES和NO，其实OC中的布尔类型就是整数1和</li>
<li>id类型，是一个对象类型，可以表示所有对象。</li>
<li>NSString是Fundation框架中定义的字符串类型。</li>
</ol>
<p>关于上面id类型在这里不做过多的解释，后面我们会专门说到，下面列出常用格式符：</p>
<p><img src="http://images2015.cnblogs.com/blog/776348/201608/776348-20160821101932667-1485118536.png" alt=""></p>
<ul>
<li>%i与%d的区别：在C或者OC中整形可以使用%i也可以使用%d来格式化，只有使用scanf()输入的时候二者才有区别（由于%d始终被编译器解释为decimal intergeer所以即使输入010会被认为是整形10，而%i则会将前面的0或者0x认为此输入是八进制或十六进制整数）。</li>
<li>%p与%x的区别：%p本质就是输出指针地址，在32位编译器下对于一个指针类型使用%x输出和%p输出其实是一样的，只是后者会在前面加上“ox”用以区别该数是16进制（注意在64位编译器下由于指针长度8byte，而整形只有4byte所以%x输出的内容只是%p的低位数据）。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.cnblogs.com/mjios/" target="_blank" rel="external">M了个J的博客</a></p>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[【28】动态内存分配]]></title>
      <url>http://sanfordy.com/2016/08/21/%E3%80%96A%E3%80%97%E3%80%901-0%E3%80%91C-%E8%AF%AD%E6%B3%95/%E3%80%9028%E3%80%91%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</url>
      <content type="html"><![CDATA[<blockquote>
<p>暂无摘要。</p>
</blockquote>
<a id="more"></a>
<h2 id="内存区划分"><a href="#内存区划分" class="headerlink" title="内存区划分"></a>内存区划分</h2><p>内存区按内存地址从大到小可以划分为以下几部分：</p>
<ol>
<li>栈区：由编译器自动分配、释放，存放函数的参数值、局部变量的值等。eg：int a = 3;</li>
<li>堆区：由程序员自己管理，如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。eg：malloc(255);</li>
<li>静态区：全局变量和静态变量被分配在这里。eg：static float h = 1.36;</li>
<li>常量区：这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改。eg：”songshuhao”</li>
<li>代码区：void func(){…};</li>
</ol>
<h2 id="栈区"><a href="#栈区" class="headerlink" title="栈区"></a>栈区</h2><p>栈内存的错误使用：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">char</span> *<span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//  注意此处是把常量区的字符串“iphone”拷贝到栈内存中。 </span></span><br><span class="line">  <span class="keyword">char</span> <span class="built_in">string</span>[] = “iphone”;</span><br><span class="line">  <span class="comment">//  栈内存返回是不安全的，禁止!!</span></span><br><span class="line">  return <span class="built_in">string</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="堆区"><a href="#堆区" class="headerlink" title="堆区"></a>堆区</h2><p>malloc 等内存分配函数分配的内存，手动分配，手动释放。</p>
<h2 id="静态区"><a href="#静态区" class="headerlink" title="静态区"></a>静态区</h2><p>在局部变量定义的类型前加static，则该变量存储在静态区。静态区有以下几个特点</p>
<ol>
<li>只初始化一次。</li>
<li>如果初始没给值，默认为0。</li>
<li>只有程序退出才释放（否则永远存在）。</li>
</ol>
<h2 id="常量区"><a href="#常量区" class="headerlink" title="常量区"></a>常量区</h2><ol>
<li>字符常量：”a”</li>
<li>整形常量：5</li>
<li>字符串常量：”iPhone”</li>
</ol>
<h2 id="代码区"><a href="#代码区" class="headerlink" title="代码区"></a>代码区</h2><p>所有的语句编译后会生成CPU指令存储在代码区。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.cnblogs.com/mjios/" target="_blank" rel="external">M了个J的博客</a></p>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[【27】typedef]]></title>
      <url>http://sanfordy.com/2016/08/21/%E3%80%96A%E3%80%97%E3%80%901-0%E3%80%91C-%E8%AF%AD%E6%B3%95/%E3%80%9027%E3%80%91typedef/</url>
      <content type="html"><![CDATA[<blockquote>
<p>我们可以使用typedef关键字为各种数据类型定义一个新名字（别名）</p>
</blockquote>
<a id="more"></a>
<h2 id="typedef的作用简介"><a href="#typedef的作用简介" class="headerlink" title="typedef的作用简介"></a>typedef的作用简介</h2><p>我们可以使用typedef关键字为各种数据类型定义一个新名字（别名）：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">int</span> Integer;</span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> UInterger;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">float</span> Float;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">     Integer i = <span class="number">-10</span>;</span><br><span class="line">     UInterger ui = <span class="number">11</span>;</span><br><span class="line">    </span><br><span class="line">    Float f = <span class="number">12.39f</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d  %d  %.2f\n"</span>, i, ui, f);</span><br><span class="line">    </span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-10  11  12.39</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>在第3、第4、第6行分别给int、unsigned int、float起了个别名，然后在main函数中使用别名定义变量，用来跟原来的基本类型是完全一样的。</li>
<li>当然，给类型起别名后，原来的int、float还是可以正常使用的。</li>
</ul>
<p>也可以在别名的基础上再起一个别名：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Integer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> Integer MyInteger;</span><br></pre></td></tr></table></figure>
<h2 id="typedef与指针"><a href="#typedef与指针" class="headerlink" title="typedef与指针"></a>typedef与指针</h2><p>除开可以给基本数据类型起别名，typedef也可以给指针起别名：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *String;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">//  相当于char *str = "This is a string!";</span></span><br><span class="line">     String str = <span class="string">"This is a string!"</span>;</span><br><span class="line"></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, str);</span><br><span class="line"></span><br><span class="line">     return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">This is a string!</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>在第3给指针类型char *起别名为String，然后在第7行使用String定义了一个字符串。</li>
</ul>
<h2 id="typedef于结构体"><a href="#typedef于结构体" class="headerlink" title="typedef于结构体"></a>typedef于结构体</h2><p>给结构体起别名可以使代码更加简洁明：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个结构体类型</span></span><br><span class="line"><span class="keyword">struct</span> MyPoint &#123;</span><br><span class="line">    <span class="keyword">float</span> x;</span><br><span class="line">    <span class="keyword">float</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 起别名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> MyPoint Point;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义结构体变量</span></span><br><span class="line">    Point p;</span><br><span class="line">    p.x = <span class="number">10.0f</span>;</span><br><span class="line">    p.y = <span class="number">20.0f</span>;</span><br><span class="line">    </span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>我们在第8行给结构体MyPoint起了个别名叫做Point，然后在12行使用Point定义了一个结构体变量p，不用再带上struct关键字了。</li>
<li>其实在上面第1~第8行的代码可以简写为：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个结构体，顺便起别名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> MyPoint &#123;</span><br><span class="line">    <span class="keyword">float</span> x;</span><br><span class="line">    <span class="keyword">float</span> y;</span><br><span class="line">&#125; Point;</span><br></pre></td></tr></table></figure>
<ul>
<li>甚至可以省略结构体名称：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="keyword">float</span> x;</span><br><span class="line">    <span class="keyword">float</span> y;</span><br><span class="line">&#125; Point;</span><br></pre></td></tr></table></figure>
<h2 id="typedef与指向结构体的指针"><a href="#typedef与指向结构体的指针" class="headerlink" title="typedef与指向结构体的指针"></a>typedef与指向结构体的指针</h2><p>typedef可以给指针、结构体起别名，当然也可以给指向结构体的指针起别名：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个结构体并起别名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="keyword">float</span> x;</span><br><span class="line">    <span class="keyword">float</span> y;</span><br><span class="line">&#125; Point;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 起别名</span></span><br><span class="line"><span class="keyword">typedef</span> Point *PP;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义结构体变量</span></span><br><span class="line">    Point point = &#123;<span class="number">10</span>, <span class="number">20</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 定义指针变量</span></span><br><span class="line">    PP p = &amp;point;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 利用指针变量访问结构体成员</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"x=%f，y=%f\n"</span>, p-&gt;x, p-&gt;y);</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x=10.000000，y=20.000000</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>在第4行定义了一个结构体，顺便起了个别名叫Point，第10行为指向结构体的指针定义了别名PP。然后在main函数中使用这2个别名。</li>
</ul>
<h2 id="typedef与枚举类型"><a href="#typedef与枚举类型" class="headerlink" title="typedef与枚举类型"></a>typedef与枚举类型</h2><p>使用typedef给枚举类型起别名也可以使代码简洁。</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义枚举类型</span></span><br><span class="line"><span class="keyword">enum</span> Season &#123;spring, summer, autumn, winter&#125;;</span><br><span class="line"><span class="comment">// 给枚举类型起别名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> Season Season;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义枚举变量</span></span><br><span class="line">    Season s = spring;</span><br><span class="line">    </span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>在第2行定义了枚举类型，在第4行起了别名为Season，然后在第8行直接使用别名定义枚举变量，不用再带上enum关键字了。</li>
<li>上面的第1行~第4行代码可以简化为：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义枚举类型，并且起别名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> Season &#123;spring, summer, autumn, winter&#125; Season;</span><br></pre></td></tr></table></figure>
<ul>
<li>甚至可以省略枚举名称，简化为：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;spring, summer, autumn, winter&#125; Season;</span><br></pre></td></tr></table></figure>
<h2 id="typedef与指向函数的指针"><a href="#typedef与指向函数的指针" class="headerlink" title="typedef与指向函数的指针"></a>typedef与指向函数的指针</h2><p>先来回顾下函数指针的知识：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个sum函数，计算a跟b的和</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = a + b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d + %d = %d\n"</span>, a, b, c);</span><br><span class="line">    return c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">//  定义一个指向sum函数的指针变量p</span></span><br><span class="line">    <span class="keyword">int</span> (*p)(<span class="keyword">int</span>, <span class="keyword">int</span>) = sum;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  调用了p指向的sum函数</span></span><br><span class="line">    (*p)(<span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">    </span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4 + 5 = 9</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>在第4行定义了一个sum函数，第12行定义了一个指向sum函数的指针变量p，可以发现，这个指针变量p的定义比一般的指针变量看来复杂多了，不利于理解。</li>
</ul>
<p>为了简化代码和方便理解，我们可以使用typedef给指向函数的指针类型起别名：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个sum函数，计算a跟b的和</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = a + b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d + %d = %d\n"</span>, a, b, c);</span><br><span class="line">    return c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*MySum)</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个指向sum函数的指针变量p</span></span><br><span class="line">    MySum p = sum;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 利用指针变量p调用sum函数</span></span><br><span class="line">    (*p)(<span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">    </span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4 + 5 = 9</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>看第10行，意思是：给指向函数的指针类型，起了个别名叫MySum，被指向的函数接收2个int类型的参数，返回值为int类型。</li>
<li>在第14行直接用别名MySum定义一个指向sum函数的指针变量p，这样看起来简单舒服多了。第17行的函数调用是一样的。</li>
</ul>
<h2 id="typedef与-define"><a href="#typedef与-define" class="headerlink" title="typedef与#define"></a>typedef与#define</h2><p>先来看看下面的两段代码有什么区别（注意每一段的第1行代码）：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *String;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    String str = <span class="string">"This is a string!"</span>;</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> String char *</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    String str = <span class="string">"This is a string!"</span>;</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>上面的两段代码只是第1行代码不一样，运行的效果都是一样的：定义了一个字符串”This is a string!”。</li>
<li>但它们的实现方式是不一样的：第1段代码是用typedef给char *定义别名为String；第2段代码是用char *代替代码中的宏名String。</li>
<li>只看上面两段代码，似乎看不太出typedef和#define的区别。</li>
</ul>
<p>再来看一段代码：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  给char *起了个别名String1</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *String1;</span><br><span class="line"><span class="comment">//  定义了宏String2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> String2 char *</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String1 str1, str2;</span><br><span class="line">    String2 str3, str4;</span><br><span class="line">    </span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>在这种情况下，只有str1、str2、str3才是指向char类型的指针变量，str4只是个char类型的变量，因为宏定义纯粹是字符串替换，用char *代替String2，所以第9行代码相当于：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  下面的代码相当于：char * str3; char str4;</span></span><br><span class="line"><span class="keyword">char</span> * str3, str4;</span><br></pre></td></tr></table></figure>
<ul>
<li>可以看出，只有str4是基本数据类型，str1、str2、str3都是指针类型。所以，以后给类型起别名，最好使用typedef，而不是使用#define。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.cnblogs.com/mjios/" target="_blank" rel="external">M了个J的博客</a></p>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[【26】枚举]]></title>
      <url>http://sanfordy.com/2016/08/21/%E3%80%96A%E3%80%97%E3%80%901-0%E3%80%91C-%E8%AF%AD%E6%B3%95/%E3%80%9026%E3%80%91%E6%9E%9A%E4%B8%BE/</url>
      <content type="html"><![CDATA[<blockquote>
<p>枚举是C语言中的一种基本数据类型，并不是构造类型，它可以用于声明一组常数。当一个变量有几个固定的可能取值时，可以将这个变量定义为枚举类型。比如，你可以用一个枚举类型的变量来表示季节，因为季节只有4种可能的取值：春天、夏天、秋天、冬天。</p>
</blockquote>
<a id="more"></a>
<h2 id="枚举的概念"><a href="#枚举的概念" class="headerlink" title="枚举的概念"></a>枚举的概念</h2><p>枚举是C语言中的一种基本数据类型，并不是构造类型，它可以用于声明一组常数。当一个变量有几个固定的可能取值时，可以将这个变量定义为枚举类型。比如，你可以用一个枚举类型的变量来表示季节，因为季节只有4种可能的取值：春天、夏天、秋天、冬天。</p>
<p>目的：提高程序的可读性。</p>
<p>作用：将人能看懂的标识符与计算机能识别的数字建立对应关系。 </p>
<h2 id="枚举类型的定义"><a href="#枚举类型的定义" class="headerlink" title="枚举类型的定义"></a>枚举类型的定义</h2><p>一般形式为：enum 枚举名 {枚举元素1,枚举元素2,……};</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> season&#123;</span><br><span class="line">    spring = <span class="number">1</span>, <span class="comment">//默认从0开始</span></span><br><span class="line">    summer,</span><br><span class="line">    autumn,</span><br><span class="line">    winter</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="枚举变量的定义"><a href="#枚举变量的定义" class="headerlink" title="枚举变量的定义"></a>枚举变量的定义</h2><p>前面只是定义了枚举类型，接下来就可以利用定义好的枚举类型定义变量。</p>
<p>跟结构体一样，有3种方式定义枚举变量，下面三种方式定义的都是枚举变量s：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  先定义枚举类型，再定义枚举变量  //</span></span><br><span class="line"><span class="keyword">enum</span> Season &#123;spring, summer, autumn, winter&#125;;</span><br><span class="line"><span class="keyword">enum</span> Season s;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  定义枚举类型的同时定义枚举变量</span></span><br><span class="line"><span class="keyword">enum</span> Season &#123;spring, summer, autumn, winter&#125; s;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  省略枚举名称，直接定义枚举变量</span></span><br><span class="line"><span class="keyword">enum</span> &#123;spring, summer, autumn, winter&#125; s;</span><br></pre></td></tr></table></figure>
<h2 id="枚举使用的注意"><a href="#枚举使用的注意" class="headerlink" title="枚举使用的注意"></a>枚举使用的注意</h2><p>C语言编译器会将枚举元素（spring、summer等）作为整型常量处理，称为枚举常量。</p>
<p>枚举元素的值取决于定义时各枚举元素排列的先后顺序。默认情况下，第一个枚举元素的值为0，第二个为1，依次顺序加1：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Season &#123;spring, summer, autumn, winter&#125;;</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>也就是说spring的值为0，summer的值为1，autumn的值为2，winter的值为3。</li>
<li>也可以在定义枚举类型时改变枚举元素的值：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  没有指定值的枚举元素，其值为前一元素加1。也就说spring的值为0，summer的值为3，autumn的值为4，winter的值为5。</span></span><br><span class="line"><span class="keyword">enum</span> season &#123;spring, summer=<span class="number">3</span>, autumn, winter&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="枚举变量的基本操作"><a href="#枚举变量的基本操作" class="headerlink" title="枚举变量的基本操作"></a>枚举变量的基本操作</h2><h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><p>可以给枚举变量赋枚举常量或者整型值：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Season &#123;spring, summer, autumn, winter&#125; s;</span><br><span class="line"></span><br><span class="line">s = spring; <span class="comment">// 等价于 s = 0;</span></span><br><span class="line"></span><br><span class="line">s = <span class="number">3</span>; <span class="comment">// 等价于 s = winter;</span></span><br></pre></td></tr></table></figure>
<h3 id="遍历枚举元素"><a href="#遍历枚举元素" class="headerlink" title="遍历枚举元素"></a>遍历枚举元素</h3><p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Season &#123;spring, summer, autumn, winter&#125; s;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历枚举元素</span></span><br><span class="line"><span class="keyword">for</span> (s = spring; s &lt;= winter; s++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"枚举元素：%d \n"</span>, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">枚举元素：0 </span><br><span class="line">枚举元素：1 </span><br><span class="line">枚举元素：2 </span><br><span class="line">枚举元素：3 </span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.cnblogs.com/mjios/" target="_blank" rel="external">M了个J的博客</a></p>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[【25】结构体]]></title>
      <url>http://sanfordy.com/2016/08/21/%E3%80%96A%E3%80%97%E3%80%901-0%E3%80%91C-%E8%AF%AD%E6%B3%95/%E3%80%9025%E3%80%91%E7%BB%93%E6%9E%84%E4%BD%93/</url>
      <content type="html"><![CDATA[<blockquote>
<p>在前面已经介绍了C语言中的数组，用法跟其他语言差不多。当一个整体由多个数据构成时，我们可以用数组来表示这个整体，但是数组有个特点：内部的每一个元素都必须是相同类型的数据。</p>
<p>在实际应用中，我们通常需要由不同类型的数据来构成一个整体，比如学生这个整体可以由姓名、年龄、身高等数据构成，这些数据都具有不同的类型，姓名可以是字符串类型，年龄可以是整型，身高可以是浮点型。为此，C语言专门提供了一种构造类型来解决上述问题，这就是结构体，它允许内部的元素是不同类型的。</p>
</blockquote>
<a id="more"></a>
<h2 id="结构体的概念"><a href="#结构体的概念" class="headerlink" title="结构体的概念"></a>结构体的概念</h2><p>在前面已经介绍了C语言中的数组，用法跟其他语言差不多。当一个整体由多个数据构成时，我们可以用数组来表示这个整体，但是数组有个特点：内部的每一个元素都必须是相同类型的数据。</p>
<p>在实际应用中，我们通常需要由不同类型的数据来构成一个整体，比如学生这个整体可以由姓名、年龄、身高等数据构成，这些数据都具有不同的类型，姓名可以是字符串类型，年龄可以是整型，身高可以是浮点型。为此，C语言专门提供了一种构造类型来解决上述问题，这就是结构体，它允许内部的元素是不同类型的。</p>
<h2 id="结构体类型的定义"><a href="#结构体类型的定义" class="headerlink" title="结构体类型的定义"></a>结构体类型的定义</h2><h3 id="定义形式"><a href="#定义形式" class="headerlink" title="定义形式"></a>定义形式</h3><p>结构体内部的元素，也就是组成成分，我们一般称为”成员”。</p>
<p>结构体类型的一般定义形式为：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span>　结构体名&#123;</span><br><span class="line">    </span><br><span class="line">    类型名<span class="number">1</span>　成员名<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    类型名<span class="number">2</span>　成员名<span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    ……</span><br><span class="line">    </span><br><span class="line">    类型名n　成员名n;　　　</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>struct是关键字，是结构体类型的标志。</li>
</ul>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>比如，我们定义一个学生的结构体类型：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Student &#123;</span><br><span class="line">    <span class="keyword">char</span> *name; <span class="comment">// 姓名</span></span><br><span class="line">    <span class="keyword">int</span> age; <span class="comment">// 年龄</span></span><br><span class="line">    <span class="keyword">float</span> height; <span class="comment">// 身高</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>上面定义了一个叫做Student的结构体类型，共有name、age、height3个成员。看到这里是否有点面向对象的味道呢，其实这跟面向对象完全是两码事，只能说感觉有点像。</li>
</ul>
<h2 id="结构体变量的初始化"><a href="#结构体变量的初始化" class="headerlink" title="结构体变量的初始化"></a>结构体变量的初始化</h2><p>前面只是定义了名字为Student的结构体类型，并非定义了一个结构体变量，就像int一样，只是一种类型。</p>
<h3 id="整体初始化"><a href="#整体初始化" class="headerlink" title="整体初始化"></a>整体初始化</h3><p>先定义结构体类型，再定义结构体变量，同时<code>整体</code>初始化结构体变量：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Student &#123;</span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//  注意：struct和Student是连着使用的。</span></span><br><span class="line"><span class="keyword">struct</span> Student stu = &#123;<span class="string">"小明"</span>,<span class="number">18</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>结构体变量名为stu。</li>
</ul>
<p>定义结构体类型的同时定义结构体变量，同时<code>整体</code>初始化结构体变量：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Student &#123;</span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125; stu = &#123;<span class="string">"小明"</span>,<span class="number">18</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>结构体变量名为stu。</li>
</ul>
<p>省略类型名，直接定义结构体变量，同时<code>整体</code>初始化结构体变量：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125; stu = &#123;<span class="string">"小明"</span>,<span class="number">18</span>&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>结构体变量名为stu。</li>
</ul>
<p>结构体变量在<code>整体初始化</code>时，不能先定义变量再拿变量来整体初始化：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  这种写法是错误的</span></span><br><span class="line">stu = &#123;<span class="string">"小明"</span>,<span class="number">18</span>&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="成员单独初始化"><a href="#成员单独初始化" class="headerlink" title="成员单独初始化"></a>成员单独初始化</h3><p>成员单独初始化时需要先拿到定义好的结构体变量（我们在（1.整体初始化）中已经学会了怎么定义结构体变量）：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stu.name = <span class="string">"小明"</span>;</span><br><span class="line">stu.age = <span class="number">18</span>;</span><br></pre></td></tr></table></figure>
<h2 id="结构体的注意点"><a href="#结构体的注意点" class="headerlink" title="结构体的注意点"></a>结构体的注意点</h2><h3 id="不允许对结构体本身递归定义"><a href="#不允许对结构体本身递归定义" class="headerlink" title="不允许对结构体本身递归定义"></a>不允许对结构体本身递归定义</h3><p>如下做法是错误的，注意第3行：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Student &#123;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">struct</span> Student stu;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="结构体内可以包含别的结构体"><a href="#结构体内可以包含别的结构体" class="headerlink" title="结构体内可以包含别的结构体"></a>结构体内可以包含别的结构体</h3><p>&lt; 代码示例 &gt;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Date &#123;</span><br><span class="line">    <span class="keyword">int</span> year;</span><br><span class="line">    <span class="keyword">int</span> month;</span><br><span class="line">    <span class="keyword">int</span> day;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Student &#123;</span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="comment">//  包含了其他结构体</span></span><br><span class="line">    <span class="keyword">struct</span> Date birthday;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="内存问题一"><a href="#内存问题一" class="headerlink" title="内存问题一"></a>内存问题一</h3><p>定义结构体类型，只是说明了该类型的组成情况，并没有给它分配存储空间，就像系统不为int类型本身分配空间一样。只有当定义属于结构体类型的变量时，系统才会分配存储空间给该变量：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Student &#123;</span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Student stu;</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>第1~4行并没有分配存储空间，当执行到第6行时，系统才会分配存储空间给stu变量。</li>
</ul>
<h3 id="内存问题二"><a href="#内存问题二" class="headerlink" title="内存问题二"></a>内存问题二</h3><p>结构体变量占用的内存的大小是其成员所占内存之和，用成员中类型所占的最大内存为分配单位，按结构体成员声明顺序⾃上而下分配，分配空间不足以存储成员时，分配新的单位：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">struct</span> A &#123;</span><br><span class="line">　　<span class="keyword">int</span> a,</span><br><span class="line">　　<span class="keyword">float</span> b,</span><br><span class="line">　　<span class="keyword">char</span> [<span class="number">10</span>],</span><br><span class="line">　　<span class="keyword">double</span> d</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>因为其中占内存最大的类型是double所以分配空间时以8个字节为一个单位分配空间。总共占：8*1+0*1+8*2+8=32个字节。</li>
</ul>
<h2 id="结构体的使用"><a href="#结构体的使用" class="headerlink" title="结构体的使用"></a>结构体的使用</h2><p>一般对结构体变量的操作是以成员为单位进行的，引用的一般形式为：结构体变量名.成员名：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Student &#123;</span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Student stu;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问stu的age成员</span></span><br><span class="line">stu.age = <span class="number">27</span>;</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>第9行对结构体的age成员进行了赋值。”.”称为成员运算符，它在所有运算符中优先级最高。</li>
</ul>
<p>如果某个成员也是结构体变量，可以连续使用成员运算符”.”访问最低一级成员：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Date &#123;</span><br><span class="line">     <span class="keyword">int</span> year;</span><br><span class="line">     <span class="keyword">int</span> month;</span><br><span class="line">     <span class="keyword">int</span> day;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Student &#123;</span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">struct</span> Date birthday;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Student stu;</span><br><span class="line"></span><br><span class="line">stu.birthday.year = <span class="number">1986</span>;</span><br><span class="line">stu.birthday.month = <span class="number">9</span>;</span><br><span class="line">stu.birthday.day = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>注意第14行以后的代码。</li>
</ul>
<p>相同类型的结构体变量之间可以进行整体赋值：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Student &#123;</span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Student stu1 = &#123;<span class="string">"MJ"</span>, <span class="number">27</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  将stu1直接赋值给stu2</span></span><br><span class="line"><span class="keyword">struct</span> Student stu2 = stu1;</span><br><span class="line"></span><br><span class="line">printf(<span class="string">"age is %d\n"</span>, stu2.age);</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">age is 27</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<h2 id="结构体数组的初始化"><a href="#结构体数组的初始化" class="headerlink" title="结构体数组的初始化"></a>结构体数组的初始化</h2><p>结构体数组中存放的是结构体变量，结构体数组的初始化跟结构体变量差不多。</p>
<h3 id="整体初始化-1"><a href="#整体初始化-1" class="headerlink" title="整体初始化"></a>整体初始化</h3><p>先定义结构体类型，再定义结构体数组，同时整体初始化结构体数组：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Student &#123;</span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Student stu[<span class="number">2</span>] = &#123;&#123;<span class="string">"小明"</span>,<span class="number">18</span>&#125;,&#123;<span class="string">"小蛋"</span>,<span class="number">20</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>
<p>定义结构体类型的同时定义结构体数组，同时整体化结构体数组：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Student &#123;</span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;stu[<span class="number">2</span>] =&#123;&#123;<span class="string">"小明"</span>,<span class="number">18</span>&#125;,&#123;<span class="string">"小蛋"</span>,<span class="number">20</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>
<p>省略类型名，直接定义结构体数组，同时整体初始化结构体数组：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;stu[<span class="number">2</span>] =&#123;&#123;<span class="string">"小明"</span>,<span class="number">18</span>&#125;,&#123;<span class="string">"小蛋"</span>,<span class="number">20</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="成员单独初始化-1"><a href="#成员单独初始化-1" class="headerlink" title="成员单独初始化"></a>成员单独初始化</h3><p>成员单独初始化时需要先拿到定义好的结构体数组（我们在（1.整体初始化）中已经学会了怎么定义结构体数组）：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stu[<span class="number">1</span>].name = <span class="string">"小明"</span>;</span><br><span class="line">stu[<span class="number">1</span>].age = <span class="number">18</span>;</span><br></pre></td></tr></table></figure>
<p>用数组下标访问每一个结构体元素，跟普通数组的用法是一样的。但是不能直接给结构体元素整体赋值：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  stu[1]是stu数组中的第二个结构体变量，这样赋值是错误的</span></span><br><span class="line">stu[<span class="number">1</span>] = &#123;<span class="string">"小明"</span>,<span class="number">18</span>&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="结构体作为函数参数"><a href="#结构体作为函数参数" class="headerlink" title="结构体作为函数参数"></a>结构体作为函数参数</h2><p>将结构体变量作为函数参数进行传递时，其实传递的是全部成员的值，也就是将实参中成员的值一一赋值给对应的形参成员。因此，形参的改变不会影响到实参：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#include <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个结构体</span></span><br><span class="line"><span class="keyword">struct</span> Student &#123;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> test(<span class="keyword">struct</span> Student stu) &#123;</span><br><span class="line">    printf(<span class="string">"修改前的形参：%d \n"</span>, stu.age);</span><br><span class="line">    <span class="comment">// 修改实参中的age</span></span><br><span class="line">    stu.age = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    printf(<span class="string">"修改后的形参：%d \n"</span>, stu.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">struct</span> Student stu = &#123;<span class="number">30</span>&#125;;</span><br><span class="line">    printf(<span class="string">"修改前的实参：%d \n"</span>, stu.age);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用test函数</span></span><br><span class="line">    test(stu);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    printf(<span class="string">"修改后的实参：%d \n"</span>, stu.age);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">修改前的实参：30 </span><br><span class="line">修改前的形参：30 </span><br><span class="line">修改后的形参：10 </span><br><span class="line">修改后的实参：30 </span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>首先在第4行定义了一个结构体类型Student。</li>
<li>在第18行定义了一个结构体变量stu，并在第22行将其作为实参传入到test函数。</li>
<li>根据输出结果可知形参是改变了，但是实参一直没有变过。</li>
</ul>
<h2 id="结构体指针"><a href="#结构体指针" class="headerlink" title="结构体指针"></a>结构体指针</h2><p>结构体指针就是指向了结构体的指针，每个结构体变量都有自己的存储空间和地址，因此指针也可以指向结构体变量。</p>
<p>结构体指针变量的定义形式：struct 结构体名称 *指针变量名。</p>
<p>有了指向结构体的指针，那么就有3种访问结构体成员的方式。</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#include <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="comment">//  定义一个结构体类型：Student</span></span><br><span class="line">    <span class="keyword">struct</span> Student &#123;</span><br><span class="line">        <span class="keyword">char</span> *name;</span><br><span class="line">        <span class="keyword">int</span> age;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  定义一个结构体变量</span></span><br><span class="line">    <span class="keyword">struct</span> Student stu = &#123;<span class="string">"小明"</span>,<span class="number">18</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  定义一个指向结构体的指针变量，指向了stu</span></span><br><span class="line">    <span class="keyword">struct</span> Student *p = &amp;stu;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     *  这时候可以有三种方式访问结构体的成员</span><br><span class="line">     */</span></span><br><span class="line">    <span class="comment">//  方式1：结构体变量名.成员名</span></span><br><span class="line">    printf(<span class="string">"name = %s, age = %d \n"</span>,stu.name,stu.age);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  方式2：（*结构体变量名）.成员名</span></span><br><span class="line">    printf(<span class="string">"name = %s, age = %d \n"</span>,(*p).name,(*p).age);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  方式3：指针变量名-&gt;成员名</span></span><br><span class="line">    printf(<span class="string">"name = %s, age = %d \n"</span>,p-&gt;name,p-&gt;age);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">name = 小明, age = 18 </span><br><span class="line">name = 小明, age = 18 </span><br><span class="line">name = 小明, age = 18 </span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.cnblogs.com/mjios/" target="_blank" rel="external">M了个J的博客</a></p>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[【24】const关键字用法小结]]></title>
      <url>http://sanfordy.com/2016/08/21/%E3%80%96A%E3%80%97%E3%80%901-0%E3%80%91C-%E8%AF%AD%E6%B3%95/%E3%80%9024%E3%80%91const%E5%85%B3%E9%94%AE%E5%AD%97%E7%94%A8%E6%B3%95%E5%B0%8F%E7%BB%93/</url>
      <content type="html"><![CDATA[<blockquote>
<p>const修饰的数据类型是指常类型，常类型的变量或对象的值是不能被更新的。</p>
</blockquote>
<a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>const修饰的数据类型是指常类型，常类型的变量或对象的值是不能被更新的。</p>
<h2 id="const的普通用法"><a href="#const的普通用法" class="headerlink" title="const的普通用法"></a>const的普通用法</h2><p>&lt; 代码示例 &gt;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  n是一个只读变量，程序不可以直接修改其值。</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> n = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<h2 id="const用于指针"><a href="#const用于指针" class="headerlink" title="const用于指针"></a>const用于指针</h2><p>&lt; 代码示例 &gt;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p；<span class="comment">//　　常量指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> *p；<span class="comment">//　　常量指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> p；<span class="comment">//　　指针常量</span></span><br></pre></td></tr></table></figure>
<h2 id="const用于函数参数"><a href="#const用于函数参数" class="headerlink" title="const用于函数参数"></a>const用于函数参数</h2><p>&lt; 代码示例 &gt;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  该函数将不会通过参数p（指针）修改p所指的数据。</span></span><br><span class="line"><span class="keyword">void</span> foo(<span class="keyword">const</span> <span class="keyword">int</span> *p);</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.cnblogs.com/mjios/" target="_blank" rel="external">M了个J的博客</a></p>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[【23】extern和static关键字 -- 对变量的作用]]></title>
      <url>http://sanfordy.com/2016/08/20/%E3%80%96A%E3%80%97%E3%80%901-0%E3%80%91C-%E8%AF%AD%E6%B3%95/%E3%80%9023%E3%80%91extern%E5%92%8Cstatic%E5%85%B3%E9%94%AE%E5%AD%97%20--%20%E5%AF%B9%E5%8F%98%E9%87%8F%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
      <content type="html"><![CDATA[<blockquote>
<p>这里稍微说一下，其实就是变量定义和变量声明的区别，变量定义使用“数据类型+变量名称”的形式，编译器需要给他分配内存单元的。而变量声明使用“extern 变量类型+变量名称”的形式，是告诉编译器我这个变量将在其他外部c文件中定义，我这里只是在外部用它。编译器就不给他分配内存空间，而等到真正遇到变量定义的时候再给他分配内存空间。</p>
</blockquote>
<a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这里稍微说一下，其实就是变量定义和变量声明的区别，变量定义使用“数据类型+变量名称”的形式，编译器需要给他分配内存单元的。而变量声明使用“extern 变量类型+变量名称”的形式，是告诉编译器我这个变量将在其他外部c文件中定义，我这里只是在外部用它。编译器就不给他分配内存空间，而等到真正遇到变量定义的时候再给他分配内存空间。</p>
<h2 id="extern与变量"><a href="#extern与变量" class="headerlink" title="extern与变量"></a>extern与变量</h2><h3 id="全局变量定义的位置是有限制的"><a href="#全局变量定义的位置是有限制的" class="headerlink" title="全局变量定义的位置是有限制的"></a>全局变量定义的位置是有限制的</h3><p>extern可以用来声明一个全局变量，但是不能用来定义变量，在C语言中，全局变量定义的位置是有限制的：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#include <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a;</span><br></pre></td></tr></table></figure>
<p>&lt; ERROR &gt;</p>
<p><img src="http://images2015.cnblogs.com/blog/776348/201608/776348-20160823152939558-1361951111.png" alt=""></p>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>在第3行定义的main函数中尝试访问第8行定义的变量a，编译器直接报错了。</li>
</ul>
<p>解决这个上面代码错误的话，有2种办法：</p>
<p>&lt; 代码示例1 &gt;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#include <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//  将变量a定义在main函数的前面，这样做编译器就不会找你麻烦了。</span></span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 代码示例2 &gt;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#include <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//  在main函数前面对变量a进行提前声明，也就是让main函数知道变量a的存在就行了，至于变量a定义在哪个位置，main函数不用管。</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a;</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>变量声明不能省略extern关键字。</li>
<li>第3行是对变量a进行声明，第10行是定义变量a，再次强调，声明和定义是两码事。在第6行操作的就是第10行定义的变量a。</li>
<li>不能省略第10行的定义，只留下第3行的声明，因为extern是用来声明一个已经定义过的变量。</li>
</ul>
<h3 id="重复定义同一个变量"><a href="#重复定义同一个变量" class="headerlink" title="重复定义同一个变量"></a>重复定义同一个变量</h3><p>其实，你也可以直接在main函数前面再定义一次a：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#include <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a;</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>看到这一幕，你可能很惊讶，但编译器是不会报错的。在这种情况下，第3行和第10行的变量a代表着同一个变量。</li>
<li>以此类推，如果我们写了无数遍全局变量int a;，它们代表的都是同一个变量：</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#include <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> a;</span><br></pre></td></tr></table></figure>
<p>还要注意的一点是，我们也可以将全局变量a声明为局部变量后再使用：</p>
<p><img src="http://images2015.cnblogs.com/blog/776348/201608/776348-20160823160439526-2135612256.png" alt=""></p>
<ul>
<li>第11、第14、第15、第19行都代表着同一个变量。其实，从第15行a的颜色(浅绿色)都可以看出，这个a依然是个全局变量。</li>
<li>这是Xcode的特性，如果在函数内部访问了全局变量，全局变量就会显示浅绿色，如果函数内部访问的是局部变量，局部变量就显示普通的白色。当然，不同的开发工具有不同的显示方案。</li>
<li>但是，如果你将第14行的extern去掉，那情况就完全不一样了，相信有编程经验的你都懂得这是什么情况了：<br><img src="http://images2015.cnblogs.com/blog/776348/201608/776348-20160823160447417-160326584.png" alt=""></li>
</ul>
<h3 id="不同源文件中的同名变量"><a href="#不同源文件中的同名变量" class="headerlink" title="不同源文件中的同名变量"></a>不同源文件中的同名变量</h3><p>假如在不同的源文件中定义了相同的变量，那么Xcode编译器会报错：</p>
<p>&lt; 代码示例 &gt;</p>
<p><em>main.c</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#include <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>test.c</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#include <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a;</span><br></pre></td></tr></table></figure>
<p>&lt; ERROR &gt;</p>
<p><img src="http://images2015.cnblogs.com/blog/776348/201608/776348-20160823165309683-477236422.png" alt=""></p>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>报错是由于标识符重复引起的。</li>
</ul>
<p>当使用extern关键字时可以解决上面标识符重复的问题，并且这这两个源文件的所有全局变量a;都代表着同一个变量：</p>
<p>&lt; 代码示例 &gt;</p>
<p><em>main.c</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#include <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="comment">//  声明test函数</span></span><br><span class="line"><span class="keyword">void</span> test();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="comment">//  修改a的值</span></span><br><span class="line">    a = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//  调用test函数</span></span><br><span class="line">    test();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>test.c</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#include <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> a;</span><br><span class="line"><span class="comment">//  用来打印a的值</span></span><br><span class="line"><span class="keyword">void</span> test()&#123;</span><br><span class="line">    printf(<span class="string">"test.c中的a为：%d\n"</span>,a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test.c中的a为：10</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>根据输出结果可知，test.c和main.c中使用的全局变量a都还是代表着同一个变量。</li>
<li>当然也可以让main.c中变量a使用extern修饰，这时候test.c中的a就不能用extern修饰了。</li>
<li>不可以两个文件的所有全局变量a都用extern，因为extern是用来声明一个已经定义过的变量，这两个文件都是在声明变量，没有人定义变量，在链接的时候肯定报错：<br><img src="http://images2015.cnblogs.com/blog/776348/201608/776348-20160823172248573-104558019.png" alt=""><br>大致错误意思是：标示符a未定义</li>
</ul>
<h2 id="static与变量"><a href="#static与变量" class="headerlink" title="static与变量"></a>static与变量</h2><p>很多时候，我们并不想让源文件中的全局变量跟其他源文件共享，相当于私有的全局变量，那么你就得用static关键字来定义变量：</p>
<p>&lt; 代码示例 &gt;</p>
<p><em>main.c</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#include <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="comment">//  声明test函数</span></span><br><span class="line"><span class="keyword">void</span> test();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="comment">//  修改a的值</span></span><br><span class="line">    a = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//  调用test函数</span></span><br><span class="line">    test();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>test.c</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#include <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> a;</span><br><span class="line"><span class="comment">//  用来打印a的值</span></span><br><span class="line"><span class="keyword">void</span> test()&#123;</span><br><span class="line">    printf(<span class="string">"test.c中的a为：%d\n"</span>,a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test.c中的a为：0</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>这样写完，test.c和main.c的变量a分别代表着不同的变量，它们是没有联系的、互不干扰的。也就是说，main.c无法访问test.c中的变量a，因此在main.c中将a修改为10后，test.c中的a依然为0。</li>
</ul>
<p>因为main.c已经没有权限访问test.c中的变量a了，所以下面的写法是错误的：</p>
<p>&lt; 代码示例 &gt;</p>
<p><em>main.c</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#include <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line"></span><br><span class="line">    a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>test.c</em></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#include <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> a;</span><br></pre></td></tr></table></figure>
<p>&lt; ERROR &gt;</p>
<p><img src="http://images2015.cnblogs.com/blog/776348/201608/776348-20160823173204433-1099493774.png" alt=""></p>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>链接的时候报错的理由是标示符a未定义。</li>
<li>extern是用来声明已经定义过而且能够访问的变量，虽然test.c中有定义过变量a，但是test.c中变量a的作用域是只限于test.c文件，main.c没有访问权限，所以main.c中的extern是废的。</li>
<li>除非main.c自己定义一个变量a，这样子extern才是有效的，不过这时候main.c和test.c中的变量a是分别代表着不同变量。</li>
</ul>
<h2 id="extern、static与变量的总结"><a href="#extern、static与变量的总结" class="headerlink" title="extern、static与变量的总结"></a>extern、static与变量的总结</h2><h3 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h3><p>extern可以用来声明一个全局变量，但是不能用来定义变量。</p>
<h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p>如果在定义全局变量的时候加上static关键字，此时static的作用在于限制该全局变量的作用域，只能在定义该全局变量的文件中才能使用，跟其他源文件中的同名变量互不干扰。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.cnblogs.com/mjios/" target="_blank" rel="external">M了个J的博客</a></p>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[【22】extern和static关键字 -- 对函数的作用]]></title>
      <url>http://sanfordy.com/2016/08/20/%E3%80%96A%E3%80%97%E3%80%901-0%E3%80%91C-%E8%AF%AD%E6%B3%95/%E3%80%9022%E3%80%91extern%E5%92%8Cstatic%E5%85%B3%E9%94%AE%E5%AD%97%20--%20%E5%AF%B9%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
      <content type="html"><![CDATA[<blockquote>
<p>在定义函数时，如果在函数的最左边加上关键字extern，则表示此函数是外部函数，可供其他文件调用。C语言规定，如果在定义函数时省略extern，则隐含为外部函数。</p>
<p>在定义函数时，在函数的最左边加上static可以把该函数声明为内部函数(又叫静态函数)，这样该函数就只能在其定义所在的文件中使用。如果在不同的文件中有同名的内部函数，则互不干扰。</p>
</blockquote>
<a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>如果一个程序中有多个源文件（.c），编译成功会生成对应的多个目标文件（.obj），这些目标文件还不能单独运行，因为这些目标文件之间可能会有关联，比如a.obj可能会调用c.obj中定义的一个函数。将这些相关联的目标文件链接在一起后才能生成可执行文件。</p>
<p>在学习extern和static之前先来理解2个概念：</p>
<ol>
<li>外部函数：如果在当前文件中定义的函数允许其他文件访问、调用，就称为外部函数。<code>C语言规定，不允许有同名的外部函数</code>。</li>
<li>内部函数：如果在当前文件中定义的函数不允许其他文件访问、调用，只能在内部使用，就称为内部函数。<code>C语言规定不同的源文件可以有同名的内部函数，并且互不干扰</code>。</li>
</ol>
<h2 id="extern与函数"><a href="#extern与函数" class="headerlink" title="extern与函数"></a>extern与函数</h2><p>接下来演示两个错误和一个正确示例，即在源文件中调用另外一个源文件定义的函数，比如在main.c中调用one.c中定义的one函数。</p>
<h3 id="错误示例1"><a href="#错误示例1" class="headerlink" title="错误示例1"></a>错误示例1</h3><p>&lt; 代码示例 &gt;</p>
<p><em>main.c</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//  调用one.c中的one函数。</span></span><br><span class="line">    one();</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>one.c</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  如果你想让这个one函数可以被`main.c`访问，那么one函数就必须是外部函数。完整的定义是要加上extern关键字。extern跟auto关键字一样废，完全可以省略，因为默认情况下，所有的函数就是外部函数。</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">one</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"调用了one函数\n"</span>);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">调用了one函数</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li><code>main.c</code>：第6行代码虽然可以正常输出，但是在标准C编译器里面会报错的，但是在Xcode中只是个警告：<br><img src="http://images2015.cnblogs.com/blog/776348/201608/776348-20160820183820078-1577562353.png" alt=""></li>
</ul>
<h3 id="错误示例2"><a href="#错误示例2" class="headerlink" title="错误示例2"></a>错误示例2</h3><p>&lt; 代码示例 &gt;</p>
<p><em>main.c</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"one.c"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//  调用one.c中的one函数。</span></span><br><span class="line">    one();</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>one.c</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">one</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"调用了one函数\n"</span>);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; BuildFaild &gt;</p>
<p><img src="http://images2015.cnblogs.com/blog/776348/201608/776348-20160820185543625-1854041435.png" alt=""></p>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li><code>duplicate symbol _one</code>是说one这个标识符重复了。</li>
<li><code>linker</code>是指链接器</li>
<li>大家都知道#include的作用纯粹就是内容拷贝，所以<code>#include&quot;onc.c&quot;</code>又相当于：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">one</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"调用了one函数\n"</span>);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>哎，这么一看好像是对的，在main函数前面定义了个one函数，然后在main函数中调用了这个one函数。从语法上看是对的，所以编译是没问题的。但是这个程序不可能运行成功，因为在链接的时候会报错。我们已经在one.c中定义了one函数，现在又在main.c中定义one函数，C语言规定不允许有同名的外部函数，链接的时候链接器会发现在one.obj和main.obj中定义了同一个函数，会直接报错。</li>
</ul>
<h3 id="正确示例"><a href="#正确示例" class="headerlink" title="正确示例"></a>正确示例</h3><p>上面的2种想法都是不可行的，其实思路是一致的：让main函数知道one函数的存在。正确的做法应该是在main函数前面对one函数进行提前声明（看清楚，是声明，不是定义，定义和声明是两码事）。</p>
<p>你想要把其他源文件中定义的外部函数拿过来声明，完整的做法，应该使用extern关键字，表示引用别人的”外部函数”：</p>
<p>&lt; 代码示例 &gt;</p>
<p><em>main.c</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">one</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//  调用one.c中的one函数。</span></span><br><span class="line">    one();</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>one.c</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">one</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"调用了one函数\n"</span>);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">调用了one函数</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li><code>main.c</code>：上述就是extern关键字对函数的作用：用来定义和声明一个外部函数。其实extern又跟auto一样废，完全可以省略。于是，我们可以简化成这样：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  省去extern关键字</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">one</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//  调用one.c中的one函数。</span></span><br><span class="line">    one();</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了模块化地开发，在正规的项目里面，我们会把one函数的声明写到另一个头文件中，当然，这个头文件的命名最好有意义、规范一点，比如叫one.h。以后，谁想调用这个one函数，包含one.h这个头文件就行了。于是最后的代码结构是这样的：</p>
<p>&lt; 代码示例 &gt;</p>
<p><em>main.c</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"one.h"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//  one.c中的one函数。</span></span><br><span class="line">    one();</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>one.h</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> one_h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> one_h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">one</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><em>one.c</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"one.h"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">one</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"调用了one函数\n"</span>);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">调用了one函数</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<h2 id="static与函数"><a href="#static与函数" class="headerlink" title="static与函数"></a>static与函数</h2><h3 id="定义内部函数"><a href="#定义内部函数" class="headerlink" title="定义内部函数"></a>定义内部函数</h3><p>从上面的例子可以看出，one.c中定义的one函数是可以被其他源文件访问的。其实有时候，我们可能想定义一个”内部函数”，也就是不想让其他文件访问本文件中定义的函数。这个非常简单，你只需要在定义函数的时候加个<code>static</code>关键字即可：</p>
<p>&lt; 代码示例 &gt;</p>
<p><em>main.c</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"one.c"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//  调用one.c中的one函数。</span></span><br><span class="line">    one();</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>one.c</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  我在void one()的前面加了个static，代表one函数是个内部函数。</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">one</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"调用了one函数\n"</span>);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; BuildFaild &gt;</p>
<p><img src="http://images2015.cnblogs.com/blog/776348/201608/776348-20160823113846605-1032450553.png" alt=""></p>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>程序运行不起来，在链接的时候就报错了。报错的原因很简单：我们在main.c中调用了one.c中定义的one函数，但是现在one.c的one函数是个”内部函数”，不允许其他文件访问。第1个红框中的Undefined symbols…意思是one这个标识符没有被定义，也就是找不到one；第2个红框的linker表明是链接器报错了。</li>
<li>但这个程序是可以编译成功的，因为我们在main函数前面声明了one函（函数的声明和定义是两码事），这个函数声明可以理解为：在语法上，骗一下main函数，告诉它one函数是存在的，所以从语法的角度上main函数是可以调用one函数的。究竟这个one函数存不存在呢，有没有被定义呢？编译器是不管的。在编译阶段，编译器只会检测单个源文件的语法合不合理，并不检测函数有没有定义，只有在链接的时候才会检测这个函数存不存在，也就是有没有被定义。</li>
<li><code>所谓编译</code>，就是单独检查每个源文件的语法是否合理，并不会检查每个源文件之间的关联关系，一个源文件编译成功就生成一个目标文件。<code>所谓链接</code>，就是检查目标文件的关联关系，将相关联的目标文件组合在一起，生成可执行文件。</li>
</ul>
<h3 id="声明内部函数"><a href="#声明内部函数" class="headerlink" title="声明内部函数"></a>声明内部函数</h3><p>我们还可以用static声明一个内部函数：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#include <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> test();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span><br><span class="line">&#123;</span><br><span class="line">    test();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> test() &#123;</span><br><span class="line">    printf(<span class="string">"调用了test函数\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">调用了test函数</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>第11行定义了一个test函数，这是一个内部函数，接着在第3行对test函数进行提前声明，然后就可以在第7行可以调用test()函数了。</li>
</ul>
<h2 id="extern、static与函数的总结"><a href="#extern、static与函数的总结" class="headerlink" title="extern、static与函数的总结"></a>extern、static与函数的总结</h2><ol>
<li>extern<ul>
<li>在定义函数时，如果在函数的最左边加上关键字extern，则表示此函数是外部函数，可供其他文件调用。C语言规定，如果在定义函数时省略extern，则隐含为外部函数。</li>
<li>在一个文件中要调用其他文件中的外部函数，则需要在当前文件中用extern声明该外部函数，然后就可以使用，这里的extern也可以省略。</li>
</ul>
</li>
<li>static<ul>
<li>在定义函数时，在函数的最左边加上static可以把该函数声明为内部函数(又叫静态函数)，这样该函数就只能在其定义所在的文件中使用。如果在不同的文件中有同名的内部函数，则互不干扰。</li>
<li>static也可以用来声明一个内部函数。</li>
</ul>
</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.cnblogs.com/mjios/" target="_blank" rel="external">M了个J的博客</a></p>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[【21】预处理指令 -- 文件包含]]></title>
      <url>http://sanfordy.com/2016/08/20/%E3%80%96A%E3%80%97%E3%80%901-0%E3%80%91C-%E8%AF%AD%E6%B3%95/%E3%80%9021%E3%80%91%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4%20--%20%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/</url>
      <content type="html"><![CDATA[<blockquote>
<p>其实我们早就有接触文件包含这个指令了， 就是#include，它可以将一个文件的全部内容拷贝另一个文件中。</p>
</blockquote>
<a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>其实我们早就有接触文件包含这个指令了， 就是#include，它可以将一个文件的全部内容拷贝另一个文件中。</p>
<h2 id="一般形式"><a href="#一般形式" class="headerlink" title="一般形式"></a>一般形式</h2><h3 id="include-lt-文件名-gt"><a href="#include-lt-文件名-gt" class="headerlink" title="#include　&lt;文件名&gt;"></a>#include　&lt;文件名&gt;</h3><p>直接到C语言库函数头文件所在的目录中寻找文件。</p>
<h3 id="include-“文件名”"><a href="#include-“文件名”" class="headerlink" title="#include　“文件名”"></a>#include　“文件名”</h3><p>系统会先在源程序当前目录下寻找，若找不到，再到操作系统的path路径中查找，最后才到C语言库函数头文件所在目录中查找。</p>
<h2 id="使用注意"><a href="#使用注意" class="headerlink" title="使用注意"></a>使用注意</h2><h3 id="嵌套包含和递归包含"><a href="#嵌套包含和递归包含" class="headerlink" title="嵌套包含和递归包含"></a>嵌套包含和递归包含</h3><p>#include指令允许嵌套包含但是<code>不允许</code>递归包含：</p>
<ol>
<li>嵌套包含：比如a.h包含b.h，b.h包含c.h。</li>
<li>递归包含：比如 a.h 包含 b.h，b.h 包含 a.h，下面的做法是错误的：<br><img src="http://images2015.cnblogs.com/blog/776348/201608/776348-20160820145127343-2070603187.png" alt=""><br><img src="http://images2015.cnblogs.com/blog/776348/201608/776348-20160820145134640-1258787116.png" alt=""></li>
</ol>
<h3 id="重复包含"><a href="#重复包含" class="headerlink" title="重复包含"></a>重复包含</h3><p>使用#include指令可能导致多次包含同一个头文件，降低编译效率，比如下面的情况：</p>
<p><img src="http://images2015.cnblogs.com/blog/776348/201608/776348-20160820145139890-235930232.png" alt=""></p>
<p><img src="http://images2015.cnblogs.com/blog/776348/201608/776348-20160820145148062-173132178.png" alt=""></p>
<p>在one.h中声明了一个one函数；在two.h中包含了one.h，顺便声明了一个two函数。（这里就不写函数的实现了，也就是函数的定义）。</p>
<p>假如我想在main.c中使用one和two两个函数，而且有时候我们并不一定知道two.h中包含了one.h，所以可能会这样做：</p>
<p><img src="http://images2015.cnblogs.com/blog/776348/201608/776348-20160820145154750-1306087584.png" alt=""></p>
<p>编译预处理之后main.c的代码是这样的：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">one</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">one</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">two</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line"></span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>第1行是由#include “one.h”导致的，第2、3行是由#include “two.h”导致的(因为two.h里面包含了one.h)。可以看出来，one函数被声明了2遍，根本就没有必要，这样会降低编译效率。</li>
</ul>
<p>为了解决这种重复包含同一个头文件的问题，一般我们会这样写头文件内容： </p>
<p><img src="http://images2015.cnblogs.com/blog/776348/201608/776348-20160820145202281-1455136960.png" alt=""></p>
<p><img src="http://images2015.cnblogs.com/blog/776348/201608/776348-20160820145210000-705717918.png" alt=""></p>
<p>大致解释一下意思，就拿one.h为例：当我们第一次#include “one.h”时，因为没有定义_ONE<em>H</em>，所以第9行的条件成立，接着在第10行定义了_ONE<em>H</em>这个宏，然后在13行声明one函数，最后在15行结束条件编译。当第二次#include “one.h”，因为之前已经定义过_ONE<em>H</em>这个宏，所以第9行的条件不成立，直接跳到第15行的#endif，结束条件编译。就是这么简单的3句代码，防止了one.h的内容被重复包含。</p>
<p>这样子的话，main.c中的：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"one.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"two.h"</span></span></span><br></pre></td></tr></table></figure>
<p>就变成了：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// #include "one.h"</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _ONE_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _ONE_H_</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">one</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// #include "two.h"</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _TWO_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _TWO_H_</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// #include "one.h"</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _ONE_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _ONE_H_</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">one</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">two</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>第2~第7行是#include “one.h”导致的，第10~第23行是#include “two.h”导致的。编译预处理之后就变为了：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  这才是我们想要的结果。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">one</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">two</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.cnblogs.com/mjios/" target="_blank" rel="external">M了个J的博客</a></p>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[【20】预处理指令 -- 条件编译]]></title>
      <url>http://sanfordy.com/2016/08/20/%E3%80%96A%E3%80%97%E3%80%901-0%E3%80%91C-%E8%AF%AD%E6%B3%95/%E3%80%9020%E3%80%91%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4%20--%20%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91/</url>
      <content type="html"><![CDATA[<blockquote>
<p>在很多情况下，我们希望程序的其中一部分代码只有在满足一定条件时才进行编译，否则不参与编译（只有参与编译的代码最终才能被执行），条件编译其实就是在编译之前预处理器根据预处理指令判断对应的条件，如果条件满足就将对应的代码编译进去，否则代码就根本不进入编译环节（相当于根本就没有这段代码）。</p>
</blockquote>
<a id="more"></a>
<h2 id="条件编译的概念"><a href="#条件编译的概念" class="headerlink" title="条件编译的概念"></a>条件编译的概念</h2><p>在很多情况下，我们希望程序的其中一部分代码只有在满足一定条件时才进行编译，否则不参与编译（只有参与编译的代码最终才能被执行），条件编译其实就是在编译之前预处理器根据预处理指令判断对应的条件，如果条件满足就将对应的代码编译进去，否则代码就根本不进入编译环节（相当于根本就没有这段代码）。</p>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>&lt; 代码示例 &gt;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#if 条件1</span></span><br><span class="line"> ...code1...</span><br><span class="line"><span class="meta">#elif 条件2</span></span><br><span class="line"> ...code2...</span><br><span class="line"><span class="meta">#else</span></span><br><span class="line"> ...code3...</span><br><span class="line"><span class="meta">#endif</span></span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>如果条件1成立，那么编译器就会把#if 与 #elif之间的code1代码编译进去（注意：是编译进去，不是执行，跟平时用的if-else是不一样的）。</li>
<li>如果条件1不成立、条件2成立，那么编译器就会把#elif 与 #else之间的code2代码编译进去。</li>
<li>如果条件1、2都不成立，那么编译器就会把#else 与 #endif之间的code3编译进去。</li>
<li>注意，条件编译结束后，要在最后面加一个#endif，不然后果很严重。</li>
<li>#if 和 #elif后面的条件一般是判断宏定义而不是判断变量，因为条件编译是在编译之前做的判断，宏定义也是编译之前定义的，而变量是在运行时才产生的、才有使用的意义。</li>
</ul>
<h2 id="举个🌰"><a href="#举个🌰" class="headerlink" title="举个🌰"></a>举个🌰</h2><p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 11</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> MAX == 0</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"MAX是0\n"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> MAX &gt; 0</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"MAX大于0\n"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"MAX小于0\n"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MAX大于0</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>在第3行定义了一个宏MAX，当然在开发中这个MAX可能被定义在其他头文件中，现在只是为了方便演示，就写到main函数上面了。注意第7到第13行的条件编译语句。由于MAX为11，所以#elif的条件成立，第10行代码将会被编译进去，其实编译预处理后的代码是这样的：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*stdio.h文件中的内容将会代替#include &lt;stdio.h&gt;的位置*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"MAX大于0"</span>);</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="其他用法"><a href="#其他用法" class="headerlink" title="其他用法"></a>其他用法</h2><h3 id="if-defined-、-if-defined"><a href="#if-defined-、-if-defined" class="headerlink" title="#if defined()、#if !defined()"></a>#if defined()、#if !defined()</h3><p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(MAX)</span></span><br><span class="line">    ...code...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>如果前面已经定义过MAX这个宏，就将code编译进去。它不会管MAX的值是多少，只要定义过MAX，条件就成立。</li>
</ul>
<p>条件也可以取反：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(MAX)</span></span><br><span class="line">    ...code...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>如果前面没有定义过MAX这个宏，就将code编译进去。</li>
</ul>
<h3 id="ifdef、-ifndef"><a href="#ifdef、-ifndef" class="headerlink" title="#ifdef、#ifndef"></a>#ifdef、#ifndef</h3><p>#ifdef的使用和<code>#if defined()</code>的用法基本一致：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> MAX</span></span><br><span class="line">    ...code...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>如果前面已经定义过MAX这个宏，就将code编译进去。</li>
</ul>
<p>#ifndef又和<code>#if !defined()</code>的用法基本一致：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MAX</span></span><br><span class="line">    ...code...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>如果前面没有定义过MAX这个宏，就将code编译进去。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.cnblogs.com/mjios/" target="_blank" rel="external">M了个J的博客</a></p>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[【19】预处理指令 -- 宏定义]]></title>
      <url>http://sanfordy.com/2016/08/19/%E3%80%96A%E3%80%97%E3%80%901-0%E3%80%91C-%E8%AF%AD%E6%B3%95/%E3%80%9019%E3%80%91%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4%20--%20%E5%AE%8F%E5%AE%9A%E4%B9%89/</url>
      <content type="html"><![CDATA[<blockquote>
<p>C语言在对源程序进行编译之前，会先对一些特殊的预处理指令作解释（比如之前使用的#include文件包含指令），产生一个新的源程序（这个过程称为编译预处理），之后再进行通常的编译。</p>
</blockquote>
<a id="more"></a>
<h2 id="预处理指令简介"><a href="#预处理指令简介" class="headerlink" title="预处理指令简介"></a>预处理指令简介</h2><p>C语言在对源程序进行编译之前，会先对一些特殊的预处理指令作解释（比如之前使用的#include文件包含指令），产生一个新的源程序（这个过程称为编译预处理），之后再进行通常的编译。</p>
<p>为了区分预处理指令和一般的C语句，所有预处理指令都以符号”#”开头，并且结尾不用分号。</p>
<p>预处理指令可以出现在程序的任何位置，它的作用范围是从它出现的位置到文件尾。习惯上我们尽可能将预处理指令写在源程序开头，这种情况下，它的作用范围就是整个源程序文件。</p>
<p>C语言提供的预处理指令主要有：宏定义、文件包含、条件编译。</p>
<p>这一讲先介绍一下宏定义，宏定义可以分为2种：不带参数的宏定义和带参数的宏定义。</p>
<h2 id="不带参数的宏定义"><a href="#不带参数的宏定义" class="headerlink" title="不带参数的宏定义"></a>不带参数的宏定义</h2><h3 id="一般形式"><a href="#一般形式" class="headerlink" title="一般形式"></a>一般形式</h3><p>#define 宏名 字符串。</p>
<p>比如#define ABC 10。</p>
<p>右边的字符串也可以省略，比如#define ABC。</p>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>它的作用是在编译预处理时，将源程序中所有”宏名”替换成右边的”字符串”，常用来定义常量。</p>
<p>接下来写个程序根据圆的半径计算周长：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 源程序中所有的宏名PI在编译预处理的时候都会被3.14所代替</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI 3.14</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据圆的半径计radius算周长</span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">girth</span><span class="params">(<span class="keyword">float</span> radius)</span> </span>&#123;</span><br><span class="line">    return <span class="number">2</span> * PI *radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> g = girth(<span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"周长为：%f\n"</span>, g);</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">周长为：12.560000</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>在第4行定义了一个叫PI的宏，在编译预处理之后，第8行中的2 <em> PI </em>radius就会变成2 <em> 3.14 </em> radius。</li>
</ul>
<h3 id="使用习惯与注意"><a href="#使用习惯与注意" class="headerlink" title="使用习惯与注意"></a>使用习惯与注意</h3><p>宏名一般用大写字母，以便与变量名区别开来，但用小写也没有语法错误。</p>
<p>在编译预处理用字符串替换宏名时，不作语法检查，只是简单的字符串替换。只有在编译的时候才对已经展开宏名的源程序进行语法检查：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I 100</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i[<span class="number">3</span>] = I;</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>在做编译预处理的时候，不管语法对不对，第4行的I都会被替换为100。不过在编译的时候就会报第4行的错。</li>
</ul>
<p>宏名的有效范围是从定义位置到文件结束。如果需要终止宏定义的作用域，可以用#undef命令：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI 3.14</span></span><br><span class="line"><span class="comment">/*</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> PI</span></span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>PI这个宏在第1行到第8行之间是有效的，第8行后就无效了。</li>
</ul>
<p>定义一个宏时可以引用已经定义的宏名：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> R  3.0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI 3.14</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> L  2*PI*R</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S  PI*R*R</span></span><br></pre></td></tr></table></figure>
<h2 id="带参数的宏定义"><a href="#带参数的宏定义" class="headerlink" title="带参数的宏定义"></a>带参数的宏定义</h2><h3 id="一般形式-1"><a href="#一般形式-1" class="headerlink" title="一般形式"></a>一般形式</h3><p>#define 宏名(参数列表) 字符串</p>
<h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><p>在编译预处理时，将源程序中所有宏名替换成字符串，并且将 字符串中的参数 用 宏名右边参数列表 中的参数替换：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> average(a, b) (a+b)/2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = average(<span class="number">10</span>, <span class="number">4</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"平均值：%d\n"</span>, a);</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">平均值：7</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>第3行中定义了一个带有2个参数的宏average，第7行其实会被替换成：int a = (10 + 4)/2;，输出结果为：。是不是感觉这个宏有点像函数呢？</li>
</ul>
<h3 id="使用注意"><a href="#使用注意" class="headerlink" title="使用注意"></a>使用注意</h3><h4 id="宏名和参数列表之间不能有空格"><a href="#宏名和参数列表之间不能有空格" class="headerlink" title="宏名和参数列表之间不能有空格"></a>宏名和参数列表之间不能有空格</h4><p>宏名和参数列表之间不能有空格，否则空格后面的所有字符串都作为替换的字符串：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> average (a, b) (a+b)/2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = average(<span class="number">10</span>, <span class="number">4</span>);</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; BuildFaild &gt;</p>
<p><img src="http://images2015.cnblogs.com/blog/776348/201608/776348-20160820003421421-1488127531.png" alt=""></p>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>注意第1行的宏定义，宏名average跟(a, b)之间是有空格的，于是，第5行就变成了这样：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  这个肯定是编译不通过的。</span></span><br><span class="line"><span class="keyword">int</span> a = (a, b) (a+b)/<span class="number">2</span>(<span class="number">10</span>, <span class="number">4</span>);</span><br></pre></td></tr></table></figure>
<h4 id="字符串中的参数用小括号扩起来"><a href="#字符串中的参数用小括号扩起来" class="headerlink" title="字符串中的参数用小括号扩起来"></a>字符串中的参数用小括号扩起来</h4><p>带参数的宏在展开时，只作简单的字符和参数的替换，不进行任何计算操作。所以在定义宏时，一般用一个小括号括住字符串的参数。</p>
<p>下面定义一个宏D(a)，作用是返回a的2倍数值。</p>
<p>如果定义宏的时候不用小括号括住参数：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> D(a) 2*a</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b = D(<span class="number">3</span>+<span class="number">4</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, b);</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>第7行将被替换成int b = 2*3+4;</li>
</ul>
<p>如果定义宏的时候用小括号括住参数：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> D(a) 2*(a)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b = D(<span class="number">3</span>+<span class="number">4</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, b);</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">14</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>注意右边的a是有括号的，第7行将被替换成int b = 2*(3+4);</li>
</ul>
<h4 id="计算结果也用括号括起来"><a href="#计算结果也用括号括起来" class="headerlink" title="计算结果也用括号括起来"></a>计算结果也用括号括起来</h4><p>下面定义一个宏P(a)，作用是返回a的平方。</p>
<p>如果不用小括号括住计算结果：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Pow(a) (a) * (a)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b = Pow(<span class="number">10</span>) / Pow(<span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, b);</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">100</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>注意第3行，没有用小括号扩住计算结果，只是括住了参数而已。第6行代码被替换为：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> b = (<span class="number">10</span>) * (<span class="number">10</span>) / (<span class="number">2</span>) * (<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>如果用小括号括住计算结果：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Pow(a) ( (a) * (a) )</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b = Pow(<span class="number">10</span>) / Pow(<span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, b);</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">25</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<ul>
<li>那么第6行被替换为：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> b = ( (<span class="number">10</span>) * (<span class="number">10</span>) ) / ( (<span class="number">2</span>) * (<span class="number">2</span>) );</span><br></pre></td></tr></table></figure>
<h3 id="与函数的区别"><a href="#与函数的区别" class="headerlink" title="与函数的区别"></a>与函数的区别</h3><p>从整个使用过程可以发现，带参数的宏定义，在源程序中出现的形式与函数很像。但是两者是有本质区别的：</p>
<ol>
<li>宏定义不涉及存储空间的分配、参数类型匹配、参数传递、返回值问题。</li>
<li>函数调用在程序运行时执行，而宏替换只在编译预处理阶段进行。所以带参数的宏比函数具有更高的执行效率。</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.cnblogs.com/mjios/" target="_blank" rel="external">M了个J的博客</a></p>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[【18】指针和函数]]></title>
      <url>http://sanfordy.com/2016/08/18/%E3%80%96A%E3%80%97%E3%80%901-0%E3%80%91C-%E8%AF%AD%E6%B3%95/%E3%80%9018%E3%80%91%E6%8C%87%E9%92%88%E5%92%8C%E5%87%BD%E6%95%B0/</url>
      <content type="html"><![CDATA[<blockquote>
<p>指针可以根据地址直接操作内存中的数据，使用得当的话，不仅能使代码量变少，还能优化内存管理、提升程序性能。关于指针的内容还非常多，比如指针数组、指向数组的指针、指向指针的指针，那些不常见，现在只讲述在iOS开发中指针的最常见用法，比如这一章的内容—-返回指针的函数 与 指向函数的指针。</p>
</blockquote>
<a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>指针可以根据地址直接操作内存中的数据，使用得当的话，不仅能使代码量变少，还能优化内存管理、提升程序性能。关于指针的内容还非常多，比如指针数组、指向数组的指针、指向指针的指针，那些不常见，现在只讲述在iOS开发中指针的最常见用法，比如这一章的内容—-返回指针的函数 与 指向函数的指针。</p>
<h2 id="返回指针的函数"><a href="#返回指针的函数" class="headerlink" title="返回指针的函数"></a>返回指针的函数</h2><p>指针也是C语言中的一种数据类型，因此一个函数的返回值肯定可以是指针类型的。</p>
<p>返回指针的函数的一般形式为：类型名 * 函数名(参数列表)，比如下面这个函数，返回一个指向char类型变量的指针：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//  将字符串str中的小写字母变成大写，并返回改变后的字符串。</span></span><br><span class="line"><span class="comment">//  注意：这里的参数要char *类型，不能传字符串常量。</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">upper</span><span class="params">(<span class="keyword">char</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">//  定义一个字符串变量</span></span><br><span class="line">    <span class="keyword">char</span> str1[] = <span class="string">"wo shi sb"</span>;</span><br><span class="line">    <span class="comment">//  当传入str2时会崩溃，因为str2指向的是一段字符串常量，字符串常量所在的这段内存只能用来存储字符串常量，并不能存储其他类型的数组，正因为如此，不可以对这段内存存储的进行改写。</span></span><br><span class="line"><span class="comment">//    char *str2 = "wo shi sb";</span></span><br><span class="line"><span class="comment">//    printf("%s",upper(str2));</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  调用函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,upper(str1));</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">upper</span><span class="params">(<span class="keyword">char</span> *str)</span></span>&#123;</span><br><span class="line">    <span class="comment">//  先保留最初的地址，因为等会儿str指向的位置会变来变去的。</span></span><br><span class="line">    <span class="keyword">char</span> *temp = str;</span><br><span class="line">    <span class="comment">//  当str指向的不是空字符时</span></span><br><span class="line">    <span class="keyword">while</span> (*str != <span class="string">'\0'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*str &gt;= <span class="string">'a'</span> &amp;&amp; *str &lt;= <span class="string">'z'</span>) &#123;</span><br><span class="line">            <span class="comment">//  变为大写字母，小写和大写字母的ASCII值有个固定的差值</span></span><br><span class="line">            *str -= <span class="string">'a'</span> - <span class="string">'A'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        str++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  返回当初指向这段字符串的指针</span></span><br><span class="line">    return temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WO SHI SB</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<h2 id="指向函数的指针"><a href="#指向函数的指针" class="headerlink" title="指向函数的指针"></a>指向函数的指针</h2><h3 id="为什么指针可以指向一个函数"><a href="#为什么指针可以指向一个函数" class="headerlink" title="为什么指针可以指向一个函数"></a>为什么指针可以指向一个函数</h3><p>函数作为一段程序，在内存中也要占据部分存储空间，它也有一个起始地址，即函数的入口地址。函数有自己的地址，那就好办了，我们的指针变量就是用来存储地址的。因此，可以利用一个指针指向一个函数。其中，<code>函数名就代表着函数的地址</code>。</p>
<h3 id="指向函数的指针的定义"><a href="#指向函数的指针的定义" class="headerlink" title="指向函数的指针的定义"></a>指向函数的指针的定义</h3><p>定义的一般形式：函数的返回值类型 (*指针变量名)(形式参数1, 形式参数2, …);</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个指针变量p，指向sum函数</span></span><br><span class="line">    <span class="keyword">int</span> (*p)(<span class="keyword">int</span> a, <span class="keyword">int</span> b) = sum;</span><br><span class="line">    <span class="comment">// 或者 int (*p)(int, int) = sum;</span></span><br><span class="line">    <span class="comment">// 或者 int (*p)() = sum;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 利用指针变量p调用函数</span></span><br><span class="line">    <span class="keyword">int</span> result = (*p)(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="comment">// 或者 int result = p(1, 3);</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, result);</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>首先在第3行定义了一个sum函数，接收2个int类型的参数，返回值类型为int</li>
<li>然后在第10行定义了一个指向sum函数的指针变量p。注意p的定义形式：<code>int (*p)(int a, int b)</code>，第1个int代表sum函数的返回值是int类型，然后*p是用括号()包住的，后面的int a和int b代表着sum函数的形参，其实完全可以省略。第10行、11行、12行都是可行</li>
<li>在第15行，先利用*p取出指向的函数，再传入参数调用函数。也可以采用第16行中的做法，这样就跟调用普通函数没什么区别。</li>
</ul>
<h3 id="指向函数的指针变量主要有两个用途"><a href="#指向函数的指针变量主要有两个用途" class="headerlink" title="指向函数的指针变量主要有两个用途"></a>指向函数的指针变量主要有两个用途</h3><h4 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h4><p>这里就不举例了。</p>
<h4 id="将函数作为参数在函数间传递"><a href="#将函数作为参数在函数间传递" class="headerlink" title="将函数作为参数在函数间传递"></a>将函数作为参数在函数间传递</h4><p>&lt; 代码示例 &gt;</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#include <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  减法运算</span></span><br><span class="line"><span class="keyword">int</span> minus(<span class="keyword">int</span> a,<span class="keyword">int</span> b)&#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  加法运算</span></span><br><span class="line"><span class="keyword">int</span> sum(<span class="keyword">int</span> a,<span class="keyword">int</span> b)&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  乘法运算</span></span><br><span class="line"><span class="keyword">int</span> multiply(<span class="keyword">int</span> a,<span class="keyword">int</span> b)&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  这个counting函数是用来做a和b之间的计算，至于做加法还是减法运算，由函数的第1个参数决定</span></span><br><span class="line"><span class="keyword">void</span> counting(<span class="keyword">int</span>(*p)(<span class="keyword">int</span>,<span class="keyword">int</span>),<span class="keyword">int</span> a,<span class="keyword">int</span> b)&#123;</span><br><span class="line">    <span class="keyword">int</span> result = p(a,b);</span><br><span class="line">    printf(<span class="string">"计算结果为：%d\n"</span>,result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="comment">//  进行减法运算</span></span><br><span class="line">    counting(minus, <span class="number">6</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="comment">//  进行加法运算</span></span><br><span class="line">    counting(sum, <span class="number">6</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="comment">//  进行乘法运算</span></span><br><span class="line">    counting(multiply, <span class="number">6</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">计算结果为：2</span><br><span class="line">计算结果为：10</span><br><span class="line">计算结果为：24</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<h3 id="使用注意"><a href="#使用注意" class="headerlink" title="使用注意"></a>使用注意</h3><ol>
<li>由于这类指针变量存储的是一个函数的入口地址，所以对它们作加减运算(比如p++)是无意义的。难道p++就会指向下一个函数了？可笑至极！！没这回事。</li>
<li>返回指针的函数的定义<code>int *p(int a,int b)</code> 和指向函数的指针的定义<code>int (*p)(int a, int b)</code>非常相似，使用时特别注意区分。</li>
</ol>
<h2 id="函数返回值是函数指针"><a href="#函数返回值是函数指针" class="headerlink" title="函数返回值是函数指针"></a>函数返回值是函数指针</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (*func(bool real))(<span class="keyword">int</span>, <span class="keyword">int</span>)</span><br></pre></td></tr></table></figure>
<p>你觉得它的返回值是什么？</p>
<p>这里就涉及到了如何理解指向函数的指针的问题了。一些来自C++教材的建议是从里向外解读这个表达式，这里所谓的里面就是func(bool real)，那么剩下的部分就是所谓的返回值了？有点生硬吧。下面就让我们循序渐进地看看如何理解更好？</p>
<p>要解决问题通常需要找出问题所在，这里是基于这样一种思维定势，那就是我们通常习惯于这样一种声明变量的方式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br></pre></td></tr></table></figure>
<p>这里我们声明a是一个int类型的变量。而对于返回值，我们通常也是采用类似的方式，如一个返回值为int类型的函数通常可以以下面的方式进行声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　　<span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">([params])</span></span>;</span><br></pre></td></tr></table></figure>
<p>因此我们惯性地认为返回值就是最左侧的一个类型名，虽然这通常是对的，但是针对上面的那个例子则显得十分尴尬。</p>
<p>让我们看看一个指向函数的指针的声明式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (*pCompare)(<span class="keyword">int</span>, <span class="keyword">int</span>);</span><br></pre></td></tr></table></figure>
<p>这个指针的名字就是pCompare，令人奇怪的是pCompare并不是在整个声明式的最右边，类型也肯定不是int，而是一个复杂的表达式。让我们用typedef来声明就会发现typedef的使用也不太一样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*PF)</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>我们发现跟惯用的typedef <em>*</em> ???;的方式也截然不同，在上面这个typedef过后，整个表达式可以被简化成：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　　PF pCompare;</span><br></pre></td></tr></table></figure>
<p>现在我们似乎就一见如故了，现在的表达式看起来中规中矩，普通的声明都是类型名加变量名完成声明，而函数指针的声明则是在一个表达式中一个固定的位置进行声明。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　　<span class="keyword">int</span> (*_)(<span class="keyword">int</span>, <span class="keyword">int</span>);</span><br></pre></td></tr></table></figure>
<p>在上文中划线的部分即为声明的部分，也就是这点不同让我们逐渐迷失了方向。</p>
<p>现在让我们写一个返回指向函数的指针的函数，也就是返回值的类型是PF的函数，这就像我们从返回int类型的变量到返回int类型值的函数一样，因此使用以下方式即可：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  PF是一个函数指针类型，所以该函数的返回值是一个函数指针类型的数。</span></span><br><span class="line">　　<span class="function">PF <span class="title">func</span><span class="params">([params])</span></span>;</span><br></pre></td></tr></table></figure>
<p>现在让我们扩展PF，将它还原，也就是把右侧的func([params])部分移到那个横线的位置上。现在我们就可以很轻松地理解本文开头的那个函数，原来是返回值为int (*)(int, int)的函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　　<span class="keyword">int</span> (*func(bool real))(<span class="keyword">int</span>, <span class="keyword">int</span>)</span><br></pre></td></tr></table></figure>
<p>以上<code>func(bool real)</code>也就是一个函数扣除返回值的部分。也就等价于</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　　<span class="function">PF <span class="title">func</span><span class="params">(<span class="keyword">bool</span> real)</span></span></span><br></pre></td></tr></table></figure>
<p>至此你应该能够分析更加复杂的表达式了。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.cnblogs.com/mjios/" target="_blank" rel="external">M了个J的博客</a></p>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[【17】指针和字符串]]></title>
      <url>http://sanfordy.com/2016/08/18/%E3%80%96A%E3%80%97%E3%80%901-0%E3%80%91C-%E8%AF%AD%E6%B3%95/%E3%80%9017%E3%80%91%E6%8C%87%E9%92%88%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      <content type="html"><![CDATA[<blockquote>
<p>strlen函数中的形参是指向字符变量的指针类型，我们可以将一个字符数组名传进去，这一点又说明了指针与数组的密切关系，肯定有JQ。其实，调用strlen函数时，你传一个地址给它就行了，它会从这个地址开始计算字符的个数，直到遇到空字符’\0’位置，因此传入指针变量或者数组名都可以。</p>
</blockquote>
<a id="more"></a>
<h2 id="用指针遍历字符串的所有字符"><a href="#用指针遍历字符串的所有字符" class="headerlink" title="用指针遍历字符串的所有字符"></a>用指针遍历字符串的所有字符</h2><p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个指针p</span></span><br><span class="line"><span class="keyword">char</span> *p;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个数组s存放字符串</span></span><br><span class="line"><span class="keyword">char</span> s[] = <span class="string">"mj"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针p指向字符串的首字符'm'</span></span><br><span class="line">p = s; <span class="comment">// 或者 p = &amp;s[0];</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (; *p != <span class="string">'\0'</span>; p++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c \n"</span>, *p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">m </span><br><span class="line">j </span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>执行完第8行后，内存分布如下图：<br><img src="http://images2015.cnblogs.com/blog/776348/201608/776348-20160818221337328-1437035902.png" alt=""></li>
<li>有了前面指针与数组的基础相信大家能看到第9行之后的代码了：每次遍历之前先判断p当前指向的字符是否为空字符\0，如果不是空字符，就打印当前字符，然后执行p++让指针p指向下一个字符元素。</li>
</ul>
<h2 id="用指针直接指向字符串"><a href="#用指针直接指向字符串" class="headerlink" title="用指针直接指向字符串"></a>用指针直接指向字符串</h2><p>从前面可以看出，指针确实可以指向字符串并操作字符串。不过前面的做法是：先定义一个字符串数组存放字符串，然后将数组首地址传给指针p，让p指向字符串的首字符。</p>
<p>我们也可以直接用指针指向一个字符串，省略定义字符数组这个步骤：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">   <span class="comment">// 定义一个字符串，用指针s指向这个字符串</span></span><br><span class="line">    <span class="keyword">char</span> *s = <span class="string">"mj"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用strlen函数测量字符串长度</span></span><br><span class="line">    <span class="keyword">int</span> len = (unsigned int)<span class="built_in">strlen</span>(s);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"字符串：%s\n"</span>, s);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"字符串长度：%d\n"</span>, len);</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">字符串：mj</span><br><span class="line">字符串长度：2</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>注意第7行，我们直接用指针s指向了字符串”mj”，并没有先创建一个字符数组。看第10行，将指针s传入到strlen函数中，说明之前所学习的字符串处理函数依然可以正常使用。</li>
<li>我们再来看看strlen函数在string.h中的声明：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  strlen函数中的形参是指向字符变量的指针类型，我们可以将一个字符数组名传进去，这一点又说明了指针与数组的密切关系，肯定有JQ。其实，调用strlen函数时，你传一个地址给它就行了，它会从这个地址开始计算字符的个数，直到遇到空字符'\0'位置，因此传入指针变量或者数组名都可以。</span></span><br><span class="line"><span class="keyword">size_t</span>     <span class="built_in">strlen</span>(<span class="keyword">const</span> <span class="keyword">char</span> *);</span><br></pre></td></tr></table></figure>
<ul>
<li>其他字符串处理函数也是一样的：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  它们的参数都是指向字符变量的指针类型，因此可以传入指针变量或者数组名。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  1.字符串拷贝函数</span></span><br><span class="line"><span class="function"><span class="keyword">char</span>    *<span class="title">strcpy</span><span class="params">(<span class="keyword">char</span> *, <span class="keyword">const</span> <span class="keyword">char</span> *)</span></span>;</span><br><span class="line"><span class="comment">//  2.字符串拼接函数</span></span><br><span class="line"><span class="function"><span class="keyword">char</span>    *<span class="title">strcat</span><span class="params">(<span class="keyword">char</span> *, <span class="keyword">const</span> <span class="keyword">char</span> *)</span></span>; </span><br><span class="line"><span class="comment">//  3.字符串比较函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>     <span class="title">strcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">const</span> <span class="keyword">char</span> *)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="指针处理字符串的注意"><a href="#指针处理字符串的注意" class="headerlink" title="指针处理字符串的注意"></a>指针处理字符串的注意</h2><h3 id="正确代码"><a href="#正确代码" class="headerlink" title="正确代码"></a>正确代码</h3><p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *s;</span><br><span class="line">s = <span class="string">"mj"</span>;</span><br></pre></td></tr></table></figure>
<p> 代码分析 &gt;</p>
<ul>
<li>先定义指针变量，再指向字符串。</li>
</ul>
<h3 id="错误代码一"><a href="#错误代码一" class="headerlink" title="错误代码一"></a>错误代码一</h3><p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> s[<span class="number">10</span>];</span><br><span class="line">s = <span class="string">"mj"</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>编译器肯定报第2行的错，因为s是个常量，代表数组的首地址，不能进行赋值运算。</li>
</ul>
<h3 id="错误代码二"><a href="#错误代码二" class="headerlink" title="错误代码二"></a>错误代码二</h3><p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *s = <span class="string">"mj"</span>;   </span><br><span class="line">*s = <span class="string">"like"</span>;</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>第2行代码相当于把字符串”like”存进s指向的那一块内存空间，由第1行代码可以看出，s指向的是”mj”的首字符’m’，也就是说s指向的一块char类型的存储空间，只有1个字节，要”like”存进1个字节的空间内，肯定内存溢出</li>
<li>由第1行代码可以看出，指针s指向的是字符串常量”mj”！因此是不能再通过指针来修改字符串内容的！就算是*s = ‘A’这样”看起来似乎正确”的写法也是错误的，因为s指向的一个常量字符串，不允许修改它内部的字符。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.cnblogs.com/mjios/" target="_blank" rel="external">M了个J的博客</a></p>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[【16】指针和数组]]></title>
      <url>http://sanfordy.com/2016/08/02/%E3%80%96A%E3%80%97%E3%80%901-0%E3%80%91C-%E8%AF%AD%E6%B3%95/%E3%80%9016%E3%80%91%E6%8C%87%E9%92%88%E5%92%8C%E6%95%B0%E7%BB%84/</url>
      <content type="html"><![CDATA[<blockquote>
<p>前面我们已经学习了指针，如果指针存储了某个变量的地址，我们就可以说指针指向这个变量。数组及其数组元素都占有存储空间，都有自己的地址，因此指针变量可以指向整个数组，也可以指向数组元素。</p>
</blockquote>
<a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前面我们已经学习了指针，如果指针存储了某个变量的地址，我们就可以说指针指向这个变量。数组及其数组元素都占有存储空间，都有自己的地址，因此指针变量可以指向整个数组，也可以指向数组元素。</p>
<h2 id="用指针指向一维数组的元素"><a href="#用指针指向一维数组的元素" class="headerlink" title="用指针指向一维数组的元素"></a>用指针指向一维数组的元素</h2><p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个int类型的数组</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个int类型的指针</span></span><br><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 让指针指向数组的第0个元素</span></span><br><span class="line">p = &amp;a[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改所指向元素的值</span></span><br><span class="line">*p = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印第一个元素的值</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"a[0] = %d\n"</span>, a[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a[0] = 10</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>输出结果说明已经通过指针间接修改了数组元素的值，跟指向一个普通int类型变量是一样的。</li>
<li>由于数组名代表着数组的首地址，即a == &amp;a[0]，因此第8行代码等价于：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="comment">// 让指针指向数组的第0个元素</span></span><br><span class="line"><span class="number">2</span> p = a;</span><br></pre></td></tr></table></figure>
<ul>
<li>内存分析图如下，一个指针变量占用2个字节，一个int类型的数组元素占用2个字节：<br><img src="http://images2015.cnblogs.com/blog/776348/201608/776348-20160812104203671-31848389.png" alt=""></li>
</ul>
<h2 id="用指针遍历一维数组元素"><a href="#用指针遍历一维数组元素" class="headerlink" title="用指针遍历一维数组元素"></a>用指针遍历一维数组元素</h2><h3 id="普通遍历方式"><a href="#普通遍历方式" class="headerlink" title="普通遍历方式"></a>普通遍历方式</h3><p>最普通的遍历方式是用数组下标来遍历元素：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个int类型的数组</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a[%d] = %d \n"</span>, i, a[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a[0] = 1 </span><br><span class="line">a[1] = 2 </span><br><span class="line">a[2] = 3 </span><br><span class="line">a[3] = 4 </span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<h3 id="用指针来遍历数组元素"><a href="#用指针来遍历数组元素" class="headerlink" title="用指针来遍历数组元素"></a>用指针来遍历数组元素</h3><p>先定义一个指针，指向数组的第一个元素：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个int类型的数组</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个int类型的指针，并指向数组的第0个元素</span></span><br><span class="line"><span class="keyword">int</span> *p = a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 利用指针运算符*取出数组元素的值</span></span><br><span class="line">    <span class="keyword">int</span> value = *(p+i);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a[%d] = %d \n"</span>, i, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a[0] = 1 </span><br><span class="line">a[1] = 2 </span><br><span class="line">a[2] = 3 </span><br><span class="line">a[3] = 4 </span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>内存分析图如下：<br><img src="http://images2015.cnblogs.com/blog/776348/201608/776348-20160818112935203-566428571.png" alt=""><br>p的值是a[0]的地址，因此，现在我们利用指针p只能访问数组的第0个元素a[0]，用*p就可取出a[0]的值1。要想访问其他元素，就必须拿到元素的地址，可以发现每个元素的地址差值为2，因为在16位编译器环境下，一个int类型的变量占用2个字节。现在只是知道a[0]的地址值为p，怎么根据a[0]的地址获取其他元素的地址呢？其实非常简单，p+1就是a[1]的地址。注意了，这里的p+1代表着p的值加2，并不是p的值加1，比如p的值为ffc3，p+1则为ffc5，而非ffc4。依次类推，p+2就是a[2]的地址ffc7，p+3就是a[3]的地址ffc9。<code>遍历完毕后，指针变量p还是指向a[0]，因为p值一直没有变过，一直都是a[0]的地址ffc3</code>。</li>
<li>我先解释一下，为什么p+1代表p的值加2，而不是加1呢？其实，p+1不一定代表p的值加2，也可能是加1、加4或者加8。究竟加多少，这跟指针的类型有关。下图是在16位编译器环境下的情况：<br><img src="http://images2015.cnblogs.com/blog/776348/201608/776348-20160818112946031-1771197389.png" alt=""><br>聪明的你可能已经找到规律了，因为char类型的变量要占用1字节，所以p+1代表p的值加1；float类型的变量占用4字节，所以p+1代表p的值加4。从这一点，也可以很好地说明为什么指针一定要分类型，不同类型的指针，p+1的含义是不一样的。</li>
<li>其实第10行改成下面的代码也是可以的：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  a值代表数组的首地址，也就是a[0]的地址ffc3。a+1则代表a的值加2，即a[1]的地址ffc5，也就是说，a+i代表着元素a[i]的地址。相信大家也能猜出来了，a+1不一定代表着a值加2，究竟加多少，取决于数组的类型。a+i的计算方法与p+i相同。 </span></span><br><span class="line"><span class="keyword">int</span> value = *(a+i);</span><br></pre></td></tr></table></figure>
<ul>
<li>其实我们也可以直接修改p的值来访问数组元素，只需要改一下第10行的代码即可：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用指针运算符*取出数组元素的值，p++其实就是相当于p = p + 1，直接修改了p值，而且每次是加2。因此，每执行一次p++，指针p就会指向下一个数组元素。遍历完毕后，指针变量p没有指向任何数组元素，因为一共执行了4次p++，最后p值为ffcb。当然，可以重新让p指向a[0]：p = &amp;a[0];或者p = a;</span></span><br><span class="line">  <span class="keyword">int</span> value = *(p++);</span><br></pre></td></tr></table></figure>
<ul>
<li>第10行改成这样是错误的：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  a++相当于a=a+1，数组名a是个常量！不能进行赋值运算！</span></span><br><span class="line"><span class="keyword">int</span> value = *(a++);</span><br></pre></td></tr></table></figure>
<h2 id="指针与一维数组的总结"><a href="#指针与一维数组的总结" class="headerlink" title="指针与一维数组的总结"></a>指针与一维数组的总结</h2><ol>
<li>p是指针，a是一个数组名。</li>
<li>如果p指向了一个数组元素，则p+1表示指向数组该元素的下一个元素。比如，假设p = &amp;a[0]，则p+1表示a[1]的地址。</li>
<li>对于不同类型的数组元素，p值的改变是不同的。如果数组元素为int类型，p+1代表着p的值加上2（16位编译器环境下）。</li>
<li>如果p的初值是&amp;a[0]，那么：<ul>
<li>p+i和a+i都可以表示元素a[i]的地址，它们都指向数组的第i个元素。a代表数组首地址，a+i也是地址，它的计算方法与p+i相同。</li>
<li><code>*(p+i)</code>和<code>*(a+i)</code>都表示数组元素a[i]</li>
<li>虽然p+i和a+i都指向数组的第i个元素,但二者使用时还是有区别的。因为作为指针变量的p可以改变自身值，如p++,使p的值自增。而数组名a是一个代表数组首地址的常量，它的值是不能改变的，即a++是不合法的</li>
</ul>
</li>
<li>引用一个数组元素可以有两种方法:　　　　　　<ul>
<li>下标法: 如a[i]</li>
<li>指针法: 如<code>*(p+i)</code> 或 <code>*(a+i)</code></li>
</ul>
</li>
</ol>
<h2 id="一维数组、指针与函数参数"><a href="#一维数组、指针与函数参数" class="headerlink" title="一维数组、指针与函数参数"></a>一维数组、指针与函数参数</h2><p>用数组名作为函数实参时，是把实参数组名（即该数组的首地址）传递给形参数组，两个数组的地址是一样的，这样形参数组中的元素值发生变化就会使实参数组的元素值也同时变化：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> b[])</span> </span>&#123;</span><br><span class="line">    b[<span class="number">0</span>] = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个int类型的数组</span></span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将数组名a传入change函数中</span></span><br><span class="line">    change(a);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查看a[0]</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a[0]=%d\n"</span>, a[<span class="number">0</span>]);</span><br><span class="line">    </span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a[0]=10</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>change函数的形参是数组类型的，在第11行调用change函数时，将数组名a，也就是数组的地址传给了数组b。因此数组a和b占用着同一块内存空间。</li>
</ul>
<p>这种地址的传递也可以用指针来实现。函数的实参和形参都可以分别使用数组或指针，这样就有4种情况：</p>
<p><img src="http://images2015.cnblogs.com/blog/776348/201608/776348-20160818140330906-137790207.png" alt=""></p>
<p>也就是说，如果一个函数的形参类型是一个数组，调用函数时，你可以传入数组名或者指针变量：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> b[])</span> </span>&#123;</span><br><span class="line">    b[<span class="number">0</span>] = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个int类型的数组</span></span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> *p = a;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将数组名a传入change函数中</span></span><br><span class="line">    change(p);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查看a[0]</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a[0]=%d\n"</span>, a[<span class="number">0</span>]);</span><br><span class="line">    </span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a[0]=10</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>注意第1行的形参类型是个数组int b[]，第10行定义了指针变量p，第13行将p当做实参传入函数。</li>
</ul>
<p>如果一个函数的形参类型是一个指针变量，调用函数时，你可以传入数组名或者指针变量：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> *b)</span> </span>&#123;</span><br><span class="line">    b[<span class="number">0</span>] = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 或者*b = 10;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个int类型的数组</span></span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将数组名a传入change函数中</span></span><br><span class="line">    change(a);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查看a[0]</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a[0]=%d\n"</span>, a[<span class="number">0</span>]);</span><br><span class="line">    </span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a[0]=10</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>注意第1行的形参类型是个指针变量int *b，第12行将数组名a当做实参传入函数。</li>
<li>由第2行可以看出，在很多情况下，指针和数组是可以相互切换使用的。但是，并不能说指针就等于数组。</li>
</ul>
<h2 id="指针和二维数组"><a href="#指针和二维数组" class="headerlink" title="指针和二维数组"></a>指针和二维数组</h2><p>二维数组就是特殊的一维数组，int a[3][3],    a数组中有三个元素a[0],a[1],a[2],每个元素都有自己的地址，a[0],a[1],a[2]又分别作为数组名代表本行数组中得第一个元素的地址。 </p>
<p>一维数组中a指向a[0]，即a指向了a数组中第一个元素，a+1指向了第二个元素a[1]。 </p>
<p>a、a[0]这两个都是指针常量，即只能指向一个固定不变的变量。a指向a[0],a[0]指向a[0][0]，同理a+1指向a[1]，a[1]指向了a[1][0]。以此类推。 比如：定义一个二维数组：int a[3][4] = {1,4,33,4,45,56}; 有三个元素【a[0],a[1],a[2]】 ，a指向了第一个元素a[0]，a+1指向了下一个元素a[1]，如果a的地址为1000则  (a+1)变成了1016【1000+4*4】（64位情况下）：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"string.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">3</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;,*p1=a[<span class="number">0</span>],*p2=a;</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a[0][0]的地址是%p\n"</span>,a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a[0][0]的地址是%p\n"</span>,*a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a[0][0]的地址是%p\n"</span>,a[<span class="number">0</span>]);</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a[0][0]=%d\n"</span>,**a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a[0][0]=%d\n"</span>,*p1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a[0][0]=%d\n"</span>,*a[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a[0][0]=%d\n"</span>,*p2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a[0][0]的地址是0x7fff5fbff820</span><br><span class="line">a[0][0]的地址是0x7fff5fbff820</span><br><span class="line">a[0][0]的地址是0x7fff5fbff820</span><br><span class="line">a[0][0]=1</span><br><span class="line">a[0][0]=1</span><br><span class="line">a[0][0]=1</span><br><span class="line">a[0][0]=1</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>对这个简单的小程序，有个地方我们需要注意，程序中指针p2=a，但由运行结果知道，<code>*p2</code>和<code>*a</code>的值不一样。<code>*a</code>表示a[0]的值，即a[0][0]的地址0x7fff5fbff820，而<code>*p2</code>直接表示a[0][0]的值（与*a[0]的值相同），为什么呢？前面不是说a和a[0]是一样吗？ 在这里我们可以这样理解，a是a[0]的地址，a[0]是a[0][0]的地址，逻辑上它们不一样，但我们来推理一下，a[0][0]的地址是什么？是0x7fff5fbff820，a[0]的地址是什么？是二维数组第一行的首元素的地址，第一行的首元素是什么，就是a[0][0]的地址，也即0x7fff5fbff820.所以，我们可以得出结论，二维数组中， a和a[0]表示的是同一个数组元素a[0][0]的地址，而a[0][0]也就是整个二维数组的首元素，同时也是二维数组第一行的首元素。 </li>
<li>而<code>*p2</code>和<code>*a</code>的值不一样，是因为当令p2=a时，把a的值0x7fff5fbff820赋给了p2，因为p2是一个变量指针，所以p2只能指向一个变量即a[0][0]，不可能指向a[0]（a[0]是一个指针常量，指向a[0][0]）。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.cnblogs.com/mjios/" target="_blank" rel="external">M了个J的博客</a></p>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[【15】指针]]></title>
      <url>http://sanfordy.com/2016/08/01/%E3%80%96A%E3%80%97%E3%80%901-0%E3%80%91C-%E8%AF%AD%E6%B3%95/%E3%80%9015%E3%80%91%E6%8C%87%E9%92%88/</url>
      <content type="html"><![CDATA[<blockquote>
<p>C语言中没有String这种类型。其实字符串就是字符序列，由多个字符组成，所以在C语言中，我们可以用字符数组来存储字符串</p>
</blockquote>
<a id="more"></a>
<h2 id="直接引用"><a href="#直接引用" class="headerlink" title="直接引用"></a>直接引用</h2><p>回想一下，之前我们是如何更改某个变量的值？我们之前是通过变量名来直接引用变量，然后进行赋值：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a;</span><br><span class="line">a = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>看上去是很简单，其实程序内部是怎么操作的呢？其实，程序对变量的读写操作，实际上是对变量所在的存储空间进行写入或取出数据。就上面的代码而言，系统会自动将变量名a转换为变量的存储地址，根据地址找到变量a的存储空间，然后再将数据10以2进制的形式放入变量a的存储空间中：<br><img src="http://images2015.cnblogs.com/blog/776348/201608/776348-20160810173720465-429747711.png" alt=""></li>
<li>通过变量名引用变量，由系统自动完成变量名和其存储地址之间的转换，称为变量的”直接引用”方式。</li>
</ul>
<h2 id="什么是指针"><a href="#什么是指针" class="headerlink" title="什么是指针"></a>什么是指针</h2><p>我们已经知道，”直接引用”是直接通过变量名来读写变量，C语言中还有一种”间接引用”的方式。</p>
<p>以变量a为例，首先将变量a的地址存放在另一个变量中，比如存放在变量b中，然后通过变量b来间接引用变量a，间接读写变量a的值。这就是”间接引用”：</p>
<p><img src="http://images2015.cnblogs.com/blog/776348/201608/776348-20160810180021981-656923486.png" alt=""></p>
<p>如果程序通过”间接引用”的方式来修改a的值，可以这样做：先根据 变量名b 获取 变量b 的地址ffc2，取出变量b中存储的内容ffc1，也就是变量a的地址，再根据变量a的地址ffc1找到a的存储空间，然后修改里面的数据。</p>
<blockquote>
<p><strong>总结</strong>：用来存放变量地址的变量，就称为”指针变量”。在上面的情况下，变量b就是个”指针变量”，我们可以说指针变量b指向变量a。</p>
</blockquote>
<h2 id="指针的定义"><a href="#指针的定义" class="headerlink" title="指针的定义"></a>指针的定义</h2><p>一般形式：类名标识符  *指针变量名;</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int *p;</span><br><span class="line"></span><br><span class="line">float *q;</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>“*”是一个说明符，用来说明这个变量是个指针变量，是不能省略的，但它不属于变量名的一部分。</li>
<li>前面的类型标识符表示指针变量所指向的变量的类型，而且只能指向这种类型的变量。</li>
</ul>
<h2 id="指针的初始化"><a href="#指针的初始化" class="headerlink" title="指针的初始化"></a>指针的初始化</h2><h3 id="先定义后初始化"><a href="#先定义后初始化" class="headerlink" title="先定义后初始化"></a>先定义后初始化</h3><p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义int类型的变量a</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个指针变量p</span></span><br><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将变量a的地址赋值给指针变量p，所以指针变量p指向变量a</span></span><br><span class="line">p = &amp;a;</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>注意第8行，赋值给p的是变量a的地址&amp;a。</li>
</ul>
<h3 id="在定义的同时初始化"><a href="#在定义的同时初始化" class="headerlink" title="在定义的同时初始化"></a>在定义的同时初始化</h3><p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义int类型的变量a</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个指针变量p</span></span><br><span class="line"><span class="comment">// 并将变量a的地址赋值给指针变量p，所以指针变量p指向变量a</span></span><br><span class="line"><span class="keyword">int</span> *p = &amp;a;</span><br></pre></td></tr></table></figure>
<h3 id="初始化的注意"><a href="#初始化的注意" class="headerlink" title="初始化的注意"></a>初始化的注意</h3><p>指针变量是用来存放变量地址的，不要给它随意赋值一个常数。下面的写法是错误的：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p; </span><br><span class="line">p = <span class="number">200</span>; <span class="comment">// 这是错误的</span></span><br></pre></td></tr></table></figure>
<h2 id="指针运算符"><a href="#指针运算符" class="headerlink" title="指针运算符"></a>指针运算符</h2><h3 id="给指针指向的变量赋值"><a href="#给指针指向的变量赋值" class="headerlink" title="给指针指向的变量赋值"></a>给指针指向的变量赋值</h3><p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"修改前，a的值：%d\n"</span>, a);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针变量p指向变量a（这里的"*"只是用来说明p是个指针变量）</span></span><br><span class="line"><span class="keyword">char</span> *p = &amp;a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过指针变量p间接修改变量a的值（这里的"*"是一个指针运算符）</span></span><br><span class="line">*p = <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"修改后，a的值：%d\n"</span>, a);</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修改前，a的值：10</span><br><span class="line">修改后，a的值：9</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>当程序刚执行完第5行代码时，内存中大概的分布情况是这样的：<br><img src="http://images2015.cnblogs.com/blog/776348/201608/776348-20160810181155449-310328214.png" alt=""></li>
<li>第8行的“*p”代表根据p值ffc3这个地址访问对应的存储空间，也就是变量a的存储空间，然后将右边的数值9写入到这个存储空间，相当于 a = 9;，于是内存中就变成这样了：<br><img src="http://images2015.cnblogs.com/blog/776348/201608/776348-20160810181159293-252393579.png" alt=""><br>可以发现，我们通过变量p间接修改了变量a的值。</li>
</ul>
<h3 id="取出指针所指向变量的值"><a href="#取出指针所指向变量的值" class="headerlink" title="取出指针所指向变量的值"></a>取出指针所指向变量的值</h3><p>指针运算符除了可以赋值之外，还可以用于取值：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a = <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">char</span> *p;</span><br><span class="line">p = &amp;a;</span><br><span class="line"><span class="comment">//  *p的意思是：根据p值(即变量a的地址)访问对应的存储空间，并取出存储的内容(即取出变量a的值)，赋值给value。</span></span><br><span class="line"><span class="keyword">char</span> value = *p;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"取出a的值：%d\n"</span>, value);</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">取出a的值：10</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<h3 id="使用注意"><a href="#使用注意" class="headerlink" title="使用注意"></a>使用注意</h3><p>在指针变量没有指向确定地址之前，不要对它所指的内容赋值。下面的写法是错误的：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p; </span><br><span class="line">*p = <span class="number">10</span>; <span class="comment">//这是错误的</span></span><br></pre></td></tr></table></figure>
<p>应该在指针变量指向一个确定的变量后再进行赋值。下面的写法才是正确的：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义2个int型变量</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">6</span>, b;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个指向变量b的指针变量p</span></span><br><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line">p = &amp;b;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将a的值赋值给变量b</span></span><br><span class="line">*p = a;</span><br></pre></td></tr></table></figure>
<h2 id="指针的用途举例"><a href="#指针的用途举例" class="headerlink" title="指针的用途举例"></a>指针的用途举例</h2><p>前面我们通过指针变量p间接访问了变量a，在有些人看来，觉得指针变量好傻B，直接用变量名a访问变量a不就好了么，干嘛搞这么麻烦。别着急，接下来举个例子，让大家看看指针还能做什么事情。</p>
<blockquote>
<p><strong>说明</strong>：在16位编译器环境下，一个指针变量占用2个字节。</p>
</blockquote>
<h3 id="例子一"><a href="#例子一" class="headerlink" title="例子一"></a>例子一</h3><p>现在有个要求：写一个函数swap，接收2个整型参数，功能是互换两个实参的值。</p>
<h4 id="不用指针"><a href="#不用指针" class="headerlink" title="不用指针"></a>不用指针</h4><p>如果没学过指针，你可能会这样写：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span> v1, <span class="keyword">char</span> v2)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"更换前：v1=%d, v2=%d\n"</span>, v1, v2);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 定义一个中间变量</span></span><br><span class="line">    <span class="keyword">char</span> temp;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 交换v1和v2的值</span></span><br><span class="line">    temp = v1;</span><br><span class="line">    v1 = v2;</span><br><span class="line">    v2 = temp;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"更换后：v1=%d, v2=%d\n"</span>, v1, v2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a = <span class="number">10</span>, b = <span class="number">9</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"更换前：a=%d, b=%d\n"</span>, a, b);</span><br><span class="line">    </span><br><span class="line">    swap(a, b);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"更换后：a=%d, b=%d\n"</span>, a, b);</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">更换前：a=10, b=9</span><br><span class="line">更换前：v1=10, v2=9</span><br><span class="line">更换后：v1=9, v2=10</span><br><span class="line">更换后：a=10, b=9Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>虽然v1和v2的值被交换了，但是变量a和b的值根本就没有换过来。因为基本数据类型作为函数实参时，只是纯粹地将值传递给形参，形参的改变并不影响实参。</li>
<li>在第20行中，将变量a、b的值分别传递给了swap函数的两个形参v1、v2：<br><img src="http://images2015.cnblogs.com/blog/776348/201608/776348-20160810211136027-1827316399.png" alt=""></li>
<li>在第8行中，将v1的值赋值给了temp:<br><img src="http://images2015.cnblogs.com/blog/776348/201608/776348-20160810211201996-1670795747.png" alt=""></li>
<li>在第9行中，将v2的值赋值给了v1：<br><img src="http://images2015.cnblogs.com/blog/776348/201608/776348-20160810211251918-2067342656.png" alt=""></li>
<li>在第10行中，将temp的值赋值给了v2：<br><img src="http://images2015.cnblogs.com/blog/776348/201608/776348-20160810211337746-344522993.png" alt=""><br>就这样，v1和v2的值被交换了，但是a和b的值一直都没有改变。</li>
</ul>
<h4 id="使用指针"><a href="#使用指针" class="headerlink" title="使用指针"></a>使用指针</h4><p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span> *v1, <span class="keyword">char</span> *v2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 中间变量</span></span><br><span class="line">    <span class="keyword">char</span> temp;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 取出v1指向的变量的值</span></span><br><span class="line">    temp = *v1;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 取出v2指向的变量的值，然后赋值给v1指向的变量</span></span><br><span class="line">    *v1 = *v2;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 赋值给v2指向的变量</span></span><br><span class="line">    *v2 = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a = <span class="number">10</span>, b = <span class="number">9</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"更换前：a=%d, b=%d\n"</span>, a, b);</span><br><span class="line">    </span><br><span class="line">    swap(&amp;a, &amp;b);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"更换后：a=%d, b=%d\n"</span>, a, b);</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">更换前：a=10, b=9</span><br><span class="line">更换后：a=9, b=10</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>先注意第20行，传递是变量的地址。因此swap函数的形参v1指向了变量a，v2指向了变量b：<br><img src="http://images2015.cnblogs.com/blog/776348/201608/776348-20160810211501152-1930237207.png" alt=""></li>
<li>第6行代码是取出v1指向的变量的值，也就是变量a的值：10，然后赋值给变量temp：<br><img src="http://images2015.cnblogs.com/blog/776348/201608/776348-20160810211522059-1684052179.png" alt=""></li>
<li>第9行代码是取出v2指向的变量(变量b)的值，然后赋值给v1指向的变量（变量a）：<br><img src="http://images2015.cnblogs.com/blog/776348/201608/776348-20160810211537465-1337156886.png" alt=""></li>
<li>第12行代码是将temp变量的值赋值给v2指向的变量（变量b）：<br><img src="http://images2015.cnblogs.com/blog/776348/201608/776348-20160810211552684-2082667724.png" alt=""></li>
</ul>
<p>相信你已经感受到指针的强大了，如果没有指针，在一个函数的内部根本改变不了外部的实参。</p>
<h3 id="例子二"><a href="#例子二" class="headerlink" title="例子二"></a>例子二</h3><p>接下来再举一个指针的实用例子。默认情况下，一个函数只能有一个返回值，有了指针，我们可以实现函数有“多返回值”。</p>
<p>现在有个要求：写一个函数sumAndMinus，可以同时计算2个整型的和与差，函数执行完毕后，返回和与差（注意了，这里要返回2个值）：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算2个整型的和与差</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sumAndMinus</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2, <span class="keyword">int</span> *minus)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 计算差，并赋值给指针指向的变量</span></span><br><span class="line">    *minus = v1 - v2;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算和，并返回和</span></span><br><span class="line">    return v1 + v2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">// 定义2个int型变量</span></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">6</span>, b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义2个变量来分别接收和与差</span></span><br><span class="line">    <span class="keyword">int</span> sum, minus;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用函数</span></span><br><span class="line">    sum = sumAndMinus(a, b, &amp;minus);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印和</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d+%d=%d\n"</span>, a, b, sum);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印差</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d-%d=%d\n"</span>, a, b, minus);</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">6+2=8</span><br><span class="line">6-2=4</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>和与差都由同一个函数计算并返回出来。和是函数的直接返回值，差是通过函数的第3个指针参数间接返回。因此有了指针，我们可以让函数有”无限个”返回值。</li>
</ul>
<h2 id="关于指针的疑问"><a href="#关于指针的疑问" class="headerlink" title="关于指针的疑问"></a>关于指针的疑问</h2><h3 id="指针变量占多少内存空间？"><a href="#指针变量占多少内存空间？" class="headerlink" title="指针变量占多少内存空间？"></a>指针变量占多少内存空间？</h3><p>在同一种编译器环境下，一个指针变量所占用的内存空间是固定的。比如，在16位编译器环境下，任何一个指针变量都只占用2个字节，并不会随所指向变量的类型而改变。各种编译器下指针所占内存空间如下图：</p>
<p><img src="http://images2015.cnblogs.com/blog/776348/201608/776348-20160810213708715-452247161.png" alt=""></p>
<p>为什么32位编译器下指针变量占用四个字节：因为CPU和内存之间是由32根地址总线连接的，CPU通过这32根地址总线控制内存，每根地址总线都有两种状态（不接通0或不接通1），32根地址线的状态不同时表示控制不同的字节，所以总共能控制2^32个字节。而这32根线的状态需要用32bit即四个字节存储（每个bit存储一个0或1表示不接通或接通）。</p>
<h3 id="指针变量为什么要分类型？"><a href="#指针变量为什么要分类型？" class="headerlink" title="指针变量为什么要分类型？"></a>指针变量为什么要分类型？</h3><p>既然每个指针变量所占用的内存空间是一样的，而且存储的都是地址，为何指针变量还要分类型？而且只能指向一种类型的变量？比如指向int类型的指针、指向char类型的指针。</p>
<p>其实，我觉得这个问题跟”数组为什么要分类型”是一样的。看下面的代码：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">char</span> c = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  定义一个指向char类型的指针</span></span><br><span class="line">    <span class="keyword">char</span> *p = &amp;c;</span><br><span class="line">    <span class="comment">//  取出</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *p);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> *q = &amp;c;</span><br><span class="line">    <span class="comment">//  取出</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *q);</span><br><span class="line">    </span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">513</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>第15行用一个本应该指向int类型的指针q，指向char类型的变量c，取出来却是513，怎么回事呢？这个要根据内存来分析，根据变量的定义顺序，这些变量在内存中大致如下图排布：<br><img src="http://images2015.cnblogs.com/blog/776348/201608/776348-20160810213716418-10922204.png" alt=""><br>其中，指针变量p和int类型变量i各占2个字节，char类型的c占一个字节，p指向c，因此p值就是c的地址。</li>
<li>第9行，用指针p指向变量c。当利用*p来获取变量c的值时，由于指针p知道变量c是char类型的，所以会从ffc3这个地址开始读取1个字节的数据：0000 0001，转为10进制就是1。</li>
<li>第13行，用指针q指向变量c。当利用*q获取变量c的值时，由于指针q认为变量c是int类型的，所以会从ffc3这个地址开始读取2个字节的数据：0000 0010 0000 0001，转为10进制就是513。</li>
</ul>
<p>可见，给指针分类是多么重要的一件事，而且一种指针最好只指向一种类型的变量，那是最安全的。</p>
<h2 id="学习指针必须搞定的问题"><a href="#学习指针必须搞定的问题" class="headerlink" title="学习指针必须搞定的问题"></a>学习指针必须搞定的问题</h2><h3 id="常量指针和指针常量"><a href="#常量指针和指针常量" class="headerlink" title="常量指针和指针常量"></a>常量指针和指针常量</h3><h4 id="常量指针"><a href="#常量指针" class="headerlink" title="常量指针"></a>常量指针</h4><p>常量指针：常量是形容词，指针是名词。这样看来常量指针本质是指针，常量修饰它，表示这个指针乃是一个指向常量的指针（这里指的是用const 修饰过的变量即常量，而不是普通变量）。因为是常量，所以它的值是不可修改的，因此用*号对指针不能进行赋值操作。当然，这个指针是变量，还可以指向其他的常量，但是这个指针只能指向常量，即存储的值只能是常量的地址而不能是变量的地址。</p>
<p>在C/C++中，常量指针是这样声明的：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  声明格式一</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  声明格式二</span></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> *p;</span><br></pre></td></tr></table></figure>
<p>常量指针的使用要注意，不能用*号对指针进行赋值操作来改变其指向的对象的值，可是仍然可以通过原来的声明修改，也就是说常量指针可以被赋值为变量的地址，之所以叫做常量指针，是限制了通过这个指针修改变量的值。例如：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> b = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *c = &amp;a; <span class="comment">// 这是合法的</span></span><br><span class="line">　　*c = <span class="number">6</span>; <span class="comment">// 非法</span></span><br><span class="line">　　 a = <span class="number">6</span>;<span class="comment">// 但可以这样修改c指向的对象的值</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *d = &amp;b; <span class="comment">// b是常量，d可以指向b，d被赋值为b的地址是合法的</span></span><br></pre></td></tr></table></figure>
<p>虽然常量指针指向的对象一般不能改变（这里指的是用const 修饰过的变量即常量，而不是普通变量），可是因为常量指针是一个变量，因此，常量指针可以不被赋初始值，且可以被重新赋值。例如：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> b = <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *c = &amp;a; <span class="comment">// 为了简化代码，很多人习惯赋初始值</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *d;</span><br><span class="line"></span><br><span class="line">d = &amp;a; <span class="comment">// 这样当然是可以的</span></span><br><span class="line">c = &amp;b; <span class="comment">// 虽然c已经被赋予初始值，可是仍然可以指向另一个变量</span></span><br></pre></td></tr></table></figure>
<h4 id="指针常量"><a href="#指针常量" class="headerlink" title="指针常量"></a>指针常量</h4><p>指针常量：指针是形容词，常量是名词。这样看来指针常量的本质是一个常量，指针修饰它，那么说明这个常量的存储的值应该是一个地址。指针常量就是说指针本身就是一个常量，正如整型常量666一样。那么作为常量，那么这个指针的值是无法改变的，就相当于一个整型常量一样，一旦初始化后就不可以改变。所以指针常量声明时必须初始化。初始化后这个指针就一直指向这个变量，可以通过*改变被指向变量的值。</p>
<p>在C/C++中，指针常量这样声明：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> b;</span><br></pre></td></tr></table></figure>
<p>只要const位于指针声明操作符右侧，就表明声明的对象是一个常量，且它的内容是一个指针，也就是一个地址。因为指针常量是一个常量，在声明的时候一定要给它赋初始值。一旦赋值，以后这个常量再也不能指向别的地址。</p>
<p>虽然指针常量的值不能变，可是它指向的对象是可变的，因为我们并没有限制它指向的对象是常量：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"string.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> *<span class="keyword">const</span> b = &amp;a;</span><br><span class="line">    *b = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,*b);<span class="comment">//  输出：2</span></span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>总结</strong>：你可以把*读作指针，把const读作常量，那么从左到右一读就可以分辨常量指针和指针常量了。</p>
</blockquote>
<h3 id="指针和地址"><a href="#指针和地址" class="headerlink" title="指针和地址"></a>指针和地址</h3><p>地址：是系统的用户地址空间的虚拟内存地址编号，并不是实际的内存地址编号。地址就是一个编号而已，就像门牌号，学号。这没有所谓的存储空间的说法，就是名字。而我们编程使用的地址是虚拟内存地址，就是我们常说的内存地址。</p>
<p>指针：是一个变量，使用变量时需要系统分配一个内存才能使用。而指针是存储内存地址的一种变量，使用指针就像使用内存地址一样。而对指针的赋值只是改变指针变量存储的值，只是更新了一下变量中存储的值而已。</p>
<p>区别和联系：</p>
<ol>
<li>区别：指针是一个存储地址的变量，占用内存空间，地址只是一串数字，不占内存空间。</li>
<li>联系：地址是放在指针变量中的。好比 int a=3;中，a（类似于指针）和3（类似于地址）的关系。 </li>
</ol>
<h3 id="变量和地址的联系"><a href="#变量和地址的联系" class="headerlink" title="变量和地址的联系"></a>变量和地址的联系</h3><p>变量占内存空间，地址只是一串数字；每一个变量都有地址，可以通过 &amp;变量名 取得变量的地址，就像每一个人都有一个住址一样的。 </p>
<h3 id="指向指针的指针"><a href="#指向指针的指针" class="headerlink" title="指向指针的指针"></a>指向指针的指针</h3><p>指向指针的指针：本质是一个指针，只是这个指针指向的变量是一个指针类型的，也叫二级指针。</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> **p1;</span><br></pre></td></tr></table></figure>
<h3 id="指针数组和指向数组的指针"><a href="#指针数组和指向数组的指针" class="headerlink" title="指针数组和指向数组的指针"></a>指针数组和指向数组的指针</h3><h4 id="指针数组"><a href="#指针数组" class="headerlink" title="指针数组"></a>指针数组</h4><p>指针数组：本质是一个数组，只是数组中的每一个元素都是指针。</p>
<p>定义一个指针数组：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  由于[]比*优先级高，因此p先于[4]结合，形成p[4]这样的形式，这显然是数组形式，表示p数组有四个元素，然后再与p前面的“*”结合，“*”表示此数组是指针类型的，每个数组元素（相当于一个指针变量）都可以指向一个int变量。</span></span><br><span class="line"><span class="keyword">int</span> *p[<span class="number">4</span>];</span><br></pre></td></tr></table></figure>
<h4 id="指向数组的指针"><a href="#指向数组的指针" class="headerlink" title="指向数组的指针"></a>指向数组的指针</h4><p>指向数组的指针：本质是一个指针，前面是定语，是修饰语，该指针指向一个数组。</p>
<p>定义一个指向数组的指针：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//   定义一</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> * p = a;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  定义二</span></span><br><span class="line"><span class="comment">//  用括号括起来的*a使得*首先与a结合，表明a是一个指针，[]表明是一个数组，int 表明这个数组中的元素都是整型的。整体理解就是: 声明一个指向含10个整型元素的数组的指针。 </span></span><br><span class="line"><span class="keyword">int</span>(*a)[<span class="number">10</span>]</span><br></pre></td></tr></table></figure>
<h3 id="数组名和指针"><a href="#数组名和指针" class="headerlink" title="数组名和指针"></a>数组名和指针</h3><p>数组名：存放数组中首个元素的地址的常量，是指针常量，内容不可以修改。</p>
<p>指针：变量，内容可以修改。</p>
<h3 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h3><p>在编程中根据需要会动态分配一块内存，这块内存如果没有释放，其他任何程序都不能使用。程序结束，程序占用的资源销毁，如果程序没有释放这块内存，那么这块内存就会因为程序的结束而失去和操作系统的联系，导致这块内存无法再次使用。如果泄露的内存过多，导致可用内存越来越少，最后甚至系统所需的内存都不能满足，系统就崩溃了。重启机器后就会正常。因为重启机器后启动系统会重新规划内存，重新分配。 </p>
<h3 id="堆和栈"><a href="#堆和栈" class="headerlink" title="堆和栈"></a>堆和栈</h3><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>堆就是一块大内存块。这个内存块是在程序所在的内存块之外的。所有程序都可以在这个堆中请求分配内存。请求成功就用一个指针指向这个请求到的内存，就可以使用了。因为这部分的内存不属于某个程序，实际上是属于系统的，相当于一个公共内存区，对于所有的程序都是可用的。当然，对于这部分的内存的管理，谁申请了就由谁来管理已分配的内存。释放掉之后就由系统来管理，未释放则一直由申请的程序进行管理和使用。如果程序运行结束后忘了释放这块内存，因而在堆中系统还是认为这块内存已经被分配，所以其他程序也就无法申请使用，而这个程序又结束了，这样一来，这块内存就谁也不可用了。这就是内存泄露。久而久之，这样的内存越来越多，那么堆中的内存就少了，自然系统就到空余的内存获取来补充堆内存的数量。然而，泄露的一直持续的话，所有的可用内存都用来做堆内存了，而对内存一直在泄露最后，堆中无可用内存，所有程序就无法请求动态分配内存了。同时此时，系统也无法请求内存，然而系统核心程序运行请求不到内存就失败，这样整个系统就运行不了了，就崩溃了。重启系统后，内存中的数据全部清零，全部重新规划，就不存在这个内存不足的问题了。但是如果还运行这些不完善的程序，还会内存泄露。堆的作用主要就是为程序提供动态内存分配，这样就能满足程序运行时增加内存的要求。程序的代码一般是在栈中的，使用动态内存分配，会给程序在内存的堆（一块特定的内存区域）中分配一块内存，利用这个动态分配函数分配的内存，在使用完后必须使用对应的函数释放相应的内存，不然就会造成内存泄露。</p>
<h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p>栈是一个先进先出的内存结构模型。系统为程序分配内存空间时，都是按照栈的方式进行分配的。因此在程序中出现的函数调用，就是利用栈的特性实现的，这个特性在递归身上表现的淋漓尽致。函数调用时首先将本函数的所有东西压入到栈中，然后执行新函数。执行新函数时将新函数用到的所有东西压入栈顶，使用时出栈即可。执行完后，新函数中所有的东西都出栈了，再出栈就回到了原来函数的执行了。这就是巧妙的利用了栈的特性。程序中自动变量的分配（如 int a ;）就是通过栈来分配的，因而执行完程序之后，这些变量所占的内存自然而然的就释放掉了。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.cnblogs.com/mjios/" target="_blank" rel="external">M了个J的博客</a></p>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[【14】字符串]]></title>
      <url>http://sanfordy.com/2016/08/01/%E3%80%96A%E3%80%97%E3%80%901-0%E3%80%91C-%E8%AF%AD%E6%B3%95/%E3%80%9014%E3%80%91%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      <content type="html"><![CDATA[<blockquote>
<p>C语言中没有String这种类型。其实字符串就是字符序列，由多个字符组成，所以在C语言中，我们可以用字符数组来存储字符串</p>
</blockquote>
<a id="more"></a>
<h2 id="字符串简介"><a href="#字符串简介" class="headerlink" title="字符串简介"></a>字符串简介</h2><p>在Java中，一个字符串可以用String类型来存储：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"string"</span>;</span><br></pre></td></tr></table></figure>
<p>C语言中没有String这种类型。其实字符串就是字符序列，由多个字符组成，所以在C语言中，我们可以用字符数组来存储字符串。</p>
<p>字符串可以看做是一个特殊的字符数组，为了跟普通的字符数组区分开来，应该在字符串的尾部添加了一个结束标志’\0’。’\0’是一个ASCII码值为0的字符，是一个空操作符，表示什么也不干。所以采用字符数组存放字符串，赋值时应包含结束标志’\0’。</p>
<p>字符串”mj”的存储情况如下（假设用字符数组char a[]来存储）：</p>
<p><img src="http://images2015.cnblogs.com/blog/776348/201608/776348-20160810115159324-73374550.png" alt=""></p>
<blockquote>
<p><strong>注意</strong>：尾部有个’\0’，如果没有这个结束标记，说明这个字符数组存储的并不是字符串。</p>
</blockquote>
<h2 id="字符串的初始化"><a href="#字符串的初始化" class="headerlink" title="字符串的初始化"></a>字符串的初始化</h2><p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  一</span></span><br><span class="line"><span class="keyword">char</span> a[<span class="number">3</span>] = &#123;<span class="string">'m'</span>, <span class="string">'j'</span>, <span class="string">'\0'</span>&#125;;</span><br><span class="line"><span class="comment">//  二</span></span><br><span class="line"><span class="keyword">char</span> b[<span class="number">3</span>];</span><br><span class="line">b[<span class="number">0</span>] = <span class="string">'m'</span>;</span><br><span class="line">b[<span class="number">1</span>] = <span class="string">'j'</span>;</span><br><span class="line">b[<span class="number">2</span>] = <span class="string">'\0'</span>;</span><br><span class="line"><span class="comment">//  三</span></span><br><span class="line"><span class="keyword">char</span> c[<span class="number">3</span>] = <span class="string">"mj"</span>;</span><br><span class="line"><span class="comment">//  四</span></span><br><span class="line"><span class="keyword">char</span> d[] = <span class="string">"mj"</span>;</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>一般我们使用第11行的初始化方式，系统会自动在字符串尾部加上一个\0结束符。</li>
</ul>
<blockquote>
<p><strong>注意</strong>：字符串所占的空间至少要比字符串长度大1，因为字符串以 ‘\0’ 表⽰结束。</p>
</blockquote>
<h2 id="字符串的输入"><a href="#字符串的输入" class="headerlink" title="字符串的输入"></a>字符串的输入</h2><p>stdio.h中有2个函数可以用来接收用户输入的字符串，分别是scanf和gets。</p>
<h3 id="scanf"><a href="#scanf" class="headerlink" title="scanf"></a>scanf</h3><p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, a);</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>scanf函数会从a的首地址开始存放用户输入的字符，存放完毕后，系统会自动在尾部加上一个结束标记’\0’。</li>
<li>不要写成scanf(“%s”, &amp;a)，因为a已经代表了数组的地址，没必要再加上&amp;这个地址运算符。</li>
</ul>
<h3 id="gets"><a href="#gets" class="headerlink" title="gets"></a>gets</h3><p>&lt; 代码示例 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char a[10];</span><br><span class="line">gets(a);</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>gets跟scanf一样，会从a的首地址开始存放用户输入的字符，存放完毕后，系统会自动在尾部加上一个结束标记’\0’。</li>
<li>gets一次只能读取一个字符串，scanf则可以同时读取多个字符串。</li>
<li>gets可以读入包含空格、tab的字符串，直到遇到回车为止；scanf不能用来读取空格、tab。</li>
</ul>
<h2 id="字符串的输出"><a href="#字符串的输出" class="headerlink" title="字符串的输出"></a>字符串的输出</h2><p>我们可以使用stdio.h中两个函数来输出字符串，分别是printf和puts函数。</p>
<h3 id="printf"><a href="#printf" class="headerlink" title="printf"></a>printf</h3><p>这个函数我们已经用过很多遍了，用格式符%s表示需要输出一个字符串：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a[<span class="number">3</span>] = &#123;<span class="string">'m'</span>, <span class="string">'j'</span>, <span class="string">'\0'</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, a);</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mj</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>最后面那个\0是不可能输出的，它只是个空字符，只是字符串结束的标记。</li>
</ul>
<p>说到这里，有人可能会想：这样看来，似乎把最后的\0去掉也没什么影响吧，输出结果应该还是一样的啊，都是”mj”。我们可以试一下，把最后面的\0去掉，再进行输出：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a[<span class="number">3</span>] = &#123;<span class="string">'m'</span>, <span class="string">'j'</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s"</span>, a);</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mj</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>跟上面添加了\0的输出结果是一样的。别高兴地太早了，我只能说你这是侥幸一样的，运气好了一点。</li>
</ul>
<p>我们再来看一个例子：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  添加了结束符\0</span></span><br><span class="line"><span class="keyword">char</span> a[<span class="number">3</span>] = &#123;<span class="string">'m'</span>, <span class="string">'j'</span>, <span class="string">'\0'</span>&#125;; </span><br><span class="line"><span class="comment">//  假设忘记添加结束符\0</span></span><br><span class="line"><span class="keyword">char</span> b[] = &#123;<span class="string">'i'</span>, <span class="string">'s'</span>&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出字符串a</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"字符串a：%s\n"</span>, a); </span><br><span class="line"><span class="comment">// 输出字符串b</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"字符串b：%s\n"</span>, b); </span><br><span class="line"></span><br><span class="line"><span class="comment">//  打印a的地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"a的地址：%x\n"</span>, a);</span><br><span class="line"><span class="comment">//  打印b的地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"b的地址：%x\n"</span>, b);</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">字符串a：mj</span><br><span class="line">字符串b：ismj</span><br><span class="line">a的地址：5fbff809</span><br><span class="line">b的地址：5fbff807</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>看清楚了，第4行的字符数组b后面没有添加结束符\0，因此b不算是个正宗的字符串。</li>
<li>按照你的猜想，字符串b的输出应该就是”is”，但是当我们尝试输出b的时候，把a也输出了。要搞清楚为什么，首先要看看a和b的内存地址：<br><img src="http://images2015.cnblogs.com/blog/776348/201608/776348-20160810143638949-521231888.png" alt=""><br>可以看出来，数组b和a的内存地址是连续的。我们再看第9行代码，%s表示期望输出一个字符串，因此printf函数会从b的首地址开始按顺序输出字符，一直到\0字符为止，因为\0是字符串的结束标记。所以，如果想要创建一个字符串，记得加上结束符\0，不然后果很严重，会访问到一些垃圾数据。</li>
</ul>
<h3 id="puts"><a href="#puts" class="headerlink" title="puts"></a>puts</h3><p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a[] = <span class="string">"mj"</span>;</span><br><span class="line"><span class="built_in">puts</span>(a);</span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"lmj"</span>);</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mj</span><br><span class="line">lmj</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>看第2行代码，puts函数会从a的首地址开始输出字符，一直到\0字符为止。</li>
<li>从输出结果可以看出puts函数输出一个字符串后会自动换行。</li>
</ul>
<blockquote>
<p><strong>注意</strong>：puts函数一次只能输出一个字符串，printf函数则可以同时输出多个字符串。</p>
</blockquote>
<h2 id="字符串常用处理函数"><a href="#字符串常用处理函数" class="headerlink" title="字符串常用处理函数"></a>字符串常用处理函数</h2><p>下面介绍的字符串处理函数都是在string.h头文件中声明的，使用前要包含这个头文件。</p>
<p>系统提供的字符串处理函数都是根据 ‘\0’ 来判断字符串是否结束。</p>
<h3 id="strlen"><a href="#strlen" class="headerlink" title="strlen"></a>strlen</h3><p>这个函数可以用来测量字符串的字符个数，不包括\0：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> size = <span class="built_in">strlen</span>(<span class="string">"mj"</span>); <span class="comment">// 长度为2</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">char</span> s1[] = <span class="string">"lmj"</span>;</span><br><span class="line"><span class="keyword">int</span> size1 = <span class="built_in">strlen</span>(s1); <span class="comment">// 长度为3</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">char</span> s2[] = &#123;<span class="string">'m'</span>, <span class="string">'j'</span>, <span class="string">'\0'</span>, <span class="string">'l'</span>, <span class="string">'m'</span>, <span class="string">'j'</span>, <span class="string">'\0'</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> size2 = <span class="built_in">strlen</span>(s2); <span class="comment">// 长度为2</span></span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>看一下第7行，strlen函数会从s2的首地址开始计算字符个数，直到遇到空字符\0为止。因为s2的第1个\0之前只有mj这2个字符，所以长度为2。</li>
</ul>
<h3 id="strcpy"><a href="#strcpy" class="headerlink" title="strcpy"></a>strcpy</h3><p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> s[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(s, <span class="string">"lmj"</span>);</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>strcpy函数会将右边的”lmj”字符串拷贝到字符数组s中。从s的首地址开始，逐个字符拷贝，直到拷贝到\0为止。当然，在s的尾部肯定会保留一个\0。</li>
</ul>
<p>假设右边的字符串中有好几个\0，strcpy函数只会拷贝第1个\0之前的内容，后面的内容不拷贝：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> s[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">char</span> c[] = &#123;<span class="string">'m'</span>, <span class="string">'j'</span>, <span class="string">'\0'</span>, <span class="string">'l'</span>, <span class="string">'m'</span>, <span class="string">'j'</span>, <span class="string">'\0'</span>&#125;;</span><br><span class="line"><span class="built_in">strcpy</span>(s, c);</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>最后字符串s中的内容为：mj。</li>
</ul>
<h3 id="strcat"><a href="#strcat" class="headerlink" title="strcat"></a>strcat</h3><p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> s1[<span class="number">30</span>] = <span class="string">"LOVE"</span>;</span><br><span class="line"><span class="built_in">strcat</span>(s1, <span class="string">"OC"</span>);</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>strcat函数会将右边的”OC”字符串拼接到s1的尾部，最后s1的内容就变成了”LOVEOC”：<br><img src="http://images2015.cnblogs.com/blog/776348/201608/776348-20160810145929012-605081378.png" alt=""><br>strcat函数会从s1的第1个\0字符开始连接字符串，s1的第1个\0字符会被右边的字符串覆盖，连接完毕后在s1的尾部保留一个\0。</li>
</ul>
<p>注意下面的情况：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> s1[<span class="number">30</span>] = &#123;<span class="string">'L'</span>, <span class="string">'m'</span>, <span class="string">'j'</span>, <span class="string">'\0'</span>, <span class="string">'L'</span>, <span class="string">'o'</span>, <span class="string">'v'</span>, <span class="string">'e'</span>, <span class="string">'\0'</span>&#125;;</span><br><span class="line"><span class="built_in">strcat</span>(s1, <span class="string">"OC"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, s1);</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LmjOC</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>第1行初始化的s1有2个\0，经过第2行的strcat函数后：<br><img src="http://images2015.cnblogs.com/blog/776348/201608/776348-20160810145937762-2089615226.png" alt=""></li>
</ul>
<h3 id="strcmp"><a href="#strcmp" class="headerlink" title="strcmp"></a>strcmp</h3><p>这个函数可以用来比较2个字符串的大小。调用形式为：strcmp(字符串1, 字符串2)。</p>
<p>两个字符串从左至右逐个字符比较（按照字符的ASCII码值的大小），直到字符不相同或者遇见’\0’为止。如果全部字符都相同，则返回值为0。如果不相同，则返回两个字符串中第一个不相同的字符ASCII码值的差。即字符串1大于字符串2时函数返回值为正，否则为负：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">char s1[] = &quot;abc&quot;;</span><br><span class="line">char s2[] = &quot;abc&quot;;</span><br><span class="line">char s3[] = &quot;aBc&quot;;</span><br><span class="line">char s4[] = &quot;ccb&quot;;</span><br><span class="line"></span><br><span class="line">printf(&quot;%d, %d, %d\n&quot;, strcmp(s1, s2), strcmp(s1, s3), strcmp(s1, s4));</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0, 32, -2</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>s1和s2相同，所以返回0。</li>
<li>s1和s3是第2个字符不相同，b的ASCII码值是98，B的ASCII码值是66，b - B = 32，所以返回32。</li>
<li>s1和s4是第1个字符就不相同，a的ASCII码值是97，c的ASCII码值是99，a - c = -2，所以返回-2。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.cnblogs.com/mjios/" target="_blank" rel="external">M了个J的博客</a></p>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[【13】数组]]></title>
      <url>http://sanfordy.com/2016/08/01/%E3%80%96A%E3%80%97%E3%80%901-0%E3%80%91C-%E8%AF%AD%E6%B3%95/%E3%80%9013%E3%80%91%E6%95%B0%E7%BB%84/</url>
      <content type="html"><![CDATA[<blockquote>
<p>定义数组时，系统将按照数组类型和个数分配一段连续的存储空间来存储数组元素，如int a[3]占据了连续的6字节存储空间（在16位编译器环境下，一个int类型占用2个字节）。要注意的是，数组名代表着整个数组的地址，也就是数组的起始地址。</p>
</blockquote>
<a id="more"></a>
<h2 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h2><p>为了让大家更好地学习和理解数组，我们先来认识一下内存中的”地址”。计算机中的内存是以字节为单位的存储空间。内存的每一个字节都有一个唯一的编号，这个编号就称为地址。凡存放在内存中的程序和数据都有一个地址，也就是说，一个函数也有自己的内存地址。</p>
<p>当定义一个变量时，系统就分配一个带有唯一地址的存储单元来存储这个变量，比如：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a = <span class="string">'A'</span>; <span class="comment">// A的ASCII值为65</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> b = <span class="number">66</span>;</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>在16bit编译器环境下，系统为a、b分别分配1个字节、2个字节的存储单元。变量存储单元的第一个字节的地址就是该变量的地址：<br><img src="http://images2015.cnblogs.com/blog/776348/201608/776348-20160809182257637-1614323130.png" alt=""><br>可以看出，变量a的地址是ffc3；变量b的地址是ffc1。内存中存储的都是2进制数据。</li>
</ul>
<p>在调试过程中，我们采取打印的方式查看变量的地址：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> c = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以16进制形式输出地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"16进制:%x\n"</span>, &amp;c);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以10进制形式输出地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"10进制:%d\n"</span>, &amp;c);</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">16进制:5fbff7ec</span><br><span class="line">10进制:1606416364</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<h2 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h2><h3 id="一维数组的定义"><a href="#一维数组的定义" class="headerlink" title="一维数组的定义"></a>一维数组的定义</h3><p>定义的形式为：类型  数组名[元素个数]。</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>];</span><br></pre></td></tr></table></figure>
<p>[]只能放在数组名的后面，下面的都是错误写法：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[<span class="number">5</span>] a; <span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">int</span>[] b; <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure>
<p>[]里面的个数必须是一个固定值，可以是常量（比如6、8）、常量表达式（比如3+4、5*7）。绝对不能使用变量或者变量表达式来表示元素个数，大多数情况下不要省略元素个数（当数组作为函数的形参和数组初始化时除外）：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  下面的都是正确写法  //</span></span><br><span class="line"><span class="keyword">int</span>  a[<span class="number">5</span>];   <span class="comment">// 整型常量</span></span><br><span class="line"><span class="keyword">int</span>  b[<span class="string">'A'</span>];  <span class="comment">// 字符常量，其实就是65</span></span><br><span class="line"><span class="keyword">int</span>  c[<span class="number">3</span>*<span class="number">4</span>];  <span class="comment">// 整型常量表达式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  下面的都是错误写法  //</span></span><br><span class="line"><span class="keyword">int</span> a[]; <span class="comment">// 没有指定元素个数，错误</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">int</span> a[i]; <span class="comment">// 用变量做元素个数，错误</span></span><br></pre></td></tr></table></figure>
<h3 id="一维数组的存储"><a href="#一维数组的存储" class="headerlink" title="一维数组的存储"></a>一维数组的存储</h3><p>定义数组时，系统将按照数组类型和个数分配一段连续的存储空间来存储数组元素，如int a[3]占据了连续的6字节存储空间（在16位编译器环境下，一个int类型占用2个字节）。要注意的是，数组名代表着整个数组的地址，也就是数组的起始地址：</p>
<p><img src="http://images2015.cnblogs.com/blog/776348/201608/776348-20160809214541777-1132269344.png" alt=""></p>
<p>数组a的地址是ffc1，a[0]的地址是ffc1，a[1]的地址是ffc3，a[2]的地址是ffc5。因此a == &amp;a[0]，即第一个元素的地址就是整个数组的地址。</p>
<blockquote>
<p><strong>注意</strong>：其实a不算是变量，是个常量，它代表着数组的地址。上图把a放到变量一栏是为了方便大家理解数组结构。</p>
</blockquote>
<h3 id="一维数组的初始化"><a href="#一维数组的初始化" class="headerlink" title="一维数组的初始化"></a>一维数组的初始化</h3><p>初始化的一般形式是：类型  数组名[元素个数] = {元素1, 元素2, …};</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">2</span>] = &#123;<span class="number">8</span>, <span class="number">10</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>元素值列表可以是数组所有元素的初值，也可以是前面部分元素的初值：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">4</span>] = &#123;<span class="number">2</span>, <span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>当数组为整型时，初始化未确定初值的元素，默认为0，所以上面的a[2]、a[3]都为0。</li>
</ul>
<p>当对全部数组元素都赋初值时，可以省略元素个数：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">2</span>, <span class="number">5</span>, <span class="number">7</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>说明数组a的元素个数是3。</li>
</ul>
<p>数组初始化时的赋值方式只能用于数组的定义，定义之后只能一个元素一个元素地赋值：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>];</span><br><span class="line">a[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; <span class="comment">// 错误</span></span><br><span class="line">a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>第2行的a[3]代表着访问数组的第4个元素，首先这里已经是数组下标越界了；就算没有越界，给a[3]赋值时也应该赋一个int类型的整数，不应该是{}。</li>
<li>第3行的a是数组名，代表着数组的地址，它是个常量！给常量赋值，那肯定错了！</li>
</ul>
<h3 id="一维数组与函数参数"><a href="#一维数组与函数参数" class="headerlink" title="一维数组与函数参数"></a>一维数组与函数参数</h3><p>一维数组的元素作为函数实参，与同类型的简单变量作为实参一样，是单向的值传递，即数组元素的值传给形参，形参的改变不影响实参：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// b是test函数的形参(形式参数)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    b = <span class="number">9</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">3</span>];</span><br><span class="line">    a[<span class="number">0</span>] = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"函数调用前的a[0]：%d\n"</span>, a[<span class="number">0</span>]);</span><br><span class="line">    </span><br><span class="line">    test(a[<span class="number">0</span>]); <span class="comment">// a[0]是test函数的实参(实际参数)</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"函数调用后的a[0]：%d\n"</span>, a[<span class="number">0</span>]);</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">函数调用前的a[0]：10</span><br><span class="line">函数调用后的a[0]：10</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<p>大家都知道，数组名代表着整个数组的地址，如果一维数组的名字作为函数实参，传递的是整个数组，即形参数组和实参数组完全等同，是存放在同一存储空间的同一个数组。这样形参数组修改时，实参数组也同时被修改了。形参数组的元素个数可以省略：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">// b是test函数的形参(形式参数)</span><br><span class="line">void test(int b[]) &#123; // 也可以写int b[3]</span><br><span class="line">    b[0] = 9;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a[3];</span><br><span class="line">    a[0] = 10;</span><br><span class="line">    </span><br><span class="line">    printf(&quot;函数调用前的a[0]：%d\n&quot;, a[0]);</span><br><span class="line">    </span><br><span class="line">    test(a); // a是test函数的实参(实际参数)</span><br><span class="line">    </span><br><span class="line">    printf(&quot;函数调用后的a[0]：%d\n&quot;, a[0]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">函数调用前的a[0]：10</span><br><span class="line">函数调用后的a[0]：9</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><h3 id="二维数组的定义"><a href="#二维数组的定义" class="headerlink" title="二维数组的定义"></a>二维数组的定义</h3><p>定义形式：类型  数组名[行数][列数];</p>
<h3 id="二维数组的存储"><a href="#二维数组的存储" class="headerlink" title="二维数组的存储"></a>二维数组的存储</h3><p>C语言把二维数组当作是一维数组的集合，即二维数组是一个特殊的一维数组：它的元素是一维数组。例如int a[2][3]可以看作由一维数组a[0]和一维数组a[1]组成，这两个一维数组都包含了3个int类型的元素：</p>
<p><img src="http://images2015.cnblogs.com/blog/776348/201608/776348-20160809215946137-1142619093.png" alt=""></p>
<p>二维数组的存放顺序是按行存放的，先存放第一行的元素，再存放第2行的元素。例如int a[2][3]的存放顺序是：a[0][0] → a[0][1] → a[0][2] → a[1][0] → a[1][1] → a[1][2]。</p>
<p>再来看看在内存中的存储情况，例如int a[2][2]：</p>
<p><img src="http://images2015.cnblogs.com/blog/776348/201608/776348-20160809215954371-182260266.png" alt=""></p>
<ul>
<li>a[0]、a[1]也是数组，是一维数组，而且a[0]、a[1]就是数组名，因此a[0]、a[1]就代表着这个一维数组的地址。</li>
<li>数组a的地址是ffc1，数组a[0]的地址也是ffc1，即a = a[0]；</li>
<li>元素a[0][0]的地址是ffc1，所以数组a[0]的地址和元素a[0][0]的地址相同，即a[0] = &amp;a[0][0]；</li>
<li>最终可以得出结论：a = a[0] = &amp;a[0][0]，以此类推，可以得出a[1] = &amp;a[1][0]</li>
</ul>
<h3 id="二维数组的初始化"><a href="#二维数组的初始化" class="headerlink" title="二维数组的初始化"></a>二维数组的初始化</h3><p>按行进行初始化：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">2</span>][<span class="number">3</span>] = &#123; &#123;<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125; &#125;;</span><br></pre></td></tr></table></figure>
<p>按存储顺序进行初始化（先存放第1行，再存放第2行）：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">2</span>][<span class="number">3</span>] = &#123;<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>对部分元素进行初始化：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">2</span>][<span class="number">3</span>] = &#123; &#123;<span class="number">2</span>&#125;, &#123;<span class="number">3</span>, <span class="number">4</span>&#125; &#125;;</span><br><span class="line"><span class="keyword">int</span> b[<span class="number">3</span>][<span class="number">3</span>] = &#123; &#123; &#125;, &#123; , , <span class="number">2</span>&#125;, &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>
<p>如果只初始化了部分元素，可以省略行数，但是不可以省略列数：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[][<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a[][<span class="number">3</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">3</span>, <span class="number">5</span>&#125;, &#123;&#125;&#125;;</span><br></pre></td></tr></table></figure>
<p>有些人可能想不明白，为什么可以省略行数，但不可以省略列数。也有人可能会问，可不可以只指定行数，但是省略列数？其实这个问题很简单，如果我们这样写：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">2</span>][] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;; <span class="comment">// 错误写法</span></span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>大家都知道，二维数组会先存放第1行的元素，由于不确定列数，也就是不确定第1行要存放多少个元素，所以这里会产生很多种情况，可能1、2是属于第1行的，也可能1、2、3、4是第一行的，甚至1、2、3、4、5、6全部都是属于第1行的</li>
</ul>
<h3 id="二维数组与函数参数"><a href="#二维数组与函数参数" class="headerlink" title="二维数组与函数参数"></a>二维数组与函数参数</h3><p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span></span><br><span class="line"></span><br><span class="line"></span>&#123;   <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> a1[][<span class="number">3</span>])</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">23</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line">    <span class="comment">//  把二维数组名a传递给a1.</span></span><br><span class="line">    f(a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a[1][2]：%d\n"</span>,a[<span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  a1[][3]在第二维大小相同的前提下，形参数组的第一位可以与实参数组不同，例如实参为a[3][3]，形参可以为a[6][3]，a[111][3].</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> a1[][<span class="number">3</span>])</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    a1[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">4</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a[1][2]：4</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<h2 id="字符数组"><a href="#字符数组" class="headerlink" title="字符数组"></a>字符数组</h2><p>字符数组用于存放字符变量的数组称为字符数组。</p>
<p>字符数组属于⼀维数组，定义方式与普通一维数组相似，只是类型是char。 字符数组的定义: </p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">￼<span class="keyword">char</span> c[<span class="number">10</span>] = &#123;‘i’ , ‘P’ , ‘h’ , ‘o’ , ‘n’ , ‘e’&#125;; </span><br><span class="line"><span class="keyword">char</span> c[<span class="number">10</span>] = “iPhone” ;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：有‘\0’结束标识的字符数组也称为字符串。</p>
</blockquote>
<h2 id="字符串数组"><a href="#字符串数组" class="headerlink" title="字符串数组"></a>字符串数组</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>字符串数组本质上是二维字符数组。</p>
<p>一维字符数组中存放一个字符串，比如一个名字char name[] = “mj”，直接赋值为字符串，此时不需要手动添加\0，编译器会自动添加。</p>
<p>如果要存储多个字符串，比如一个班所有学生的名字，则需要二维字符数组，char names[15][20]可以存放15个学生的姓名(假设姓名不超过20字符)。</p>
<p>如果要存储两个班的学生姓名，那么可以用三维字符数组char names[2][15][20]。</p>
<h3 id="字符串数组的初始化"><a href="#字符串数组的初始化" class="headerlink" title="字符串数组的初始化"></a>字符串数组的初始化</h3><p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">char</span> names[<span class="number">2</span>][<span class="number">10</span>] = &#123; &#123;<span class="string">'J'</span>,<span class="string">'a'</span>,<span class="string">'y'</span>,<span class="string">'\0'</span>&#125;, &#123;<span class="string">'J'</span>,<span class="string">'i'</span>,<span class="string">'m'</span>,<span class="string">'\0'</span>&#125; &#125;;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">char</span> names2[<span class="number">2</span>][<span class="number">10</span>] = &#123; &#123;</span><br><span class="line"></span><br><span class="line"><span class="string">"Jay"</span>&#125;, &#123;<span class="string">"Jim"</span>&#125; &#125;;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">char</span> names3[<span class="number">2</span>][<span class="number">10</span>] = &#123; <span class="string">"Jay"</span>, <span class="string">"Jim"</span> &#125;;</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>可以把字符串数组看作是一维数组，它的元素是字符串。字符串数组names由字符串”Jay”和字符串”Jim”构成。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.cnblogs.com/mjios/" target="_blank" rel="external">M了个J的博客</a></p>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[【12】基本运算]]></title>
      <url>http://sanfordy.com/2016/08/01/%E3%80%96A%E3%80%97%E3%80%901-0%E3%80%91C-%E8%AF%AD%E6%B3%95/%E3%80%9012%E3%80%91%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97/</url>
      <content type="html"><![CDATA[<blockquote>
<p>计算机的基本能力就是计算，所以一门程序设计语言的计算能力是非常重要的。C语言之所以无所不能，是因为它不仅有丰富的数据类型，还有强大的计算能力。C语言一共有34种运算符，包括了常见的加减乘除运算。这讲就对C语言中的运算符做一个详细介绍。</p>
</blockquote>
<a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>计算机的基本能力就是计算，所以一门程序设计语言的计算能力是非常重要的。C语言之所以无所不能，是因为它不仅有丰富的数据类型，还有强大的计算能力。C语言一共有34种运算符，包括了常见的加减乘除运算。这讲就对C语言中的运算符做一个详细介绍。</p>
<h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><p>算术运算符非常地简单，就是小学数学里面的一些加减乘除操作。不过呢，还是有一些语法细节需要注意的。</p>
<h3 id="加法运算符："><a href="#加法运算符：" class="headerlink" title="加法运算符：+"></a>加法运算符：+</h3><p>跟平时用的加号一样。</p>
<h3 id="减法运算符-或-负值运算符："><a href="#减法运算符-或-负值运算符：" class="headerlink" title="减法运算符 或 负值运算符：-"></a>减法运算符 或 负值运算符：-</h3><p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> b = <span class="number">10</span> - <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">-10</span>;</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>在第1行利用减法运算符 - 进行了减法运算，再将差赋值给了变量b，最终变量b的值是5。</li>
<li>在第3行中，这个 - 并不是什么减法运算符，而算是一个负值运算符，-10代表的是负十。</li>
</ul>
<h3 id="乘法运算符："><a href="#乘法运算符：" class="headerlink" title="乘法运算符：*"></a>乘法运算符：*</h3><p>&lt; 代码示例 &gt; </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> b = <span class="number">10</span> * <span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>乘法运算符并不是x或者X，而是星号*。变量b最终的值是50。</li>
</ul>
<h3 id="除法运算符："><a href="#除法运算符：" class="headerlink" title="除法运算符：/"></a>除法运算符：/</h3><p>除法运算符并不是÷，而是一个正斜杠 /。</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> a = <span class="number">10.0</span> / <span class="number">4</span>;</span><br><span class="line"><span class="keyword">double</span> b = <span class="number">10</span> / <span class="number">4</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"a=%f, b=%f \n"</span>, a, b);</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a=2.500000, b=2.000000 </span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>第1行中的10.0是浮点型，4是整型，因此会将4自动类型提升为浮点型后再进行运算，最后变量b的值是2.5。</li>
<li>第2行中的10和4都是整型，计算机中的运算有个原则：相同数据类型的值才能进行运算，而且运算结果依然是同一种数据类型。因此，整数除于整数，求出来的结果依然是整数，会损失小数部分。</li>
<li>如果想让整数除于整数不损失精度的话，可以将某个整数强制转换为浮点型数据。</li>
</ul>
<h3 id="模运算符-或称-取余运算符："><a href="#模运算符-或称-取余运算符：" class="headerlink" title="模运算符 或称 取余运算符：%"></a>模运算符 或称 取余运算符：%</h3><p>这个%并不是除号÷，它是一个取余运算符，或者叫做模运算符。取余的意思是，取得两个整数相除之后的余数。比如，5除于2的余数是1，5除于3的余数是2。因此使用这个%有个原则：%两侧必须都为整数。下面的写法是错误的：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5.0</span> % <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>编译器会直接报错，因为5.0并非整数。</li>
</ul>
<h4 id="正数取余"><a href="#正数取余" class="headerlink" title="正数取余"></a>正数取余</h4><p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span> % <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span> % <span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>简单计算可得：变量a的值为1，变量b的值为2。</li>
</ul>
<h4 id="负数取余"><a href="#负数取余" class="headerlink" title="负数取余"></a>负数取余</h4><p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">-5</span> % <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">5</span> % <span class="number">-2</span>;</span><br><span class="line"><span class="keyword">int</span> c = <span class="number">-5</span> % <span class="number">-2</span>;</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>利用%求出来的余数是正数还是负数，由%左边的被除数决定，被除数是正数，余数就是正数，反之则反。因此变量a、b、c的值分别是-1、1、-1。</li>
</ul>
<h3 id="运算顺序"><a href="#运算顺序" class="headerlink" title="运算顺序"></a>运算顺序</h3><h4 id="算术表达式"><a href="#算术表达式" class="headerlink" title="算术表达式"></a>算术表达式</h4><p>用算术运算符将数据连接起来的式子，称为“算术表达式”。比如a + b、10 * 5等。如果表达式比较复杂的话，那么就要注意一下它的运算顺序。表达式的运算顺序是按照运算符的结合方向和优先级进行的。</p>
<h4 id="结合方向"><a href="#结合方向" class="headerlink" title="结合方向"></a>结合方向</h4><p>算术运算符的结合方向是从左到右。例如表达式2+3+4，先计算2+3。</p>
<h4 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h4><p>优先级越高，就越先进行运算，当优先级相同时，参照结合方向。</p>
<p>算术运算符的优先级排序：负值运算符（-）&gt; 乘（*）、除（/）、模（%）运算符 &gt; 加（+）、减（-）运算符。</p>
<h4 id="小括号"><a href="#小括号" class="headerlink" title="小括号"></a>小括号</h4><p>如果需要先计算优先级低的可以使用小括号()括住，小括号的优先级是最高的！</p>
<h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><p>赋值运算符又分两种：简单赋值运算符 和 复合赋值运算符。</p>
<h3 id="简单赋值运算符："><a href="#简单赋值运算符：" class="headerlink" title="简单赋值运算符：="></a>简单赋值运算符：=</h3><h4 id="简单用法"><a href="#简单用法" class="headerlink" title="简单用法"></a>简单用法</h4><p>其实这个等号 = 从讲变量开始就见过它了，它的作用是将右边的值赋值给左边。</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int a = 10 + 5;</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>赋值运算符的结合方向是：从右到左，而且优先级比算术运算符低。因此先进行等号=右边的加法运算，运算完毕后再将结果赋值给等号右边的变量。最后变量a的值是15。</li>
</ul>
<h4 id="连续赋值"><a href="#连续赋值" class="headerlink" title="连续赋值"></a>连续赋值</h4><p>&lt; 代码示例 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> int a, b;</span><br><span class="line"> </span><br><span class="line">a = b = 10;</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>在第1行分别定义了int类型的变量a、b。</li>
<li>第3行代码的意思：将10赋值给变量b，再把变量b的值赋值给a。所以最后变量a、b的值都是10。</li>
</ul>
<h4 id="使用注意"><a href="#使用注意" class="headerlink" title="使用注意"></a>使用注意</h4><p>等号=左边只能是变量，不能是常量！常量都是不可变的，怎么可以再次赋值呢？下面的写法是错误的：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span> = <span class="number">10</span> + <span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<h3 id="复合赋值运算符"><a href="#复合赋值运算符" class="headerlink" title="复合赋值运算符"></a>复合赋值运算符</h3><p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a += <span class="number">3</span>+<span class="number">2</span>  <span class="comment">//  等价于 a = a +（3+2）。</span></span><br><span class="line">a -= <span class="number">3</span>+<span class="number">2</span>，<span class="comment">//  等价于 a = a -（3+2）。</span></span><br><span class="line">a *= <span class="number">3</span>+<span class="number">2</span>，<span class="comment">//  等价于 a = a *（3+2）。</span></span><br><span class="line">a /= <span class="number">3</span>+<span class="number">2</span>，<span class="comment">//  等价于 a = a /（3+2）。</span></span><br><span class="line">a %= <span class="number">3</span>+<span class="number">2</span>，<span class="comment">//  等价于 a = a %（3+2）。</span></span><br></pre></td></tr></table></figure>
<h2 id="自增自减运算符"><a href="#自增自减运算符" class="headerlink" title="自增自减运算符"></a>自增自减运算符</h2><p>自增自减运算符都只能用于变量，你写个5++是错误的，因为5是常量。</p>
<h3 id="自增运算符："><a href="#自增运算符：" class="headerlink" title="自增运算符：++"></a>自增运算符：++</h3><p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a++; <span class="comment">//  等价于 a = a+1;</span></span><br><span class="line">++a; <span class="comment">//  等价于 a = a+1;</span></span><br></pre></td></tr></table></figure>
<h3 id="自减运算符：–"><a href="#自减运算符：–" class="headerlink" title="自减运算符：–"></a>自减运算符：–</h3><p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a--; <span class="comment">//  等价于 a = a-1;</span></span><br><span class="line">--a; <span class="comment">//  等价于 a = a-1;</span></span><br></pre></td></tr></table></figure>
<h3 id="a和a-的区别"><a href="#a和a-的区别" class="headerlink" title="++a和a++的区别"></a>++a和a++的区别</h3><p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> b = ++a;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> b = a++;</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>第1段代码：++a的意思是先对a执行+1操作，再将a的值赋值给b。因此最后a、b的值都是11。</li>
<li>第2段代码：a++的意思是先将a的值拷贝出来一份，然后对a执行+1操作，于是a变成了11，但是拷贝出来的值还是10，a++运算完毕后，再将拷贝出来的值10赋值给了b，所以最后变量b的值是10，变量a的值是11。</li>
</ul>
<blockquote>
<p><strong>注意</strong>：自减运算符也是一样的区别。</p>
</blockquote>
<p>再来看一个比较刁钻的例子：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line"> a = a++;</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>很多人一眼看上去，觉得最后a的值应该是11，其实最后a的值是10。前面已经说过a++的作用了，这里也是一样的。先将a的值拷贝出来一份，然后对a执行+1操作，于是a变成了11，但是拷贝出来的值还是10，a++运算完毕后，再将拷贝出来的值10赋值给了a，所以最后变量a的值是10。</li>
</ul>
<h2 id="逗号运算符"><a href="#逗号运算符" class="headerlink" title="逗号运算符"></a>逗号运算符</h2><p>逗号运算符“,”主要用于连接表达式，用逗号运算符连接起来的表达式称为逗号表达式。它的一般形式为：表达式1, 表达式2, … …, 表达式n。</p>
<p>逗号表达式的运算过程是：从左到右的顺序，先计算表达式1，接着计算表达式2，…，最后计算表达式n，整个逗号表达式的值是最后一个表达式的值：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> c;</span><br><span class="line"></span><br><span class="line">c = (++a, a *= <span class="number">2</span>, b = a / <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"c = %d"</span>, c);</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c = 2</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>++a的结果为3，a *= 2的结果为6，b = a / 3的结果为2。</li>
</ul>
<p>这里要注意的是，右边的表达式是有用括号()包住的，如果不用括号包住，也就是：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c = ++a, a *= <span class="number">2</span>, b = a / <span class="number">3</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"c = %d"</span>, c);</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c = 3</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>因为c = ++a也属于逗号表达式的一部分，跟后面的a *= 2以及b = a / 3是相互独立的。</li>
</ul>
<h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><h3 id="“真”与“假”"><a href="#“真”与“假”" class="headerlink" title="“真”与“假”"></a>“真”与“假”</h3><p>默认情况下，我们在程序中写的每一句正确代码都会被执行。但很多时候，我们想在某个条件成立的情况下才执行某一段代码。比如微信的这个界面：</p>
<p><img src="http://images2015.cnblogs.com/blog/776348/201607/776348-20160731215744731-1017647345.png" alt=""></p>
<p>如果用户点击了注册按钮，我们就执行“跳转到注册界面”的代码；如果用户点击了登录按钮，我们就执行“跳转到登录界面”的代码。如果用户没做出任何操作，就不执行前面所说的两段代码。像这种情况的话可以使用条件语句来完成，但是我们暂时不学习条件语句，先来看一些更基础的知识：如何判断一个条件成不成立。如果这个都不会判断，还执行什么代码。</p>
<p>在C语言中，条件成立称为“真”，条件不成立称为“假”，因此，判断条件是否成立，就是判断条件的“真假”。那怎么判断真假呢？C语言规定，任何非0值都为“真”，只有0才为“假”。也就是说，108、-18、4.5、-10.5等都是“真”，0则是“假”。</p>
<h3 id="关系运算符的简单使用"><a href="#关系运算符的简单使用" class="headerlink" title="关系运算符的简单使用"></a>关系运算符的简单使用</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a&lt;<span class="number">5</span>;<span class="comment">//  小于</span></span><br><span class="line">a&lt;=<span class="number">5</span>;<span class="comment">//  小于等于</span></span><br><span class="line">a&gt;<span class="number">5</span>;<span class="comment">//  大于</span></span><br><span class="line">a&gt;=<span class="number">5</span>;<span class="comment">//  大于等于</span></span><br><span class="line">a==<span class="number">5</span>;<span class="comment">//  等于</span></span><br><span class="line">a!=<span class="number">5</span>;<span class="comment">//  不等于</span></span><br></pre></td></tr></table></figure>
<p>关系运算符的运算结果只有2种：如果条件成立，结果就为1，也就是“真”；如果条件不成立，结果就为0，也就是“假”：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a1 = <span class="number">5</span> &gt; <span class="number">4</span>; <span class="comment">// 1</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">int</span> a2 = <span class="number">5</span> &lt; <span class="number">4</span>; <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<h3 id="关系运算符的使用注意"><a href="#关系运算符的使用注意" class="headerlink" title="关系运算符的使用注意"></a>关系运算符的使用注意</h3><ol>
<li>关系运算符中==、!=的优先级相等，&lt;、&lt;=、&gt;、&gt;=的优先级相等，且前者的优先级低于后者。eg：2==3&gt;1 ：先算3&gt;1，条件成立，结果为1。再计算2==1，条件不成立，结果为0。因此2==3&gt;1的结果为0。</li>
<li>关系运算符的结合方向为“从左往右”。eg：4&gt;3&gt;2 ：先算4&gt;3，条件成立，结果为1。再与2比较，即1&gt;2，条件不成立，结果为0。因此4&gt;3&gt;2的结果为0。</li>
<li>关系运算符的优先级小于算术运算符。eg：3+4&gt;8-2 ：先计算3+4，结果为7。再计算8-2，结果为6。最后计算7&gt;6，条件成立，结果为1。因此3+4&gt;8-2的结果为1。</li>
</ol>
<h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>有时候，我们需要在多个条件同时成立的时候才能执行某段代码，比如：用户只有同时输入了QQ和密码，才能执行登录代码，如果只输入了QQ或者只输入了密码，就不能执行登录代码。这种情况下，我们就要借助于C语言提供的逻辑运算符。</p>
<p>C语言提供了3个逻辑运算符：</p>
<ol>
<li>逻辑与：&amp;&amp;</li>
<li>逻辑或：||</li>
<li>逻辑非：!</li>
</ol>
<blockquote>
<p><strong>注意</strong>：这些都是英文字符，不要写成中文字符。跟关系运算符一样，逻辑运算的结果只有2个：“真”为1，“假”为0</p>
</blockquote>
<h3 id="逻辑与：-amp-amp"><a href="#逻辑与：-amp-amp" class="headerlink" title="逻辑与：&amp;&amp;"></a>逻辑与：&amp;&amp;</h3><h4 id="使用格式"><a href="#使用格式" class="headerlink" title="使用格式"></a>使用格式</h4><p>“条件A &amp;&amp; 条件B”</p>
<h4 id="运算结果"><a href="#运算结果" class="headerlink" title="运算结果"></a>运算结果</h4><p>只有当条件A和条件B都成立时，结果才为1，也就是“真”；其余情况的结果都为0，也就是“假”。因此，条件A或条件B只要有一个不成立，结果都为0，也就是“假”</p>
<h4 id="运算过程"><a href="#运算过程" class="headerlink" title="运算过程"></a>运算过程</h4><p>总是先判断条件A是否成立。如果条件A成立，接着再判断条件B是否成立：如果条件B成立，“条件A &amp;&amp; 条件B”的结果就为1，即“真”，如果条件B不成立，结果就为0，即“假”。如果条件A不成立，就不会再去判断条件B是否成立：因为条件A已经不成立了，不管条件B如何，“条件A &amp;&amp; 条件B”的结果肯定是0，也就是“假”。</p>
<h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p>逻辑与的结合方向是“自左至右”。比如表达式 (a&gt;3) &amp;&amp; (a&lt;5)：</p>
<ol>
<li>若a的值是4：先判断a&gt;3，成立；再判断a&lt;5，也成立。因此结果为1</li>
<li>若a的值是2：先判断a&gt;3，不成立，停止判断。因此结果为0</li>
<li>因此，如果a的值在(3, 5)这个范围内，结果就为1；否则，结果就为0</li>
</ol>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>若想判断a的值是否在(3, 5)范围内，千万不能写成3<a<5，因为关系运算符的结合方向为“从左往右”。比如a为2，它会先算3<a，也就是3<2，条件不成立，结果为0。再与5比较，即0<5，条件成立，结果为1。因此3<a<5的结果为1，条件成立，也就是说当a的值为2时，a的值是在(3, 5)范围内的。这明显是不对的。正确的判断方法是：(a="">3) &amp;&amp; (a&lt;5)。</a<5，因为关系运算符的结合方向为“从左往右”。比如a为2，它会先算3<a，也就是3<2，条件不成立，结果为0。再与5比较，即0<5，条件成立，结果为1。因此3<a<5的结果为1，条件成立，也就是说当a的值为2时，a的值是在(3,></p>
<p>C语言规定：任何非0值都为“真”，只有0才为“假”。因此逻辑与也适用于数值。比如 5 &amp;&amp; 4的结果是1，为“真”；-6 &amp;&amp; 0的结果是0，为“假”。</p>
<h3 id="逻辑或："><a href="#逻辑或：" class="headerlink" title="逻辑或：||"></a>逻辑或：||</h3><h4 id="使用格式-1"><a href="#使用格式-1" class="headerlink" title="使用格式"></a>使用格式</h4><p>“条件A || 条件B”</p>
<h4 id="运算结果-1"><a href="#运算结果-1" class="headerlink" title="运算结果"></a>运算结果</h4><p>当条件A或条件B只要有一个成立时（也包括条件A和条件B都成立），结果就为1，也就是“真”；只有当条件A和条件B都不成立时，结果才为0，也就是“假”。</p>
<h4 id="运算过程-1"><a href="#运算过程-1" class="headerlink" title="运算过程"></a>运算过程</h4><p>总是先判断条件A是否成立。如果条件A成立，就不会再去判断条件B是否成立：因为条件A已经成立了，不管条件B如何，“条件A || 条件B”的结果肯定是1，也就是“真”。如果条件A不成立，接着再判断条件B是否成立：如果条件B成立，“条件A || 条件B”的结果就为1，即“真”，如果条件B不成立，结果就为0，即“假”。</p>
<h4 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h4><p>逻辑或的结合方向是“自左至右”，比如表达式 (a<3) ||="" (a="">5)。</3)></p>
<ol>
<li>若a的值是4：先判断a<3，不成立；再判断a>5，也不成立。因此结果为0</3，不成立；再判断a></li>
<li>若a的值是2：先判断a&lt;3，成立，停止判断。因此结果为1</li>
<li>因此，如果a的值在(-∞, 3)或者(5, +∞)范围内，结果就为1；否则，结果就为0</li>
</ol>
<h4 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h4><p>C语言规定：任何非0值都为“真”，只有0才为“假”。因此逻辑或也适用于数值。比如 5 || 4的结果是1，为“真”；-6 || 0的结果是1，为“真”；0 || 0的结果是0，为“假”。</p>
<h3 id="逻辑非："><a href="#逻辑非：" class="headerlink" title="逻辑非：!"></a>逻辑非：!</h3><h4 id="使用格式-2"><a href="#使用格式-2" class="headerlink" title="使用格式"></a>使用格式</h4><p>“! 条件A”</p>
<h4 id="运算结果-2"><a href="#运算结果-2" class="headerlink" title="运算结果"></a>运算结果</h4><p>其实就是对条件A进行取反：若条件A成立，结果就为0，即“假”；若条件A不成立，结果就为1，即“真”。也就是说：真的变假，假的变真。</p>
<h4 id="举例-2"><a href="#举例-2" class="headerlink" title="举例"></a>举例</h4><p>逻辑非的结合方向是“自右至左”。比如表达式 ! (a&gt;5)</p>
<ol>
<li>若a的值是6：先判断a&gt;5，成立，再取反之后的结果为0</li>
<li>若a的值是2：先判断a&gt;3，不成立，再取反之后的结果为1</li>
<li>因此，如果a的值大于5，结果就为0；否则，结果就为1</li>
</ol>
<h4 id="注意-2"><a href="#注意-2" class="headerlink" title="注意"></a>注意</h4><p>可以多次连续使用逻辑非运算符：!(4&gt;2)结果为0，是“假”，!!(4&gt;2)结果为1，是“真”，!!!(4&gt;2)结果为0，是“假”</p>
<p>C语言规定：任何非0值都为“真”，只有0才为“假”。因此，对非0值进行逻辑非!运算的结果都是0，对0值进行逻辑非!运算的结果为1。!5、!6.7、!-9的结果都为0，!0的结果为1</p>
<h3 id="优先级-1"><a href="#优先级-1" class="headerlink" title="优先级"></a>优先级</h3><p>逻辑运算符的优先级顺序为： 小括号() &gt; 负号 - &gt; ! &gt; 算术运算符 &gt; 关系运算符 &gt; &amp;&amp; &gt; ||。</p>
<p>表达式!(3&gt;5) || (2<4) &&="" (6<1)="" ：先计算="" !(3="">5)、(2&lt;4)、(6&lt;1)，结果为1，式子变为1 || 1 &amp;&amp; 0，再计算1 &amp;&amp; 0，式子变为1 || 0，最后的结果为1。</4)></p>
<p>表达式3+2<5||6>3 等价于 ((3+2) &lt; 5) || (6&gt;3)，结果为1。</5||6></p>
<p>表达式4&gt;3 &amp;&amp; !-5&gt;2 等价于 (4&gt;3) &amp;&amp;  ((!(-5)) &gt; 2) ，结果为0。</p>
<h2 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h2><p>C语言提供了唯一一个三目运算符：条件运算符。</p>
<h3 id="使用格式-3"><a href="#使用格式-3" class="headerlink" title="使用格式"></a>使用格式</h3><p>表达式A ? 表达式B : 表达式C</p>
<h3 id="运算结果-3"><a href="#运算结果-3" class="headerlink" title="运算结果"></a>运算结果</h3><p>如果表达式A成立，也就是为“真”，条件运算符的结果就是表达式B的值，否则，就为表达式C的值</p>
<h3 id="结合方向和优先级"><a href="#结合方向和优先级" class="headerlink" title="结合方向和优先级"></a>结合方向和优先级</h3><p>优先级顺序为：算术运算符 &gt; 关系运算符 &gt; 条件运算符 &gt; 赋值运算符。</p>
<p>条件运算符的结合方向是“从右至左”。</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>&gt;<span class="number">4</span> ? <span class="number">4</span>+<span class="number">5</span> : <span class="number">5</span>&gt;<span class="number">4</span> ? <span class="number">5</span>+<span class="number">6</span> : <span class="number">6</span>&gt;<span class="number">7</span>+<span class="number">1</span>;</span><br><span class="line"><span class="comment">//  上面的代码等价于：int a = (3&gt;4) ? (4+5) : ( (5&gt;4) ? (5+6) : (6&gt;(7+1)) );</span></span><br><span class="line"><span class="comment">//  简化一下就是：int a = 0 ? 9 : ( 1 ? 11 : 0 );</span></span><br><span class="line"><span class="comment">//  继续简化为：int a = 0 ? 9 : 11;</span></span><br></pre></td></tr></table></figure>
<h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><p>所谓位运算就是对每一个二进制位进行运算。C语言一共提供了6种位运算符，只能对整数进行操作，分别是：<code>&amp;</code>按位与、<code>|</code>按位或、<code>^</code>按位异或、<code>&lt;&lt;</code>左移、<code>&gt;&gt;</code>右移、<code>~</code>取反。</p>
<h3 id="按位与：-amp"><a href="#按位与：-amp" class="headerlink" title="按位与：&amp;"></a>按位与：&amp;</h3><p>使用形式：整数a &amp; 整数b。</p>
<p>功能：整数a和b各对应的二进位相与。只有对应的两个二进位均为1时，结果位才为1，否则为0。参与运算的数以补码方式出现。</p>
<p>举例：比如9&amp;5，其实就是1001&amp;101=1，因此9&amp;5=1。</p>
<p>规律：</p>
<ol>
<li>相同整数相&amp;的结果是整数本身。比如5&amp;5=5。</li>
<li>多个整数相&amp;的结果跟顺序无关。比如5&amp;6&amp;7=5&amp;7&amp;6。</li>
</ol>
<h3 id="按位或："><a href="#按位或：" class="headerlink" title="按位或：|"></a>按位或：|</h3><p>使用形式：整数a | 整数b。</p>
<p>功能：整数a和b各对应的二进位相或。只要对应的二个二进位有一个为1时，结果位就为1，否则为0。参与运算的数以补码方式出现。</p>
<p>举例：比如9|5，其实就是1001|101=1101，因此9|5=13。</p>
<p>规律：</p>
<ol>
<li>相同整数相|的结果是整数本身。比如5|5=5。</li>
<li>多个整数相|的结果跟顺序无关。比如5|6|7=5|7|6。</li>
</ol>
<h3 id="按位异或："><a href="#按位异或：" class="headerlink" title="按位异或：^"></a>按位异或：^</h3><p>使用形式：整数a ^ 整数b。</p>
<p>功能：整数a和b各对应的二进位相异或。当对应的二进位相异（不相同）时，结果为1，否则为0。参与运算的数以补码方式出现。</p>
<p>举例：比如9^5，其实就是1001^101=1100，因此9^5=12。</p>
<p>规律：</p>
<ol>
<li>二进制中，与1相^就会取反，与0相^保持原位。</li>
<li>相同整数相^的结果是0。比如5^5=0。</li>
<li>多个整数相^的结果跟顺序无关。比如5^6^7=5^7^6。因此得出结论：a^b^a = b。</li>
</ol>
<h3 id="取反："><a href="#取反：" class="headerlink" title="取反：~"></a>取反：~</h3><p><code>~</code>为单目运算符，具有右结合性，使用形式：~整数a</p>
<p>功能：对整数a的各二进位进行取反（0变1，1变0）</p>
<p>举例：比如~9，其实就是~(0000 0000 0000 0000 0000 0000 0000 1001)=(1111 1111 1111 1111 1111 1111 1111 0110)，因此~9=-10</p>
<h3 id="左移：-lt-lt"><a href="#左移：-lt-lt" class="headerlink" title="左移：&lt;&lt;"></a>左移：&lt;&lt;</h3><p><code>&lt;&lt;</code>是双目运算符，使用形式：整数a&lt;&lt;正数n。</p>
<p>功能：把整数a的各二进位全部左移n位，高位丢弃，低位补0。左移n位其实就是乘以2的n次方。</p>
<p>举例：3&lt;&lt;4，3本来是0000 0011，左移4位后变成了0011 0000，因此3&lt;&lt;4 = 48 = 3 * 24。</p>
<p>需要注意的是：由于左移是丢弃最高位，0补最低位，所以符号位也会被丢弃，左移出来的结果值可能会改变正负性。</p>
<h3 id="右移：-gt-gt"><a href="#右移：-gt-gt" class="headerlink" title="右移：&gt;&gt;"></a>右移：&gt;&gt;</h3><p><code>&gt;&gt;</code>是双目运算符，使用形式：整数a&gt;&gt;正数n。</p>
<p>功能：把整数a的各二进位全部右移n位，保持符号位不变。右移n位其实就是除以2的n次方。</p>
<p>举例：32&gt;&gt;3，32本来是0010 0000，右移3位后变成了0000 0100，因此32&gt;&gt;3 = 4 = 32 / 23。</p>
<h2 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof"></a>sizeof</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>sizeof可以用来计算一个变量或者一个常量、一种数据类型所占的内存字节数：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> size = <span class="keyword">sizeof</span>(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"10所占的字节数：%d"</span>, size);</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10所占的字节数：4</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>10是int类型的数据，在64bit编译器环境下，int类型需要占用4个字节。</li>
</ul>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>sizeof一共有3种形式。</p>
<h4 id="sizeof-变量-常量"><a href="#sizeof-变量-常量" class="headerlink" title="sizeof( 变量\常量 )"></a>sizeof( 变量\常量 )</h4><p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sizeof</span>(<span class="number">10</span>); </span><br><span class="line"><span class="keyword">char</span> c = <span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">sizeof</span>(c);</span><br></pre></td></tr></table></figure>
<h4 id="sizeof-变量-常量-1"><a href="#sizeof-变量-常量-1" class="headerlink" title="sizeof 变量\常量"></a>sizeof 变量\常量</h4><p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sizeof</span> <span class="number">10</span>; </span><br><span class="line"><span class="keyword">char</span> c = <span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">sizeof</span> c;</span><br></pre></td></tr></table></figure>
<h4 id="sizeof-数据类型"><a href="#sizeof-数据类型" class="headerlink" title="sizeof( 数据类型 )"></a>sizeof( 数据类型 )</h4><p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">float</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：不可以写成sizeof float。</p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.cnblogs.com/mjios/" target="_blank" rel="external">M了个J的博客</a></p>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[【11】流程控制]]></title>
      <url>http://sanfordy.com/2016/07/31/%E3%80%96A%E3%80%97%E3%80%901-0%E3%80%91C-%E8%AF%AD%E6%B3%95/%E3%80%9011%E3%80%91%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</url>
      <content type="html"><![CDATA[<blockquote>
<p>为了方便我们控制程序的运行流程，C语言提供3种流程结构，不同的流程结构可以实现不同的运行流程。这3种流程结构分别是：</p>
<ol>
<li>顺序结构：默认的流程结构。按照书写顺序执行每一条语句。</li>
<li>选择结构：对给定的条件进行判断，再根据判断结果来决定执行哪一段代码。</li>
<li>循环结构：在给定条件成立的情况下，反复执行某一段代码。</li>
</ol>
</blockquote>
<a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="默认的运行流程"><a href="#默认的运行流程" class="headerlink" title="默认的运行流程"></a>默认的运行流程</h3><p>默认情况下，程序的运行流程是这样的：运行程序后，系统会按书写顺序执行程序中的每一行代码。比如下面的程序：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello-1\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello-2\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello-3\n"</span>);</span><br><span class="line">    </span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Hello-1</span><br><span class="line">Hello-2</span><br><span class="line">Hello-3</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<h3 id="其他运行流程"><a href="#其他运行流程" class="headerlink" title="其他运行流程"></a>其他运行流程</h3><p>但很多时候，我们并不想要按照默认的运行流程去走，比如想在某个条件成立的情况下才执行某一段代码，否则不执行。比如微信的这个界面：</p>
<p><img src="http://images2015.cnblogs.com/blog/776348/201607/776348-20160731215744731-1017647345.png" alt=""></p>
<p>如果用户点击了注册按钮，我们就执行“跳转到注册界面”的代码；如果用户点击了登录按钮，我们就执行“跳转到登录界面”的代码。如果用户没做出任何操作，就不执行前面所说的两段代码。要想实现这种功能，那就要学会如何去控制程序的运行流程。</p>
<h3 id="流程结构"><a href="#流程结构" class="headerlink" title="流程结构"></a>流程结构</h3><p>为了方便我们控制程序的运行流程，C语言提供3种流程结构，不同的流程结构可以实现不同的运行流程。这3种流程结构分别是：</p>
<ol>
<li>顺序结构：默认的流程结构。按照书写顺序执行每一条语句。</li>
<li>选择结构：对给定的条件进行判断，再根据判断结果来决定执行哪一段代码。</li>
<li>循环结构：在给定条件成立的情况下，反复执行某一段代码。</li>
</ol>
<p>下面是这3种结构的流程图，大致预览一下即可：</p>
<p><img src="http://images2015.cnblogs.com/blog/776348/201607/776348-20160731215752450-665863719.png" alt=""></p>
<h2 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h2><p>顺序结构是3种结构中最简单的，也是默认的流程结构：程序中的语句是按照书写顺序执行的。在文章开头开始列出的代码段，就是顺序结构，这里就不多介绍了。</p>
<h2 id="选择结构1-if语句"><a href="#选择结构1-if语句" class="headerlink" title="选择结构1-if语句"></a>选择结构1-if语句</h2><h3 id="形式一"><a href="#形式一" class="headerlink" title="形式一"></a>形式一</h3><p>先来看看if语句最简单的形式</p>
<h4 id="语法简介"><a href="#语法简介" class="headerlink" title="语法简介"></a>语法简介</h4><p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( 条件 )</span><br><span class="line">&#123;</span><br><span class="line">    语句<span class="number">1</span>;</span><br><span class="line">    语句<span class="number">2</span>;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>如果if右边小括号()中的条件成立，也就是为“真”时，就会执行第2~6行大括号{}中的语句；如果条件为假，就不执行大括号{}中的语句。这里的if是关键字。</li>
</ul>
<h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">7</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ( a )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"条件a成立\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"a的值为真\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">条件a成立</span><br><span class="line">a的值为真</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>C语言规定所有非0值都为“真”，而a的值是7，因此第3行的条件是成立的，接着就会执行第5、6行代码。</li>
<li>如果将a的值改为0，那么第3行的条件就不成立，就不会执行第5、6行代码。</li>
</ul>
<h4 id="省略大括号"><a href="#省略大括号" class="headerlink" title="省略大括号{}"></a>省略大括号{}</h4><p>如果if后面大括号{}中只有一行代码时，可以省略大括号。形式如下：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( 条件 )</span><br><span class="line">    语句<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>如果条件成立，只会执行if后面的第1条语句；如果条件不成立，就不会执行if后面的第1条语句。</li>
</ul>
<p>省略大括号带来的问题：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( a &gt; <span class="number">9</span> )</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"aaa\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"bbb\n"</span>);</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bbb</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>因为第3行的a&gt;9是不成立的，所以不会执行第4行代码。而第5行代码跟if语句是没有任何联系的，因此，第5行代码照常执行。</li>
<li>由于第5行代码跟if语句是没有任何联系的，所以一般会把代码写成下面这样：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( a &gt; <span class="number">9</span> )</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"aaa"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"bbb"</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>为了保证代码的可读性，不建议省略大括号！！！</li>
</ul>
<h4 id="语句嵌套"><a href="#语句嵌套" class="headerlink" title="语句嵌套"></a>语句嵌套</h4><p>if语句内部是可以嵌套其他if语句的，如下面的例子：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( a &gt; <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a的值大于0\n"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ( a&lt;<span class="number">9</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"a的值小于9"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a的值大于<span class="number">0</span></span><br><span class="line">a的值小于<span class="number">9</span></span><br><span class="line">Program ended with <span class="built_in">exit</span> code: <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>第3行的a&gt;0是成立的，因此会按顺序执行第4~11大括号中的代码。执行到第7行的时候，a&lt;9也是成立的，因此会执行第9行代码。</li>
</ul>
<h3 id="形式二"><a href="#形式二" class="headerlink" title="形式二"></a>形式二</h3><p>if还可以跟关键字else一起使用</p>
<h4 id="语法简介-1"><a href="#语法简介-1" class="headerlink" title="语法简介"></a>语法简介</h4><p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( 条件 ) &#123;</span><br><span class="line">    语句<span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    语句<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>如果条件成立，就会执行if后面大括号{}中的语句；如果条件不成立，就会执行else后面大括号{}中的语句。总之，两个大括号中一定会有1个被执行，而且只能执行的1个。</li>
</ul>
<p>当然，也可以省略大括号，写成下面的格式：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( 条件 )</span><br><span class="line">    语句<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    语句<span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>如果条件成立，就执行if后面的第1条语句；如果条件不成立，就执行else后面的第1条语句。但还是不建议省略大括号{}。</li>
</ul>
<h4 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h4><p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span> ( a==<span class="number">0</span> ) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a等于0"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a不等于0"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a不等于<span class="number">0</span></span><br><span class="line">Program ended with <span class="built_in">exit</span> code: <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>第2行的a==0不成立，所以会执行第5行代码。</li>
</ul>
<h3 id="形式三"><a href="#形式三" class="headerlink" title="形式三"></a>形式三</h3><p>if和else还有一种比较复杂的用法</p>
<h4 id="语法简介-2"><a href="#语法简介-2" class="headerlink" title="语法简介"></a>语法简介</h4><p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( 条件<span class="number">1</span> )</span><br><span class="line">&#123;</span><br><span class="line">    语句<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( 条件<span class="number">2</span> )</span><br><span class="line">&#123;</span><br><span class="line">    语句<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( 条件<span class="number">3</span> )</span><br><span class="line">&#123;</span><br><span class="line">    语句<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    其他语句;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>如果条件1成立，就执行条件1后面大括号{}中的内容：第2~4行</li>
<li>如果条件1不成立，条件2成立，就执行条件2后面大括号{}中的内容：第6~8行</li>
<li>如果条件1、条件2都不成立，条件3成立，就执行条件3后面大括号{}中的内容：第10~12行</li>
<li>第13行的…表示可以有无限个else if</li>
<li>如果所有的条件都不成立，就会执行else后面大括号{}中的内容：第15~17行</li>
</ul>
<blockquote>
<p><strong>注意</strong>：这么多大括号中，只有1个大括号内的代码会被执行。跟之前一样，所有的大括号都可以省略，但是不建议省略。必要的时候，最后面的else那一段（第14~17行）是可以省略的。</p>
</blockquote>
<h4 id="举例-2"><a href="#举例-2" class="headerlink" title="举例"></a>举例</h4><p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span> ( a==<span class="number">0</span> ) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a等于0"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>( a&gt;<span class="number">0</span> ) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a大于0"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a小于0"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a大于0</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>第2行中的a==0不成立，接着会检查第4行。第4行的a&gt;0成立，因此会执行第5行代码。</li>
<li>如果a的值是负数，那么第2、4行的条件都不成立，于是就会执行第7行代码。</li>
</ul>
<h2 id="选择结构2-switch语句"><a href="#选择结构2-switch语句" class="headerlink" title="选择结构2-switch语句"></a>选择结构2-switch语句</h2><h3 id="形式"><a href="#形式" class="headerlink" title="形式"></a>形式</h3><p>先来看看switch语句的使用形式：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(整型表达式)&#123;</span><br><span class="line">    <span class="keyword">case</span> 数值<span class="number">1</span>:</span><br><span class="line">        语句<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> 数值<span class="number">2</span>:</span><br><span class="line">        语句<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    ... ...</span><br><span class="line">    <span class="keyword">case</span> 数值n:</span><br><span class="line">        语句n;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span> :</span><br><span class="line">        语句n+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>当整型表达式的值等于“数值1”时，就会执行“语句1”，后面的break表示退出整个switch语句，也就是直接跳到第16行代码。</li>
<li>当整形表达式的值等于“数值2”时，就会执行“语句2”；后面的以此类推。如果在数值1~数值n中，没有一个值等于整型表达式的值，那么就会执行default中的语句n+1。</li>
<li>由于所有的case后面都有个break，因此执行完任意一个case中的语句后，都会直接退出switch语句。</li>
</ul>
<h3 id="举例-3"><a href="#举例-3" class="headerlink" title="举例"></a>举例</h3><p>&lt; 代码分析 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (a) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"这是一个0"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"这是一个5"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"这是一个10"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"什么也不是"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这是一个10</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>因为a的值刚好等于第10行case后面的10，所以会执行第11行代码，输出结果：</li>
</ul>
<h3 id="break"><a href="#break" class="headerlink" title="break"></a>break</h3><p>break关键字的作用是退出整个switch语句。默认的格式中，每个case后面都有个break，因此执行完case中的语句后，就会退出switch语句。</p>
<p>如果某个case后面没有break，意味着执行完这个case中的语句后，会按顺序执行后面所有case和default中的语句，直到遇到break为止：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (a) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"这是一个0\n"</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"这是一个5\n"</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"这是一个10\n"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"什么也不是\n"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">这是一个<span class="number">0</span></span><br><span class="line">这是一个<span class="number">5</span></span><br><span class="line">这是一个<span class="number">10</span></span><br><span class="line">Program ended with <span class="built_in">exit</span> code: <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>由于变量a的值等于第4行case后面的0，因此肯定会执行第5行代码。</li>
<li>由于case 0中没有break语句，就不会退出switch语句，继续往下执行代码。</li>
<li>由于a的值已经等于第4行case的值，接着不会再判断a的值是否等于其他case的值了，直接按顺序执行第7、9行代码。在第10行有个break，接着就会退出switch语句。</li>
</ul>
<h3 id="在case中定义变量"><a href="#在case中定义变量" class="headerlink" title="在case中定义变量"></a>在case中定义变量</h3><p>有时候，我们可能会想在case中定义一些变量，这个时候，就必须用大括号{}括住case中的所有语句：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> op = <span class="string">'-'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (op)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = a + b;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"a+b=%d\n"</span>, sum);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> minus = a - b;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"a-b=%d\n"</span>, minus);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"不能识别的符号"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a-b=<span class="number">6</span></span><br><span class="line">Program ended with <span class="built_in">exit</span> code: <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h2 id="循环结构1-while循环"><a href="#循环结构1-while循环" class="headerlink" title="循环结构1-while循环"></a>循环结构1-while循环</h2><p>while通常用于不知道循环次数的循环。</p>
<h3 id="形式-1"><a href="#形式-1" class="headerlink" title="形式"></a>形式</h3><p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ( 条件 )</span><br><span class="line">&#123;</span><br><span class="line">    语句<span class="number">1</span>;</span><br><span class="line">    语句<span class="number">2</span>;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>如果条件成立，就会执行循环体中的语句（“循环体”就是while后面大括号{}中的内容）。然后再次判断条件，重复上述过程，直到条件不成立就结束while循环</li>
<li>while循环的特点：如果while中的条件一开始就不成立，那么循环体中的语句永远不会被执行</li>
</ul>
<p>可以省略大括号{}，但是只会影响到while后面的第一条语句。不建议省略大括号：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ( 条件 )</span><br><span class="line">    语句<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<h3 id="举例-4"><a href="#举例-4" class="headerlink" title="举例"></a>举例</h3><p>在屏幕上重复输出10次Hello World，每输出一次的换行：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ( count &lt; <span class="number">10</span> )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello World\n"</span>);</span><br><span class="line">   </span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>如果省略第6行的count++，count就一直是0，那么count&lt;10一直都是成立的，这个while循环将会陷入“死循环”，一直在重复执行第4行代码。</li>
</ul>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>如果写成下面这样，也会让程序进入“死循环”：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ( count &lt; <span class="number">10</span> );</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello World\n"</span>);</span><br><span class="line">    </span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>注意第3行，while后面不小心加了个分号; ，一个分号表示一条空语句。</li>
<li>可以看出：while循环只会影响到第3行的空语句，而第4~8行的代码块是不受while循环影响的</li>
<li>由于count是0，那么count&lt;10一直都是成立的，程序将会一直重复执行第3行的空语句，陷入死循环。</li>
</ul>
<h2 id="循环结构2-do-while循环"><a href="#循环结构2-do-while循环" class="headerlink" title="循环结构2-do while循环"></a>循环结构2-do while循环</h2><p>do…while不是特别常用，通常用于需要先执行一次的循环。形式如下：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    语句<span class="number">1</span>;</span><br><span class="line">    语句<span class="number">2</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">while</span> (条件);</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>注意第5行，后面是加上一个分号;的。</li>
<li>当执行到do-while循环时，首先会执行一遍循环体中的语句（“循环体”就是do后面大括号{}中的内容）。接着判断while中的条件，如果条件成立，就执行循环体中的语句。然后再次判断条件，重复上述过程，直到条件不成立就结束while循环。</li>
<li>do-while循环的特点：不管while中的条件是否成立，循环体中的语句至少会被执行一遍。</li>
<li>其实do while循环的用法跟while循环是差不多的，这里就不举例子了。</li>
</ul>
<h2 id="循环结构3-for循环"><a href="#循环结构3-for循环" class="headerlink" title="循环结构3-for循环"></a>循环结构3-for循环</h2><p>for最常用，通常用于知道循环次数的循环。 </p>
<h3 id="形式-2"><a href="#形式-2" class="headerlink" title="形式"></a>形式</h3><p>for循环是所有循环结构中最复杂的：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (语句<span class="number">1</span>; 条件; 语句<span class="number">2</span>) &#123;</span><br><span class="line">    语句<span class="number">3</span>;</span><br><span class="line">    语句<span class="number">4</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>for循环开始时，会先执行语句1，而且在整个循环过程中只执行一次语句1。</li>
<li>接着判断条件，如果条件成立，就会执行循环体中的语句（“循环体”就是for后面大括号{}中的内容）。</li>
<li>循环体执行完毕后，接下来会执行语句2，然后再次判断条件，重复上述过程，直到条件不成立就结束for循环。</li>
</ul>
<h3 id="举例-5"><a href="#举例-5" class="headerlink" title="举例"></a>举例</h3><p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">5</span>; i++)</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"%d  "</span>, i);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span> </span><br><span class="line">Program ended with <span class="built_in">exit</span> code: <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>需要注意的是：变量i的作用域是第1~4行。一旦离开了这个for循环，变量i就失效了。</li>
</ul>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>如果for循环的初始化语句和循环一次后执行的语句是由多条语句组成的，就用逗号,隔开：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>, y =<span class="number">0</span>; x&lt;<span class="number">3</span>; x++, y+=<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"x=%d, y=%d \n"</span>, x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="number">0</span>, y=<span class="number">0</span> </span><br><span class="line">x=<span class="number">1</span>, y=<span class="number">2</span> </span><br><span class="line">x=<span class="number">2</span>, y=<span class="number">4</span> </span><br><span class="line">Program ended with <span class="built_in">exit</span> code: <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h2 id="break和continue"><a href="#break和continue" class="headerlink" title="break和continue"></a>break和continue</h2><p>接下来，介绍两个比较重要的语句：break和continue。</p>
<p>break跳出本层循环，continue结束本次循环。这两者通常与if连⽤。</p>
<h3 id="break-1"><a href="#break-1" class="headerlink" title="break"></a>break</h3><p>前面在switch语句中已经用到了break，它的作用是跳出switch语句。它也可以用在循环结构中，这时候它的作用是跳出整个循环语句。</p>
<h4 id="举例-6"><a href="#举例-6" class="headerlink" title="举例"></a>举例</h4><p>这里以for循环为例子，break也可以用在while循环、do-while循环中：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">5</span>; i++) &#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"i=%d \n"</span>, i);</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">if</span> (i&gt;<span class="number">2</span>) &#123;</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">i=<span class="number">0</span> </span><br><span class="line">i=<span class="number">1</span> </span><br><span class="line">i=<span class="number">2</span> </span><br><span class="line">i=<span class="number">3</span> </span><br><span class="line">Program ended with <span class="built_in">exit</span> code: <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>上面代码的意思是当i&gt;2时，就跳出整个for循环，也就是结束for循环，所以输出结果是：</li>
</ul>
<h4 id="for循环嵌套"><a href="#for循环嵌套" class="headerlink" title="for循环嵌套"></a>for循环嵌套</h4><p>先来看一个for循环嵌套的例子，嵌套的意思就是：for循环内部又一个for循环：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x&lt;<span class="number">2</span>; x++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y&lt;<span class="number">2</span>; y++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"x=%d, y=%d \n"</span>, x, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="number">0</span>, y=<span class="number">0</span> </span><br><span class="line">x=<span class="number">0</span>, y=<span class="number">1</span> </span><br><span class="line">x=<span class="number">1</span>, y=<span class="number">0</span> </span><br><span class="line">x=<span class="number">1</span>, y=<span class="number">1</span> </span><br><span class="line">Program ended with <span class="built_in">exit</span> code: <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>这个时候如果在for循环中加入一个break，那么这个break究竟是跳出里面还是外面的for循环呢：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x&lt;<span class="number">2</span>; x++) &#123;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y&lt;<span class="number">2</span>; y++) &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"x=%d, y=%d \n"</span>, x, y);</span><br><span class="line">         </span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="number">0</span>, y=<span class="number">0</span> </span><br><span class="line">x=<span class="number">1</span>, y=<span class="number">0</span> </span><br><span class="line">Program ended with <span class="built_in">exit</span> code: <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>注意第5行的break，这个break的作用是跳出里面的for循环，并非外面的for循环。</li>
</ul>
<p>如果改变一下break的位置：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x&lt;<span class="number">2</span>; x++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y&lt;<span class="number">2</span>; y++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"x=%d, y=%d \n"</span>, x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="number">0</span>, y=<span class="number">0</span> </span><br><span class="line">x=<span class="number">0</span>, y=<span class="number">1</span> </span><br><span class="line">Program ended with <span class="built_in">exit</span> code: <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>注意第6行的break，这个break的作用是跳出外面的for循环，并非里面的for循环。</li>
</ul>
<blockquote>
<p><strong>说明</strong>：规律已经很明显了：break只会影响它所在的那个for循环。</p>
</blockquote>
<h3 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h3><p>continue只能使用在循环结构中，它的作用是跳过这一次循环，直接进入下一次循环。</p>
<p>这里以for循环为例子，continue也可以用在while循环、do-while循环中：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x&lt;<span class="number">10</span>; x++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x%<span class="number">2</span>==<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"x=%d \n"</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="number">1</span> </span><br><span class="line">x=<span class="number">3</span> </span><br><span class="line">x=<span class="number">5</span> </span><br><span class="line">x=<span class="number">7</span> </span><br><span class="line">x=<span class="number">9</span> </span><br><span class="line">Program ended with <span class="built_in">exit</span> code: <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>注意第2行，当x%2==0，也就是当x是2的倍数时，就跳过这次循环，不执行第6行语句，直接进入下一次循环。输出结果：</li>
</ul>
<blockquote>
<p><strong>说明</strong>：跟break一样，continue只会影响它所在的那个for循环。</p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.cnblogs.com/mjios/" target="_blank" rel="external">M了个J的博客</a></p>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[【10】函数]]></title>
      <url>http://sanfordy.com/2016/07/07/%E3%80%96A%E3%80%97%E3%80%901-0%E3%80%91C-%E8%AF%AD%E6%B3%95/%E3%80%9010%E3%80%91%E5%87%BD%E6%95%B0/</url>
      <content type="html"><![CDATA[<blockquote>
<p>任何一个C语言程序都是由一个或者多个程序段（小程序）构成的，每个程序段都有自己的功能，我们一般称这些程序段为“函数”。所以，你可以说C语言程序是由函数构成的。</p>
</blockquote>
<a id="more"></a>
<h2 id="函数的概念"><a href="#函数的概念" class="headerlink" title="函数的概念"></a>函数的概念</h2><h3 id="什么是函数"><a href="#什么是函数" class="headerlink" title="什么是函数"></a>什么是函数</h3><p>任何一个C语言程序都是由一个或者多个程序段（小程序）构成的，每个程序段都有自己的功能，我们一般称这些程序段为“函数”。所以，你可以说C语言程序是由函数构成的。</p>
<p>比如你用C语言编写了一个MP3播放器程序，那么它的程序结构如下图所示：</p>
<p><img src="http://images2015.cnblogs.com/blog/776348/201607/776348-20160707155751452-1805121758.png" alt=""></p>
<p>函数就是用来实现某个功能的程序段，每一个函数都有自己的功能。因此，你应该把实现某个功能所需的代码都写在函数中。比如，有个函数的功能是播放MP3，那么播放MP3的代码都应该写到这个函数中。当调用（执行）一个函数时，计算机就会按顺序执行函数中的所有代码，从而展示函数所实现的功能。</p>
<h3 id="函数名"><a href="#函数名" class="headerlink" title="函数名"></a>函数名</h3><p>一般来说，我们会将不同的功能交给不同的函数去实现。比如，将暂停播放MP3的代码写到一个函数中，将停止播放MP3的代码写到另一个函数中。因此，一个C程序中可能会有很多的函数。为了方便调用和区分这些函数，我们需要为每一个函数都起一个唯一的名称，函数的命名必须按照标识符命名规则。利用函数名就可以调用到对应的函数。</p>
<h2 id="函数的分类"><a href="#函数的分类" class="headerlink" title="函数的分类"></a>函数的分类</h2><p>前面已经说过，C语言中的函数就是面向对象中的”方法”，C语言的函数可以大概分为3类：</p>
<ol>
<li>主函数，也就是main函数。每个程序中只能有一个、也必须有一个主函数。无论主函数写在什么位置，C程序总是从主函数开始执行。</li>
<li>开发人员自定义的函数，可有可无，数目不限。</li>
<li>C语言提供的库函数，例如stdio.h中的输出函数printf()和输入函数scanf()。</li>
</ol>
<h2 id="函数的声明"><a href="#函数的声明" class="headerlink" title="函数的声明"></a>函数的声明</h2><h3 id="函数的定义顺序"><a href="#函数的定义顺序" class="headerlink" title="函数的定义顺序"></a>函数的定义顺序</h3><p>在C语言中，函数的定义顺序是有讲究的，默认情况下，只有后面定义的函数才可以调用前面定义过的函数：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    return a + b;</span><br><span class="line">    <span class="comment">//  这里是注释</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = sum(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>第5行定义的main函数调用了第1行的sum函数，这是合法的。如果调换sum函数和main函数的顺序，在标准的C编译器环境下是不合法的（不过在GCC编译器环境下只是一个警告）。</li>
</ul>
<p>如果想把函数的定义写在main函数后面，而且main函数能正常调用这些函数，那就必须在main函数的前面进行函数的声明：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只是做个函数声明，并不用实现</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = sum(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数的定义(实现)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>在第11行定义了sum函数，在第2行对sum函数进行了声明，然后在第6行(main函数中)就可以正常调用sum函数了。</li>
</ul>
<p>函数声明的格式：返回值类型 函数名 (参数1, 参数2, …)</p>
<p>只要你在main函数前面声明过一个函数，main函数就知道这个函数的存在，就可以调用这个函数。而且只要知道函数名、函数的返回值、函数接收多少个参数、每个参数是什么类型的，就能够调用这个函数了，因此，声明函数的时候可以省略参数名称。比如上面的sum函数声明可以写成这样：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>究竟这个函数是做什么用的，还要看函数的定义。</li>
</ul>
<h3 id="函数声明的注意事项"><a href="#函数声明的注意事项" class="headerlink" title="函数声明的注意事项"></a>函数声明的注意事项</h3><p>如果只有函数的声明，而没有函数的定义，那么程序将会在链接时出错，下面的写法是错误的：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    sum(<span class="number">10</span>, <span class="number">11</span>);</span><br><span class="line"></span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>在第1行声明了一个sum函数，但是并没有对sum函数进行定义，接着在第6行调用sum函数。</li>
<li>这个程序是可以编译成功的，因为我们在main函数前面声明了sum函数(函数的声明和定义是两码事)，这个函数声明可以理解为：在语法上，骗一下main函数，告诉它sum函数是存在的，所以从语法的角度上main函数是可以调用sum函数的。究竟这个sum函数存不存在呢，有没有被定义呢？编译器是不管的。在编译阶段，编译器并不检测函数有没有定义，只有在链接的时候才会检测这个函数存不存在，也就是检测函数有没有被定义。</li>
<li>因此，这个程序会在链接的时候报错，错误信息如下：<br><img src="http://images2015.cnblogs.com/blog/776348/201607/776348-20160707155851108-1963224110.png" alt=""><br>我这里的源文件是main.c文件，所以编译成功后生成一个main.o文件。链接的时候，链接器会检测main.o中的函数有没有被定义。</li>
<li>上面的错误信息大致意思是：在main.o文件中找不到sum这个标识符。</li>
<li>错误信息中的linker是链接器的意思，下次看到这个linker，说明是链接阶段出错了。链接出错了，就不能生成可执行文件，程序就不能运行。</li>
<li>这个错误的解决方案就是加上sum函数的定义。</li>
</ul>
<h2 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h2><p>任何一个函数在使用之前都必须进行定义，定义函数的目的就是为了写清楚你这个函数是干啥用的，里面包含了哪些代码。函数的定义格式如下：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">返回值类型  函数名(形式参数列表)</span><br><span class="line">  &#123;</span><br><span class="line">      函数体</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数定义示例"><a href="#函数定义示例" class="headerlink" title="函数定义示例"></a>函数定义示例</h3><p>比如定义一个函数用来计算两个整数的和。那么可以写成下面这样：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = a + b;</span><br><span class="line">    return c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> d = sum(<span class="number">10</span>, <span class="number">11</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"d is %d"</span>, d);</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d is 21</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>分别在第3行、第9行定义了sum函数、main函数，其中sum函数的作用是计算两个整数的和。</li>
<li>函数定义好后，并不会马上执行函数内部的代码，要有人调用它才会执行内部的代码。就好像你的手机虽然有打电话的功能，但是只有按了拨号键，才会执行打电话的功能。</li>
<li>程序运行时就会先调用main函数，按顺序执行第11~14行代码，因为main函数是程序的入口。</li>
<li>第11行的sum(10, 11)是调用sum函数，sum函数被调用了，就会分配存储空间给形式参数列表中的所有参数，也就是第3行中的变量a和变量b，它们都是“形式参数”。</li>
<li>第11行中的10、11称为“实际参数”，它们将分别赋值给变量a、变量b，也就是相当于：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">11</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>既然调用了sum函数，就会按顺序执行sum函数中的代码，也就是第5~6行代码。</li>
<li>第5行将a+b的值21赋值给了变量c，第6行使用return关键字将变量c返回给了函数调用者，也是说，第11行sum(10, 11)的值是21。那么变量d的值就是21。</li>
<li>第13行的输出结果为：d is 21</li>
<li>第3~7行中的变量a、b、c都只有在调用sum函数时，才会分配存储空间，当sum函数执行完毕后，变量a、b、c就会被释放存储空间。因此，它们的作用域仅限于sum函数内部。</li>
<li>第3行sum左边的int称为“返回值类型”，第6行return关键字后面跟着的数值称为“返回值”，因此第6行的变量c就是返回值，返回值的数据类型应该跟“返回值类型”保持一致。</li>
</ul>
<h3 id="函数定义的注意"><a href="#函数定义的注意" class="headerlink" title="函数定义的注意"></a>函数定义的注意</h3><h4 id="函数名不能重复"><a href="#函数名不能重复" class="headerlink" title="函数名不能重复"></a>函数名不能重复</h4><p>默认情况下，函数的名字必须唯一。下面的写法是错误的：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a)</span></span><br><span class="line"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    return <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>第1、6行定义的函数的名称都是test，编译器会直接报错。</li>
</ul>
<h4 id="函数都应该独立定义"><a href="#函数都应该独立定义" class="headerlink" title="函数都应该独立定义"></a>函数都应该独立定义</h4><p>下面的写法是错误的：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>在第3行把test函数定义在了main函数内部，这是错误的写法。</li>
</ul>
<h2 id="形式参数和实际参数"><a href="#形式参数和实际参数" class="headerlink" title="形式参数和实际参数"></a>形式参数和实际参数</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>形式参数：在定义函数时，函数名后面的小括号()中定义的变量称为形式参数，简称形参。</p>
<p>实际参数：在调用函数时传入的值称为实际参数，简称实参。</p>
<h3 id="实参必须和形参个数一致"><a href="#实参必须和形参个数一致" class="headerlink" title="实参必须和形参个数一致"></a>实参必须和形参个数一致</h3><p>调用函数时传递的实参个数 必须和 函数的形参个数必须保持一致：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    return a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    sum(<span class="number">10</span>, <span class="number">9</span>, <span class="number">7</span>);</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>第1行中sum函数中有3个形参，因此在第8行调用sum函数时，需要传入3个实参。</li>
</ul>
<h3 id="值传递注意"><a href="#值传递注意" class="headerlink" title="值传递注意"></a>值传递注意</h3><p>当使用基本数据类型（char、int、float等）作为实参时，实参和形参之间只是值传递，修改形参的值并不影响到实参：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test</span><span class="params">(<span class="keyword">char</span> a)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    a = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> b = <span class="number">5</span>;</span><br><span class="line">    </span><br><span class="line">    test(b);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"b的值是%d\n"</span>, b);</span><br><span class="line">    </span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b的值是5</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>在第3行定义了test函数，只有一个形参a。</li>
<li>在第14行调用了test函数，接着就会分配内存给变量a。这里将变量b当做实参，那么变量b的值将传递给变量a。这个时候，内存中大致如下图所示：<br><img src="http://images2015.cnblogs.com/blog/776348/201607/776348-20160707155855624-785321241.png" alt=""><blockquote>
<p><strong>注意</strong>：其实在内存中存储的是二进制数据，这里我写成10进制是为了直观性</p>
</blockquote>
</li>
<li>执行完第5行代码后，变量a的值变成了10，但是变量b的值依然是5：<br><img src="http://images2015.cnblogs.com/blog/776348/201607/776348-20160707155901561-302125664.png" alt="f"></li>
</ul>
<h3 id="函数可以没有形参"><a href="#函数可以没有形参" class="headerlink" title="函数可以没有形参"></a>函数可以没有形参</h3><p>定义一个函数时是可以没有形参的，比如下面的函数：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"调用了test函数\n"</span>);</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    test();</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">调用了test函数</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<ul>
<li>在第3行定义了test函数，可以发现，它的形参列表是空的，也就是没有形参。</li>
<li>那么在第11行调用test函数时，就不用传递任何实参。</li>
<li>其实，第9行定义的main函数也是没有形参的。</li>
</ul>
<h3 id="数组作为实参"><a href="#数组作为实参" class="headerlink" title="数组作为实参"></a>数组作为实参</h3><p>数组元素作为参数，与普通变量一样，把数组名传入，即数组的首地址。</p>
<blockquote>
<p><strong>注意</strong>：此时，形参和实参实际上是同一段内存空间。</p>
</blockquote>
<h2 id="返回值类型"><a href="#返回值类型" class="headerlink" title="返回值类型"></a>返回值类型</h2><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>返回值就是函数调用完后，返回给函数调用者的结果，用return关键字进行返回。定义函数时，要指明函数的返回值类型：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">pi</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    return <span class="number">3.4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> a = pi();</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>第1行定义了一个pi函数，返回值类型是double，因此用return返回的数值应该是double类型的，这里返回的是3.14。</li>
<li>第8行pi函数调用完毕后，函数调用者得到的值就是3.14，因此，变量a的值是3.14。</li>
</ul>
<h3 id="函数可以没有返回值"><a href="#函数可以没有返回值" class="headerlink" title="函数可以没有返回值"></a>函数可以没有返回值</h3><p>一个函数可以没有返回值，如果没有返回值，应该用void表示返回值类型：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"调用了test函数\n"</span>);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    test();</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">调用了test函数</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>在第3行定义了一个test函数，它是没有返回值的，所以第6行的return后面没有跟上任何数值，最后面的return语句可以省略。</li>
<li>在第11行调用了test函数。</li>
</ul>
<h3 id="函数默认返回值类型是int"><a href="#函数默认返回值类型是int" class="headerlink" title="函数默认返回值类型是int"></a>函数默认返回值类型是int</h3><p>如果一个函数没有明确写出返回值类型，那么代表这个函数的返回值类型是int：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sum(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line">       return a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>可以看到，第1行定义的sum函数没有明确写出返回值类型，那么这个sum函数的返回值类型就是int。因此，第3行return后面跟随的是int类型数据。</li>
</ul>
<h2 id="return"><a href="#return" class="headerlink" title="return"></a>return</h2><p>return语句可以在函数内部返回一个值给函数调用者：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = sum(<span class="number">5</span>, <span class="number">8</span>);</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>第3行使用了return语句，将a+b的值返回给了函数调用者，因此第8行变量c的值是13</li>
</ul>
<blockquote>
<p><strong>注意</strong>：一个函数内部可以多次使用return语句，使用了return语句后，函数就会马上停止执行，return语句后面的代码就不再被执行</p>
</blockquote>
<h2 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h2><p>函数自身调用自身，即函数内部又使用到了该函数功能，这个函数就叫做递归函数。</p>
<p>在计算机中阶乘就可以使用递归调用：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import &lt;Foundation/Foundation.h&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fac</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"input an number "</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    y = fac(n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d!=%d\n"</span>,n,y);</span><br><span class="line">    </span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fac</span><span class="params">(<span class="keyword">int</span> n)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m ;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"n&lt; 0,data error"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>|| n== <span class="number">1</span>)</span><br><span class="line">        m = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> m = fac(n <span class="number">-1</span>)*n;<span class="comment">//精华(解释在下面)</span></span><br><span class="line"></span><br><span class="line">    return m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 步骤：从里往外算，一层一层嵌套。</span><br><span class="line"> </span><br><span class="line">假设n = 4;</span><br><span class="line">1.m = f(4 - 1) * 4,</span><br><span class="line">2.m = f(3 - 1) * 3 * 4,</span><br><span class="line">3.m = f(2 - 1) * 2 * 3 * 4,</span><br><span class="line">4.此时n = 2,return m,即m返回给上一个调用他的函数 m = f(2 - 1) = 1;</span><br><span class="line">所以 m = 1 * 2 * 3 * 4 = 24</span><br><span class="line"> */</span></span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">input an number <span class="number">4</span></span><br><span class="line"><span class="number">4</span>!=<span class="number">24</span></span><br><span class="line">Program ended with <span class="built_in">exit</span> code: <span class="number">0</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：递归一定要有出口。 </p>
</blockquote>
<h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><p>通过函数指针调用函数的函数。如果你把函数A的指针（地址）作为参数传递给另一个函数B，当这个指针被用来调用其所指向的函数A时，我们就说函数A是回调函数：</p>
<p>&lt; 代码示例 &gt; </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">//  shouwNum内有两个参数：1.类型为整形的整数参数 2.类型为void (*)()的指针参数</span><br><span class="line">void showNum (int,void (*)(int));</span><br><span class="line">//  回调函数</span><br><span class="line">void printNum(int);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    showNum(110, printNum);</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">void showNum(int a,void (*ptr)(int))&#123;</span><br><span class="line">    (* ptr)(a);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">void printNum(int b)&#123;</span><br><span class="line">    printf("%d \n",b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">110</span> </span><br><span class="line">Program ended with <span class="built_in">exit</span> code: <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h2 id="常见函数"><a href="#常见函数" class="headerlink" title="常见函数"></a>常见函数</h2><h3 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h3><p>从第一个C语言程序开始，就认识了这个main函数。main函数是整个C程序的入口，有了main函数，C程序才能运行成功，而且整个C程序中只能有一个main函数。</p>
<p>main函数的简单定义如下：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>它可以没有形式参数，返回值是int类型。它的返回值用于说明程序的退出状态：如果返回0，则代表程序正常退出，否则代表程序异常退出。</li>
</ul>
<h3 id="scanf函数"><a href="#scanf函数" class="headerlink" title="scanf函数"></a>scanf函数</h3><p>这是在stdio.h中声明的一个函数，因此使用前必须加入#include <stdio.h>。调用scanf函数时，需要传入变量的地址作为参数，scanf函数会等待标准输入设备（比如键盘）输入数据，并且将输入的数据赋值给地址对应的变量：</stdio.h></p>
<p>&lt; 代码分析 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"Please input your age:"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;age);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Your age is %d."</span>, age);</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>运行程序，执行完第1行代码，控制台会输出一句提示信息：please input your age:</li>
<li>执行到第4行的scanf函数时，会等待用户的键盘输入，并不会往后执行代码。scanf的第1个参数是”%d”，说明要求用户以10进制的形式输入一个整数。这里要注意，scanf的第2个参数传递的不是age变量，而是age变量的地址&amp;age，&amp;是C语言中的一个地址运算符，可以用来获取变量的地址。</li>
<li>接着我们可以在提示信息后面输入个8：please input your age:8</li>
<li>输入完毕后，敲一下回车键，目的是告诉scanf函数我们已经输入完毕了，scanf函数会将输入的8赋值给age变量。</li>
<li>scanf函数赋值完毕后，才会往后执行代码，执行到第6行时，控制器会输出：Your age is 8.</li>
</ul>
<p>scanf的注意事项：</p>
<ol>
<li>以回车确定输入结束。切记：只有回⻋才会结束输入。</li>
<li>scanf(“%d%d”,&amp;num1,&amp;num2); // 限制输入格式。</li>
<li>不要在格式串后面加’\n’字符，否则会抵消掉人工输⼊的回车。</li>
</ol>
<h3 id="printf函数"><a href="#printf函数" class="headerlink" title="printf函数"></a>printf函数</h3><p>这是在stdio.h中声明的一个函数，因此使用前必须加入#include <stdio.h>，使用它可以向标准输出设备（比如屏幕）输出数据。</stdio.h></p>
<h4 id="简单用法"><a href="#简单用法" class="headerlink" title="简单用法"></a>简单用法</h4><p>printf(字符串, 格式符参数)：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">// 使用常量作参数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"My age is %d\n"</span>, <span class="number">26</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 也可以使用变量</span></span><br><span class="line">    <span class="keyword">int</span> age = <span class="number">17</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"My age is %d\n"</span>, age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">My age is 26</span><br><span class="line">My age is 17</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>格式符%d表示以有符号的十进制形式输出一个整型，格式符参数中的26和age会代替%d的位置。</li>
<li>第2行代码中的\n是个转义字符，表示换行，所以输出了第一句”My age is 26”后会先换行，再输出”My age is 17”。</li>
<li>如果去掉第2行中的\n，将会是这样的效果：My age is 26My age is 17</li>
</ul>
<blockquote>
<p><strong>总结</strong>：左边字符串中格式符的个数 必须跟 右边格式符参数的个数一样；格式符的类型决定了格式符参数的类型，比如使用%d，说明对应的格式符参数必须是整型。</p>
</blockquote>
<h4 id="常用的格式符及其含义"><a href="#常用的格式符及其含义" class="headerlink" title="常用的格式符及其含义"></a>常用的格式符及其含义</h4><p><img src="http://images2015.cnblogs.com/blog/776348/201607/776348-20160718141032685-1803882138.png" alt=""></p>
<h4 id="精细的格式控制"><a href="#精细的格式控制" class="headerlink" title="精细的格式控制"></a>精细的格式控制</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  输出结果：The price is　　14.</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"The price is %4d."</span>, <span class="number">14</span>);</span><br></pre></td></tr></table></figure>
<p>你会发现”is”跟”14”的距离被拉开了，%4d的意思是输出宽度为4，而”14”的宽度为2，因此多出2个宽度，多出的宽度就会在左边用空格填补，因此你会看到”14”左边多了2个空格。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  输出结果：The price is 142434</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"The price is %4d."</span>, <span class="number">142434</span>);</span><br></pre></td></tr></table></figure>
<p>如果实际数值宽度比较大，用%4d输出宽度为6的”142434”，那就会按照实际数值宽度6来输出。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  输出结果：The price is 14　　.</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"The price is %-4d."</span>, <span class="number">14</span>);</span><br></pre></td></tr></table></figure>
<p>你会发现”14”跟”.”的距离被拉开了，%-4d表示输出宽度为4，如果比实际数值宽度大，多出的宽度会在右边用空格填补。如果4比实际数值宽度小，就按照实际数值的宽度来输出。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  输出结果：My height is 179.95</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"My height is %.2f"</span>, <span class="number">179.95f</span>);</span><br></pre></td></tr></table></figure>
<p>保留两位小数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  输出结果：My height is　　179.9</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"My height is %8.1f"</span>, <span class="number">179.95f</span>);</span><br></pre></td></tr></table></figure>
<p>同时设置输出宽度和小数位数，，输出宽度为8，保留1位小数。</p>
<h2 id="字符处理函数"><a href="#字符处理函数" class="headerlink" title="字符处理函数"></a>字符处理函数</h2><p>下面介绍的两个字符处理函数都是在stdio.h头文件中声明的。</p>
<h3 id="字符输出函数putchar"><a href="#字符输出函数putchar" class="headerlink" title="字符输出函数putchar"></a>字符输出函数putchar</h3><p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">putchar</span>(<span class="number">65</span>); <span class="comment">// A</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">'A'</span>); <span class="comment">// A</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">65</span>;</span><br><span class="line"><span class="built_in">putchar</span>(a); <span class="comment">// A</span></span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>上面的3种用法，输出的都是大写字母A。</li>
</ul>
<blockquote>
<p><strong>注意</strong>：putchar一次只能输出一个字符，而printf可以同时输出多个字符。</p>
</blockquote>
<h3 id="字符输入函数getchar"><a href="#字符输入函数getchar" class="headerlink" title="字符输入函数getchar"></a>字符输入函数getchar</h3><p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c;</span><br><span class="line">c = getchar();</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>getchar会将用户输入的字符赋值给变量c。</li>
</ul>
<p>getchar函数可以读入空格、TAB，直到遇到回车为止（因为空格、TAB都有对应的ASCII码，getchar把他们当做ASCII码处理了）。</p>
<p>getchar一次只能读入一个字符。</p>
<p>getchar还能读入回车换行符，这时候你要敲2次回车键。第1次敲的回车换行符被getchar读入，第2次敲的回车键代表输入结束。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.cnblogs.com/mjios/" target="_blank" rel="external">M了个J的博客</a></p>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[【09】ASCII码]]></title>
      <url>http://sanfordy.com/2016/06/19/%E3%80%96A%E3%80%97%E3%80%901-0%E3%80%91C-%E8%AF%AD%E6%B3%95/%E3%80%9009%E3%80%91ASCII%E7%A0%81/</url>
      <content type="html"><![CDATA[<blockquote>
<p>ASCII码是基于拉丁字母的一套电脑编码系统，是现今最通用的单字节编码系统，全称是“American Standard Code for Information Interchange”。编码系统，看起来好像很高级，其实就是一个字符集—字符的集合。</p>
</blockquote>
<a id="more"></a>
<h2 id="ASCII码简介"><a href="#ASCII码简介" class="headerlink" title="ASCII码简介"></a>ASCII码简介</h2><p>ASCII码是基于拉丁字母的一套电脑编码系统，是现今最通用的单字节编码系统，全称是“American Standard Code for Information Interchange”。编码系统，看起来好像很高级，其实就是一个字符集—字符的集合。</p>
<p>ASCII字符集包括了：所有的大写和小写英文字母，数字0到9，标点符号，以及一些特殊控制字符：如退格、删除、制表、回车，一共128个字符，全部都是“单字节字符”。</p>
<p>在计算机中的任何数据都是以二进制形式存储的，因此每个ASCII字符在内存中是以二进制形式存储的，而且只占用1个字节，二进制数的值就称为这个ASCII字符的ASCII值。比如大写字母‘A’在内存中的二进制形式是：0100 0001，那么它的ASCII值就是65。</p>
<h2 id="ASCII码表"><a href="#ASCII码表" class="headerlink" title="ASCII码表"></a>ASCII码表</h2><p>下面是一张ASCII码字符表，ASCII码值的范围是0~127：</p>
<p><img src="http://images2015.cnblogs.com/blog/776348/201607/776348-20160701092939656-1944808901.png" alt=""></p>
<h2 id="ASCII码使用"><a href="#ASCII码使用" class="headerlink" title="ASCII码使用"></a>ASCII码使用</h2><p>我们都知道1个char型变量只占用1个字节的存储空间，而所有的ASCII字符都是单字节字符，因此char型变量能存储任何ASCII字符。而且在使用char型变量存储ASCII字符时，可以直接用ASCII字符，也可以用ASCII值：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c1 = <span class="number">65</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> c2 = <span class="string">'A'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"c1=%c  c2=%c \n"</span>, c1, c2);</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c1=A  c2=A </span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>在第5、7行分别定义了字符型变量c1、c2。很明显，变量c2存储的是ACII字符‘A’；变量c1存储的是65，而ASCII值65对应的ASCII字符就是‘A’，因此变量c1存储的也是‘A’。</li>
</ul>
<p>下面来看看6和‘6’的区别：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c1 = <span class="number">6</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> c2 = <span class="string">'6'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"c1=%d  c2=%d \n"</span>, c1, c2);</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c1=6  c2=54 </span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>第5行给变量c1赋值了整数6，第7行给变量c2赋值了字符‘6’，‘6’的ASCII值是54。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.cnblogs.com/mjios/" target="_blank" rel="external">M了个J的博客</a></p>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[【08】进制]]></title>
      <url>http://sanfordy.com/2016/06/19/%E3%80%96A%E3%80%97%E3%80%901-0%E3%80%91C-%E8%AF%AD%E6%B3%95/%E3%80%9008%E3%80%91%E8%BF%9B%E5%88%B6/</url>
      <content type="html"><![CDATA[<blockquote>
<p>我们先来看看平时是如何表示一个整数的，最常见的肯定是用阿拉伯数字表示，比如“十二”，我们可以用12来表示，其实这种表示方式是基于一种叫做“十进制”的计数方式。“进制”是一种计数方式，编程中常见的进制有4种：十进制、二进制、八进制、十六进制。也就是说，同一个整数，我们至少有4种表示方式。</p>
</blockquote>
<a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们先来看看平时是如何表示一个整数的，最常见的肯定是用阿拉伯数字表示，比如“十二”，我们可以用12来表示，其实这种表示方式是基于一种叫做“十进制”的计数方式。“进制”是一种计数方式，编程中常见的进制有4种：十进制、二进制、八进制、十六进制。也就是说，同一个整数，我们至少有4种表示方式。</p>
<h2 id="十进制"><a href="#十进制" class="headerlink" title="十进制"></a>十进制</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>十进制是我们最熟悉、最常用的一种计数方式，它有两个特点：由0、1、2….9十个基本数字组成；运算规则是“逢十进一”。</p>
<h3 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h3><p>所谓“逢十进一”，似乎在小学数学中都已经学过了，也就是当数值满十时，就要向前进一位：</p>
<p><img src="http://images2015.cnblogs.com/blog/776348/201606/776348-20160623102519860-1011222561.png" alt=""></p>
<p>个位数为9+1，满十了，十位数就进一。</p>
<h2 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>二进制是计算机内部使用的一种计数方式，它有两个特点：由0、1两个基本数字组成；运算规则是“逢二进一”。</p>
<h3 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h3><p>有人可能会问：为什么二进制里面没有2~9这些数字呢？都说了，逢二进一，因此当数字满二的时候就会进位。</p>
<p>如果我写个1010，你能看出它是二进制还是十进制么？为了跟其他进制区分开来，书写二进制数的时候，需要以<code>0b</code>或者<code>0B</code>开头。比如0b1010是个二进制数，而1010则还是我们熟悉的十进制数，就是“一千零一十”</p>
<h3 id="运算-1"><a href="#运算-1" class="headerlink" title="运算"></a>运算</h3><p>做个简单的运算吧，比如1+1：</p>
<p><img src="http://images2015.cnblogs.com/blog/776348/201606/776348-20160623102524750-87756776.png" alt=""></p>
<p>个位数是1+1，值满二了，于是十位数要进一。因此，在二进制中：1 + 1 = 0b10，这里的0b10表示的是十进制中的“二”，并不是“十”。</p>
<p>以此类推，11 + 1 = 0b100：</p>
<p><img src="http://images2015.cnblogs.com/blog/776348/201606/776348-20160623102530235-234384441.png" alt=""></p>
<h3 id="二进制转为十进制"><a href="#二进制转为十进制" class="headerlink" title="二进制转为十进制"></a>二进制转为十进制</h3><p>进制里面有个“基数”的概念，基数是用来计算数值的，比如十进制的基数是10，因此十进制是这样算数的：1230 = 0 x 10<sup>0</sup> + 3 x 10<sup>1</sup> + 2 x 10<sup>2</sup> + 1 x 10<sup>3</sup> = 0 x 1 + 3 x 10 + 2 x 100 + 1 x 1000。</p>
<p>二进制的基数是2，以此类推：0b1011 = 1 x 2<sup>0</sup> + 1 x 2<sup>1</sup> + 0 x 2<sup>2</sup> + 1 x 2<sup>3</sup> = 1 x 1 + 1 x 2 + 0 x 4 + 1 x 8 = 1 + 2 + 0 + 8 = 11，因此二进制数0b1011表示的数值是十进制中的11。</p>
<p>一位二进制数能表示的最大值是1，而n位二进制数所能表示的最大值是0b111…1111，也就是说n位二进制数都是1，那么它的十进制数值为：1 x 2<sup>0</sup> + 1 x 2<sup>1</sup> + 1 x 2<sup>2</sup> + 1 x 2<sup>3</sup> + …. + 1 x 2<sup>n-1</sup> = 2<sup>n</sup> - 1。因此，n位二进制数所能表示的最大值是2<sup>n</sup> - 1。也就是说，4位二进制数能表示的最大值是0b1111，十进制数值为：2<sup>4</sup> - 1 = 15。</p>
<h2 id="八进制"><a href="#八进制" class="headerlink" title="八进制"></a>八进制</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p>八进制有两个特点：由0~7八个基本数字组成；运算规则是“逢八进一”。</p>
<h3 id="细节-1"><a href="#细节-1" class="headerlink" title="细节"></a>细节</h3><p>由于十进制和八进制中都包含了0~7，为了区分开来，在书写八进制数的时候，需要在前面加个<code>0</code>。比如076是个八进制数，76则是个十进制数。</p>
<h3 id="运算-2"><a href="#运算-2" class="headerlink" title="运算"></a>运算</h3><p><img src="http://images2015.cnblogs.com/blog/776348/201606/776348-20160623102534906-1731486194.png" alt=""></p>
<p>个位数是7+1，值满八了，于是十位数要进一。因此，在八进制中，7 + 1 = 010。010则表示十进制中的“八”，而不是“十”。</p>
<h3 id="八进制转十进制"><a href="#八进制转十进制" class="headerlink" title="八进制转十进制"></a>八进制转十进制</h3><p>八进制的基数是8，因此027计算出来就是十进制中的23：027 = 7 x 8<sup>0</sup> + 2 x 8<sup>1</sup> = 7 x 1 + 2 x 8 = 23。</p>
<h3 id="二进制转八进制"><a href="#二进制转八进制" class="headerlink" title="二进制转八进制"></a>二进制转八进制</h3><p>不难发现一个十进制数可以表示的最大值是9，而一个八进制数可以表示的最大值是7，恰好一个3位进制数可以表示的最大值0b111也是7。因此，我们可以用一个3位二进制数来代替一个1位八进制数：</p>
<p>0b11110011 = 0b 011  110  011  = 0363。</p>
<h3 id="八进制转二进制"><a href="#八进制转二进制" class="headerlink" title="八进制转二进制"></a>八进制转二进制</h3><p>如果是八进制转为二进制，那就反过来，用一个3位二进制数来表示一个1位八进制数：</p>
<p>025 = 0b 010  101 = 0b10101。</p>
<h2 id="十六进制"><a href="#十六进制" class="headerlink" title="十六进制"></a>十六进制</h2><h3 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h3><p>十六进制有两个特点：由0~9和A~F组成，A~F分别表示10~15；运算规则是“逢十六进一”。</p>
<h3 id="细节-2"><a href="#细节-2" class="headerlink" title="细节"></a>细节</h3><p>由于十进制、八进制、十六进制中都包含了0~7，为了区分开来，在书写十六进制数的时候，需要在前面加个<code>0x</code>或者<code>0X</code>。比如0x76是个十六进制数，076是个八进制数，76则是个十进制数。</p>
<h3 id="运算-3"><a href="#运算-3" class="headerlink" title="运算"></a>运算</h3><p><img src="http://images2015.cnblogs.com/blog/776348/201606/776348-20160623102539938-225212688.png" alt=""></p>
<p>个位数是B+5，也就是11+5，值满十六了，于是十位数要进一。因此，在十六进制中，B + 5 = 0x10。0x10则表示十进制中的“十六”，而不是“十”。</p>
<h3 id="十六进制转十进制"><a href="#十六进制转十进制" class="headerlink" title="十六进制转十进制"></a>十六进制转十进制</h3><p>十六进制的基数是16，F表示十进制中的15，因此0x2F计算出来就是十进制中的47：</p>
<p>0x2F = 15 x 16<sup>0</sup> + 2 x 16<sup>1</sup> = 15 x 1 + 2 x 16 = 47</p>
<h3 id="二进制转十六进制"><a href="#二进制转十六进制" class="headerlink" title="二进制转十六进制"></a>二进制转十六进制</h3><p>一个十六进制数可以表示的最大值是15，恰好一个4位二进制数可以表示的最大值0b1111也是15。因此，我们可以用一个4位二进制数来代替一个1位十六进制数：</p>
<p>0b11110011 = 0b 1111  0011  = 0xF3</p>
<h3 id="十六进制转二进制"><a href="#十六进制转二进制" class="headerlink" title="十六进制转二进制"></a>十六进制转二进制</h3><p>如果是十六进制转为二进制，那就反过来，用一个4位二进制数来表示一个1位十六进制数：</p>
<p>0x25 = 0b 0010  0101=0b100101</p>
<h2 id="变量与进制"><a href="#变量与进制" class="headerlink" title="变量与进制"></a>变量与进制</h2><h3 id="十进制与变量"><a href="#十进制与变量" class="headerlink" title="十进制与变量"></a>十进制与变量</h3><p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 代码示例 &gt;</p>
<ul>
<li>在第3行定义了一个变量a，存储的是十进制整数10。其实，这个变量a在内存中是以二进制数的形式存储的，10的二进制形式是1010：<br><img src="http://images2015.cnblogs.com/blog/776348/201606/776348-20160623102544594-718950591.png" alt=""></li>
</ul>
<h3 id="其他进制与变量"><a href="#其他进制与变量" class="headerlink" title="其他进制与变量"></a>其他进制与变量</h3><p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>b110; <span class="comment">// 十进制数：6</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">021</span>; <span class="comment">// 十进制数：17</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">12</span>; <span class="comment">// 十进制数：12</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> d = <span class="number">0x1D</span>; <span class="comment">// 十进制数：29</span></span><br><span class="line">    </span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>上面的代码中，分别将4种不同进制的数值赋值给不同的整型变量。对应的十进制数值已经写在右边的注释中。它们最终都是以二进制的形式存储在内存中：<br><img src="http://images2015.cnblogs.com/blog/776348/201606/776348-20160623102549172-1114288608.png" alt=""></li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.cnblogs.com/mjios/" target="_blank" rel="external">M了个J的博客</a></p>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[【07】变量（三）]]></title>
      <url>http://sanfordy.com/2016/06/18/%E3%80%96A%E3%80%97%E3%80%901-0%E3%80%91C-%E8%AF%AD%E6%B3%95/%E3%80%9007%E3%80%91%E5%8F%98%E9%87%8F%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      <content type="html"><![CDATA[<blockquote>
<p>我们已经知道，在64bit编译器环境下，1个int类型变量取值范围是-231 ~ 231 - 1，最大值是231-1。有时候，我们要使用的整数可能比231-1还大，比如234这个整数，如果还坚持用int类型变量来存储这个值的话，就会损失精度，得到的是垃圾数据。为了解决这个问题，C语言允许我们给int类型的变量加一些类型修饰符，某些类型修饰符可以增大int类型变量的长度，这样的话，int类型变量能存储的数据范围就变大了。</p>
</blockquote>
<a id="more"></a>
<h2 id="类型修饰符"><a href="#类型修饰符" class="headerlink" title="类型修饰符"></a>类型修饰符</h2><h3 id="什么是类型修饰符"><a href="#什么是类型修饰符" class="headerlink" title="什么是类型修饰符"></a>什么是类型修饰符</h3><p>我们已经知道，在64bit编译器环境下，1个int类型变量取值范围是-231 ~ 231 - 1，最大值是231-1。有时候，我们要使用的整数可能比231-1还大，比如234这个整数，如果还坚持用int类型变量来存储这个值的话，就会损失精度，得到的是垃圾数据。为了解决这个问题，C语言允许我们给int类型的变量加一些类型修饰符，某些类型修饰符可以增大int类型变量的长度，这样的话，int类型变量能存储的数据范围就变大了。</p>
<p>C语言提供了以下4种类型修饰符，4个都属于关键字：</p>
<ol>
<li>short  短型。</li>
<li>long  长型。</li>
<li>signed  有符号型。</li>
<li>unsigned  无符号型。</li>
</ol>
<p>按照用途进行分类，short和long是一类，signed和unsigned是一类。</p>
<h3 id="用法演示"><a href="#用法演示" class="headerlink" title="用法演示"></a>用法演示</h3><p>这些说明符一般就是用来修饰int类型的，所以在使用时可以省略int：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面两种写法是等价的</span></span><br><span class="line"> <span class="keyword">short</span> <span class="keyword">int</span> s1 = <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">short</span> s2 = <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 下面两种写法是等价的</span></span><br><span class="line"> <span class="keyword">long</span> <span class="keyword">int</span> l1 = <span class="number">2</span>;</span><br><span class="line"> <span class="keyword">long</span> l2 = <span class="number">2</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 可以连续使用2个long</span></span><br><span class="line"> <span class="keyword">long</span> <span class="keyword">long</span> ll = <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 下面两种写法是等价的</span></span><br><span class="line"> <span class="keyword">signed</span> <span class="keyword">int</span> si1 = <span class="number">3</span>;</span><br><span class="line"> <span class="keyword">signed</span> si2 = <span class="number">3</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 下面两种写法是等价的</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">int</span> us1 = <span class="number">4</span>;</span><br><span class="line"> <span class="keyword">unsigned</span> us2 = <span class="number">4</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 也可以同时使用2种修饰符</span></span><br><span class="line"> <span class="keyword">signed</span> <span class="keyword">short</span> <span class="keyword">int</span> ss = <span class="number">5</span>;</span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> ul = <span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>第2行中的short int和第3行中的short是等价的。</li>
<li>看第10行，可以连续使用两个long。long的作用会在后面解释。</li>
<li>注意第21和22行，可以同时使用两种不同的说明符。但是不能同时使用相同类型的修饰符，也就是说不能同时使用short和long 或者 不能同时使用signed和unsigned。</li>
</ul>
<h3 id="short和long"><a href="#short和long" class="headerlink" title="short和long"></a>short和long</h3><p>short和long可以提供不同长度的整型数，也就是可以改变整型数的取值范围。在64bit编译器环境下，int占用4个字节（32bit），取值范围是-231~231-1；short占用2个字节（16bit），取值范围是-215~215-1；long占用8个字节（64bit），取值范围是-263~263-1。</p>
<p>在64位编译器环境下，short占2个字节(16位)，int占4个字节(32位)，long占8个字节(64位)。因此，如果使用的整数不是很大的话，可以使用short代替int，这样的话，更节省内存开销。</p>
<p>世界上的编译器林林总总，不同编译器环境下，int、short、long的取值范围和占用的长度又是不一样的。比如在16bit编译器环境下，long只占用4个字节。不过幸运的是，ANSI \ ISO制定了以下规则：</p>
<ol>
<li>short跟int至少为16位（2字节）。</li>
<li>long至少为32位（4字节）。</li>
<li>short的长度不能大于int，int的长度不能大于long。</li>
<li>char一定为为8位（1字节），毕竟char是我们编程能用的最小数据类型。</li>
</ol>
<p>可以连续使用2个long，也就是long long。一般来说，long long的范围是不小于long的，比如在32bit编译器环境下，long long占用8个字节，long占用4个字节。不过在64bit编译器环境下，long long跟long是一样的，都占用8个字节。</p>
<p>还有一点要明确的是：short int等价于short，long int等价于long，long long int等价于long long。</p>
<h3 id="long的使用注意"><a href="#long的使用注意" class="headerlink" title="long的使用注意"></a>long的使用注意</h3><h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><p>long和int都能够存储整型常量，为了区分long和int，一般会在整型常量后面加个小写字母l，比如100l，表示long类型的常量。如果是long long类型呢，就加2个l，比如100ll。如果什么都不加，就是int类型的常量。因此，100是int类型的常量，100l是long类型的常量，100ll是long long类型的常量：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">long</span> b = <span class="number">100l</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> c = <span class="number">100l</span>l;</span><br><span class="line">    </span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>变量a、b、c最终存储的值其实都是100，只不过占用的字节不相同，变量a用4个字节来存储100，变量b、c则用8个字节来存储100。</li>
</ul>
<p>其实，你直接将100赋值给long类型的变量也是没问题的，照样使用。因为100是个int类型的常量，只要有4个字节，就能存储它，而long类型的变量b有8个字节，那肯定可以装下100啦：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> b = <span class="number">100</span>;</span><br><span class="line">    </span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> a = <span class="number">100000000000l</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a);</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1215752192</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>在第5行定义了long类型变量a，在第7行尝试输出a的值。注意了，这里用的是%d，表示以十进制整数格式输出，%d会把a当做int类型来输出，它认为a是4个字节的。由于a是long类型的，占用8个字节，但是输出a的时候，只会取其中4个字节的内容进行输出，所以输出结果又是传说的垃圾数据。</li>
</ul>
<p>那怎样才能完整地输出long类型呢？应该用格式符%ld：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> a = <span class="number">100000000000l</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%ld\n"</span>, a);</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1000000000000</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<ul>
<li>注意第7行，双引号里面的是%ld，表示输出1个long类型的整数。</li>
</ul>
<p>如果是long long类型，应该用%lld：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> a = <span class="number">100000000000l</span>l;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, a);</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1000000000000</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<h3 id="signed和unsigned"><a href="#signed和unsigned" class="headerlink" title="signed和unsigned"></a>signed和unsigned</h3><p>首先要明确的：<code>signed int</code>等价于<code>signed</code>，<code>unsigned int</code>等价于<code>unsigned</code>。</p>
<p><code>signed</code>和<code>unsigned</code>的区别就是它们的最高位是否要当做符号位，并不会像<code>short</code>和<code>long</code>那样改变数据的长度，即所占的字节数。</p>
<h4 id="signed"><a href="#signed" class="headerlink" title="signed"></a>signed</h4><p><code>signed</code>表示有符号，也就是说最高位要当做符号位，所以包括正数、负数和0。其实int的最高位本来就是符号位，已经包括了正负数和0了，因此signed和int是一样的，signed等价于signed int，也等价于int。signed的取值范围是-231 ~ 231 - 1。</p>
<h4 id="unsigned"><a href="#unsigned" class="headerlink" title="unsigned"></a>unsigned</h4><p><code>unsigned</code>表示无符号，也就是说最高位并不当做符号位，所以不包括负数。在64bit编译器环境下面，int占用4个字节（32bit），因此unsigned的取值范围是：0000 0000 0000 0000 0000 0000 0000 0000 ~ 1111 1111 1111 1111 1111 1111 1111 1111，也就是0 ~ 232 - 1。</p>
<blockquote>
<p><strong>注意</strong>：signed、unsigned也可以修饰char，long还可以修饰double。</p>
</blockquote>
<h3 id="不同数据类型所占用的存储空间"><a href="#不同数据类型所占用的存储空间" class="headerlink" title="不同数据类型所占用的存储空间"></a>不同数据类型所占用的存储空间</h3><p><img src="http://images2015.cnblogs.com/blog/776348/201606/776348-20160618225017760-1752659694.png" alt=""></p>
<h2 id="自动类型提升"><a href="#自动类型提升" class="headerlink" title="自动类型提升"></a>自动类型提升</h2><h3 id="什么是自动类型提升"><a href="#什么是自动类型提升" class="headerlink" title="什么是自动类型提升"></a>什么是自动类型提升</h3><p>先来看看下面的一则运算：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">double</span> d = a + <span class="number">9.5</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%f \n"</span>, d);</span><br><span class="line">    </span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">19.500000</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<ul>
<li>在第5行定义了一个int类型的变量a，赋值了一个整数10。</li>
<li>接着在第7行取出a的值10，加上浮点数9.5，这里做了一个“加法运算”，并且将“和”赋值给d。所以d的值应该是19.5。</li>
<li>在第9行使用格式符%f输出浮点型变量d，默认是保留6位小数的。</li>
<li>看似这么简单的运算，其实包含了一些语法细节在里面。严格来说，相同数据类型的值才能进行运算（比如加法运算），而且运算结果依然是同一种数据类型。第7行的情况是：变量a的值10是int类型（4字节），9.5是double类型（8字节）。很明显，10和9.5并不是相同数据类型。按理来说，10和9.5是不允许进行加法运算的。但是，系统会自动对占用内存较少的类型做一个“自动类型提升”的操作，也就把10提升为double类型。也就是说，本来是用4个字节来存放10的，现在改为用8个字节来存放10。因此，10和9.5现在都是用8个字节来存放的，都是double类型，然后就可以进行运算了。并且把运算结果赋值给double类型的变量d。</li>
<li>需要注意的是：经过第7行代码后，变量a一直都还是int类型的，并没有变成double类型。1个变量在它定义的时候是什么类型，那么就一直都是什么类型。“自动类型提升”只是在运算过程中进行的。</li>
</ul>
<h3 id="常见的自动类型提升"><a href="#常见的自动类型提升" class="headerlink" title="常见的自动类型提升"></a>常见的自动类型提升</h3><p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> a = <span class="number">10</span> + <span class="number">3.45f</span>;<span class="comment">// int 提升为 float</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> b = <span class="string">'A'</span> + <span class="number">32</span>; <span class="comment">// char 提升为 int</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">double</span> c = <span class="number">10.3f</span> + <span class="number">5.7</span>; <span class="comment">// float 提升为 double</span></span><br><span class="line">    </span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>注意第5行，系统会将字符’A’提升为int类型数据，也就是转为’A’的ASCII值后再跟32进行加法运算。’A’的ASCII值是65，因此变量b的值为65+32=97。</li>
<li>这个自动类型提升，知道有这么一回事就行了，不用死记这规则，因为系统会自动执行这个操作。</li>
</ul>
<h2 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h2><h3 id="什么是强制类型转换"><a href="#什么是强制类型转换" class="headerlink" title="什么是强制类型转换"></a>什么是强制类型转换</h3><p>先来看看下面的代码：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10.7</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d \n"</span>, i);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> j = (int) <span class="number">10.7</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d \n"</span>, j);</span><br><span class="line">    </span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">10 </span><br><span class="line">10 </span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<ul>
<li>注意第5行，我们将一个8个字节的浮点数10.7赋值给了只有4个字节存储空间的整型变量i。可以想象得到，把8个字节的内容塞给4个字节，肯定会损失精度。这里面也有一点语法细节，其实第5行做了一个“强制类型转换”的操作：由于左边是int类型的变量i，那么就会强制把double类型的10.7转换为int类型的10，并且把转换后的值赋值给了整型变量i。由于C语言是语法限制不严格，所以系统会自动强制转换，如果换做是其他语法严格的语言，比如Java，第5行代码早就报错了。</li>
<li>如果写得严格一点，明显地进行“强制类型转换”，应该写成第8行，在10.7的前面加了个(int)，表示强制转换为int类型的数据。这样就绝对不会有语法问题了。总之你将一个浮点型数据转换为整型数据，就会丢失小数部分的值。</li>
</ul>
<h3 id="常见的强制类型转换"><a href="#常见的强制类型转换" class="headerlink" title="常见的强制类型转换"></a>常见的强制类型转换</h3><p>这个强制类型转换，知道有这么一回事就行了，不用死记这规则，因为很多时候系统会自动执行这个操作：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">198l</span>; <span class="comment">// long 转换为 int</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> b = <span class="number">65</span>; <span class="comment">// int 转换为 char</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">19.5f</span>; <span class="comment">// float 转换为 int</span></span><br><span class="line">    </span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="其他用法"><a href="#其他用法" class="headerlink" title="其他用法"></a>其他用法</h3><p>前面看到的强制转换好像都是“大类型”转为“小类型”，其实这是不一样的，也可以由“小类型”转为“大类型”：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">double</span> b = (double)a  + <span class="number">9.6</span>;</span><br><span class="line">    </span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>注意第5行，先将a的值强制转换为double类型后，再跟9.6进行加法运算。这样的话，系统就不用执行“自动类型提升”的操作了。其实你不强转也可以的，因为系统会做一个“自动类型提升”的操作，将变量a的值10提升为double类型。知道有这用法就行了，以后某些地方会用得上。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.cnblogs.com/mjios/" target="_blank" rel="external">M了个J的博客</a></p>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[【06】变量（二）]]></title>
      <url>http://sanfordy.com/2016/06/07/%E3%80%96A%E3%80%97%E3%80%901-0%E3%80%91C-%E8%AF%AD%E6%B3%95/%E3%80%9006%E3%80%91%E5%8F%98%E9%87%8F%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      <content type="html"><![CDATA[<blockquote>
<p>在C语言中，你声明一个局部变量后，没有经过初始化赋值是可以使用的，但这是很危险的，不建议这样做。大多数人应该觉得变量b打印出来应该是0，其实不是。因为系统会随意给变量b赋值，得到的是垃圾数据。</p>
</blockquote>
<a id="more"></a>
<h2 id="变量和内存的关系"><a href="#变量和内存的关系" class="headerlink" title="变量和内存的关系"></a>变量和内存的关系</h2><h3 id="变量示例"><a href="#变量示例" class="headerlink" title="变量示例"></a>变量示例</h3><p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a = <span class="string">'A'</span>; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>变量a中的‘A’是用1个字节来存储的，1个字节共8位，变量a在内存中的存储形式是0100 0001，至于为什么‘A’的二进制是这样呢，后面再讨论。</li>
<li>变量b中的10是用4个字节来存储的，4个字节共32位，因此变量b在内存中的存储形式应该是0000 0000 0000 0000 0000 0000 0000 1010。</li>
<li>上述变量a、b在内存中的存储情况大致如下表所示（“存储的内容”那一列的一个小格子就代表一个字节，“地址”那一列是指每个字节的地址。）：<br><img src="http://images2015.cnblogs.com/blog/776348/201606/776348-20160607225259808-1160410400.png" alt=""><br>从图中可以看出，变量b占用了内存地址从ffc1~ffc4的4个字节，变量a占用了内存地址为ffc5的1个字节。每个字节都有自己的地址，其实变量也有地址。变量存储单元的第一个字节的地址就是该变量的地址。变量a的地址是ffc5，变量b的地址是ffc1。内存寻址是从大到小的，也就是说做什么事都会先从内存地址较大的字节开始，因此系统会优先分配地址值较大的字节给变量。由于是先定义变量a、后定义变量b，因此你会看到变量a的地址ffc5比变量b的地址ffc1大。注意看表格中变量b存储的内容，变量b的二进制形式是：0000 0000 0000 0000 0000 0000 0000 1010。由于内存寻址是从大到小的，所以是从内存地址最大的字节开始存储数据，存放顺序是ffc4-&gt;ffc3-&gt; ffc2-&gt;ffc1，所以把前面的0000 0000都放在ffc2~ffc4中，最后面的八位0000 1010放在ffc1中。</li>
</ul>
<h3 id="查看变量的内存地址"><a href="#查看变量的内存地址" class="headerlink" title="查看变量的内存地址"></a>查看变量的内存地址</h3><p>在调试过程中，我们经常会采取打印的方式查看变量的地址：</p>
<p>&lt; 代码示例 &gt;</p>
<p><em>main.c</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"变量a的地址是：%p"</span>, &amp;a);</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量a的地址是：<span class="number">0x7fff5fbff8f8</span></span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>第6行中的&amp;是一个地址运算符，&amp;a表示取得变量a的地址。格式符%p是专门用来输出地址的。这个0x7fff5fbff8f8就是变量a的内存地址。</li>
</ul>
<h2 id="变量的使用注意"><a href="#变量的使用注意" class="headerlink" title="变量的使用注意"></a>变量的使用注意</h2><h3 id="不能重复定义同一个变量"><a href="#不能重复定义同一个变量" class="headerlink" title="不能重复定义同一个变量"></a>不能重复定义同一个变量</h3><p>下面的代码是错误的：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">89</span>;</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; CRASH &gt;</p>
<ul>
<li>编译器会报第5行的错，错误的原因很简单，第3行和第5行都是定义变量i，因此在内存中会是这样：<br><img src="http://images2015.cnblogs.com/blog/776348/201606/776348-20160607225305090-942626929.png" alt=""><br>内存中会出现两块存储空间，而且名字都叫i，那如果我想取出变量i的值，那你说计算机取10好还是取89好呢？因此，这种做法肯定是不可以的。</li>
</ul>
<h3 id="同类型变量之间可以相互赋值"><a href="#同类型变量之间可以相互赋值" class="headerlink" title="同类型变量之间可以相互赋值"></a>同类型变量之间可以相互赋值</h3><p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> a = i;</span><br><span class="line">    </span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>在第3行定义了变量i且初始值为10；接着在第5行定义了变量a，并且将变量i的值赋值给了a。在内存中大致如下图所示：<br><img src="http://images2015.cnblogs.com/blog/776348/201606/776348-20160607225310043-2108240599.png" alt=""><br>变量i和变量a存储的值都是10。</li>
</ul>
<h3 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h3><p>变量的作用范围（作用域）是从定义变量的那一行代码开始，下面的代码是错误的：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = i;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> b = i;</span><br><span class="line">    </span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; CRASH &gt;</p>
<ul>
<li>编译器会报第3行的错误，错误原因是：标识符i找不到。我们是在第5行定义了变量i，因此变量i从第5行开始才有效，在前面的第3行是无效的。</li>
</ul>
<h3 id="没有经过初始化的变量是可以使用的"><a href="#没有经过初始化的变量是可以使用的" class="headerlink" title="没有经过初始化的变量是可以使用的"></a>没有经过初始化的变量是可以使用的</h3><p>在C语言中，你声明一个局部变量后，没有经过初始化赋值是可以使用的，但这是很危险的，不建议这样做。大多数人应该觉得变量b打印出来应该是0，其实不是。因为系统会随意给变量b赋值，得到的是垃圾数据：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b;           </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, b);</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1606422622</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>上述代码的打印结果是个垃圾数据，因此局部变量还是必须先进行初始化赋值，然后再使用，这样才是最安全的做法。</li>
</ul>
<p>如果是全局的int类型变量，系统会默认赋值为0：</p>
<p><img src="http://images2015.cnblogs.com/blog/776348/201606/776348-20160607225318965-1449503471.png" alt=""></p>
<h3 id="char使用注意事项"><a href="#char使用注意事项" class="headerlink" title="char使用注意事项"></a>char使用注意事项</h3><h4 id="char的取值范围"><a href="#char的取值范围" class="headerlink" title="char的取值范围"></a>char的取值范围</h4><p>char的取值范围是ASCII码字符或者-128~127的整数，所以使用char存储大写字母A有2种赋值方式：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式1</span></span><br><span class="line"><span class="keyword">char</span> c = <span class="string">'A'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式2</span></span><br><span class="line"><span class="keyword">char</span> c = <span class="number">65</span>;</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>上面两种方式是等效的，因为大写字母A的ASCII码值刚好为65。</li>
</ul>
<h4 id="char只能存储一个字符"><a href="#char只能存储一个字符" class="headerlink" title="char只能存储一个字符"></a>char只能存储一个字符</h4><p>汉字或者字符串需要用字符数组来存储，因为一个汉字占了2个字符，一个字符串是由一个或者多个字符组成的。因此，下面的写法都是错误的：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char c1 = '我';</span><br><span class="line">char c2 = '123';</span><br><span class="line">char c3 = "123";</span><br></pre></td></tr></table></figure>
<h3 id="补码相关"><a href="#补码相关" class="headerlink" title="补码相关"></a>补码相关</h3><p>其实任何数值在内存中都是以补码的形式存储的：</p>
<ol>
<li>正数的补码与原码相同。比如9的原码和补码都是1001。</li>
<li>负数的补码等于它正数的原码取反后再+1。（取反的意思就是0变1、1变0）。那么-10的补码计算过程如下：<ul>
<li>先算出10的二进制形式：0000 0000 0000 0000 0000 0000 0000 1010。</li>
<li>对10的二进制进行取反：1111 1111 1111 1111 1111 1111 1111 0101。</li>
<li>取反后的结果+1：1111 1111 1111 1111 1111 1111 1111 0110，因此，整数-10在内存中的二进制形式是：1111 1111 1111 1111 1111 1111 1111 0110。</li>
</ul>
</li>
</ol>
<h2 id="变量的作用域-1"><a href="#变量的作用域-1" class="headerlink" title="变量的作用域"></a>变量的作用域</h2><h3 id="作用域简介"><a href="#作用域简介" class="headerlink" title="作用域简介"></a>作用域简介</h3><p>变量的作用域就是指变量的作用范围。先来看看下面的程序：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">7</span>;</span><br><span class="line">    </span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>在第3行定义了一个变量a，当执行到这行代码时，系统就会为变量a分配存储空间。</li>
<li>当main函数执行完毕，也就是执行完第5行代码了，变量a所占用的内存就会被系统自动回收。</li>
<li>因此，变量a的作用范围是从定义它的那行开始，一直到它所在的大括号{}结束，也就是第3~6行，一旦离开这个范围，变量a就失效了。</li>
</ul>
<h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p>代码块其实就是用大括号{}括住的一块代码：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"a=%d"</span>, a);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    a = <span class="number">9</span>;</span><br><span class="line">    </span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>注意第3~7行的大括号，这就是一个代码块。</li>
<li>当执行到第4行时，系统会分配内存给变量a。</li>
<li>当代码块执行完毕，也就是执行完第6行代码后，变量a所占用的内存就会被系统回收。</li>
<li>因此，变量a的作用范围是从定义它的那行开始，一直到它所在的大括号{}结束，也就是第4~7行，离开这个范围，变量a就失效了。</li>
<li>所以，上面的程序是编译失败的，第9行代码是错误的，变量a在第7行的时候已经失效了，不可能在第9行使用。</li>
</ul>
<p>如果是下面这种情况：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">9</span>;</span><br><span class="line">    </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"a=%d"</span>, a);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a=10</span><br></pre></td></tr></table></figure>
<ul>
<li>注意第3、6行，各自定义了一个变量a，这种情况是没问题的。C语言规定：在不同作用域中允许有同名变量，系统会为它们分配不同的存储空间。</li>
<li>在第3行定义的变量a的作用域是：第3~12行；在第6行定义的变量a的作用域是：第6~9行。</li>
<li>最后注意第8行：尝试输出变量a的值。那这里输出的是哪一个变量a呢？其实这里采取的是“就近原则”，也就是第8行访问的是在第6行定义的变量a，并不是在第3行的变量a。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.cnblogs.com/mjios/" target="_blank" rel="external">M了个J的博客</a></p>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[【05】变量（一）]]></title>
      <url>http://sanfordy.com/2016/06/07/%E3%80%96A%E3%80%97%E3%80%901-0%E3%80%91C-%E8%AF%AD%E6%B3%95/%E3%80%9005%E3%80%91%E5%8F%98%E9%87%8F%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      <content type="html"><![CDATA[<blockquote>
<p>常量表示的数据是不可以改的，而用变量表示的数据是可以经常修改的。</p>
</blockquote>
<a id="more"></a>
<h2 id="什么是变量"><a href="#什么是变量" class="headerlink" title="什么是变量"></a>什么是变量</h2><p>常量表示的数据是不可以改的，而用变量表示的数据是可以经常修改的。</p>
<h2 id="变量的定义"><a href="#变量的定义" class="headerlink" title="变量的定义"></a>变量的定义</h2><p>跟其他语言一样，C语言中用变量来存储计算过程使用的值，任何变量都必须先定义类型再使用。为什么一定要先定义呢？因为变量的类型决定了变量占用的存储空间，所以定义变量类型，就是为了给该变量分配适当的存储空间，以便存放数据。比如你是char类型，我就只给你分配1个字节就够了，没必要分配2个字节、3个字节乃至更多的存储空间。</p>
<h2 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h2><p>我们在定义变量的时候，需要指明变量类型，系统会根据变量类型来分配相应的存储空间。不同数据类型所占用的存储空间是不一样的，如果是字符型（char）变量，就分配1个字节的存储空间；如果是整型（int）变量，就分配4个字节的存储空间。</p>
<p>变量类型的还一个作用是用来约束变量所存放数据的类型。一旦给变量指明了类型，那么这个变量就只能存储这种类型的数据，比如整型（int）变量只能存储整型数据，不能存储浮点型数据。</p>
<h2 id="变量名"><a href="#变量名" class="headerlink" title="变量名"></a>变量名</h2><p>在程序运行过程，肯定会定义大量的变量，每个变量都有自己的存储空间。那怎么区分这些变量呢？怎么找到变量对应的存储空间呢？为了区分这些变量，定义变量的时候应该为每个变量指定一个变量名，变量名也是标识符的一种。当我们要修改变量的数据时，系统会根据变量名找到变量对应的存储空间，将存储空间里面的数据改掉。</p>
<p>变量的命名规则：</p>
<ol>
<li>只能由数字、字母、下划线组成，并且不能以数字开头。</li>
<li>不可以与系统保留字同名。</li>
<li>不能使用重复的变量名。</li>
<li>见名知意（规范）。</li>
</ol>
<h2 id="变量的分类"><a href="#变量的分类" class="headerlink" title="变量的分类"></a>变量的分类</h2><h3 id="根据变量的作用域"><a href="#根据变量的作用域" class="headerlink" title="根据变量的作用域"></a>根据变量的作用域</h3><p>C语言根据变量作用域的不同，将变量分为<code>局部变量</code>、<code>全局变量</code>。</p>
<h4 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h4><p>定义：在函数内部定义的变量，称为局部变量。形式参数也属于局部变量。</p>
<p>作用域：局部变量只在定义它的函数内部有效，即局部变量只有在定义它的函数内部使用，其它函数不能使用它。</p>
<h4 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h4><p>定义：在所有函数外部定义的变量，称为全局变量。</p>
<p>作用域：全局变量的作用范围是从定义变量的位置开始到源程序结束，即全局变量可以被在其定义位置之后的其它函数所共享。</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  a是全局变量</span></span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span><br><span class="line"></span>&#123;   </span><br><span class="line">    <span class="comment">//  b是局部变量。</span></span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="根据变量的存储地点"><a href="#根据变量的存储地点" class="headerlink" title="根据变量的存储地点"></a>根据变量的存储地点</h3><p>有3个地方可以用于存储变量：普通内存、运行时堆栈、硬件寄存器。变量的存储地点决定了变量何时创建、何时销毁以及它的值能保持多久，也就是决定了变量的生命周期。</p>
<p>C语言根据变量存储地点的不同，可以把变量分为：<code>自动变量</code>、<code>静态变量</code>、<code>寄存器变量</code>。</p>
<h4 id="自动变量"><a href="#自动变量" class="headerlink" title="自动变量"></a>自动变量</h4><p>定义：自动变量是存储在堆栈中的。</p>
<p>哪些是自动变量：被关键字<code>auto</code>修饰的局部变量都是自动变量，但是极少使用这个关键字，基本上是废的，因为所有的局部变量在默认情况下都是自动变量。</p>
<p>生命周期：在程序执行到声明自动变量的代码块（函数）时，自动变量才被创建，当自动变量所在的代码块（函数）执行完毕后，这些自动变量就会自行销毁。如果一个函数被重复调用，这些自动变量每次都会重新创建。</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  a和b是自动变量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//  c是自动变量</span></span><br><span class="line">      <span class="keyword">int</span> c = a + b;</span><br><span class="line">      <span class="comment">//  d是自动变量</span></span><br><span class="line">      <span class="keyword">auto</span> <span class="keyword">int</span> d;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h4><p>定义：静态变量是存储在静态内存中的，也就是不属于堆栈。</p>
<p>哪些是静态变量：</p>
<ol>
<li>所有的全局变量都是静态变量。</li>
<li>被关键字<code>static</code>修饰的局部变量也是静态变量。</li>
</ol>
<p>生命周期：静态变量在程序<code>运行之前</code>创建并且只会创建一次，在程序的整个运行期间始终存在，直到程序结束。</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">    b++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">    c++;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"b=%d, c=%d \n"</span>, b, c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">// 连续调用3次test函数</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;<span class="number">3</span>; i++) &#123;</span><br><span class="line">        test();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">b=1, c=1 </span><br><span class="line">b=2, c=1 </span><br><span class="line">b=3, c=1 </span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>第3行的变量a、第6行的变量b都是静态变量，第9行的变量c、第16行的变量i是自动变量。</li>
<li>因为第6行的变量b是静态变量，所以它只会被创建一次，而且生命周期会延续到程序结束。因为它只会创建一次，所以第6行代码只会执行一次，下次再调用test函数时，变量b的值不会被重新初始化为0。<blockquote>
<p><strong>注意</strong>：虽然第6行的变量b是静态变量，但是只改变了它生命周期，并没有改变它的作用域，变量b还是只能在test函数内部使用。</p>
</blockquote>
</li>
</ul>
<h4 id="寄存器变量"><a href="#寄存器变量" class="headerlink" title="寄存器变量"></a>寄存器变量</h4><p>定义：存储在硬件寄存器中的变量，称为寄存器变量。寄存器变量比存储在内存中的变量访问效率更高（默认情况下，自动变量和静态变量都是放在内存中的）。</p>
<p>哪些变量是寄存器变量：被关键字<code>register</code>修饰的自动变量都是寄存器变量。</p>
<blockquote>
<p><strong>注意</strong>：<br>1.只有局部变量才可以是寄存器变量；<br>2.寄存器变量只限于int、char和指针类型变量使用。</p>
</blockquote>
<p>生命周期：因为寄存器变量本身就是局部变量，所以函数中的寄存器变量在调用该函数时占用寄存器中存放的值，当函数结束时释放寄存器，变量消失。</p>
<p>使用注意：</p>
<ol>
<li>由于计算机中寄存器数目有限，不能使用太多的寄存器变量。如果寄存器使用饱和时，程序将寄存器变量自动转换为自动变量处理。</li>
<li>为了提高运算速度，一般会将一些频繁使用的局部变量定义为寄存器变量，这样程序尽可能地为它分配寄存器存放，而不用内存。</li>
</ol>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">//  a是个寄存器变量。</span></span><br><span class="line">     <span class="keyword">register</span> <span class="keyword">int</span> a;</span><br><span class="line">     return <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h2><p>总结可得，定义变量需要2个条件：变量类型、变量名。代码如下：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    </span><br><span class="line">    return <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>在第3行定义了一个名字为i的整型变量，说明i只能存储整型数据；在第5行定义了一个名字为c的字符型变量，说明c只能存储字符型数据。</li>
<li>于是，系统就会在内存中分别为变量i、c分配一定的存储空间，如下图所示，i和c各占用一块存储空间：<br><img src="http://images2015.cnblogs.com/blog/776348/201606/776348-20160607173556355-1508318186.png" alt=""></li>
</ul>
<p>如果是同一种类型的变量，可以连续定义，变量名之间用逗号,隔开。代码如下：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, c;</span><br><span class="line">    </span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>第3行代码的意思是定义了2个int类型的变量，变量名分别为a、c。</li>
</ul>
<h2 id="变量的使用"><a href="#变量的使用" class="headerlink" title="变量的使用"></a>变量的使用</h2><h3 id="先定义，再初始化"><a href="#先定义，再初始化" class="headerlink" title="先定义，再初始化"></a>先定义，再初始化</h3><p>前面已经定义了两个变量，但是这两个变量并没有存储任何值，我们需要给变量进行第一次赋值，也叫做“初始化”。</p>
<p>变量赋值的格式是：变量名 = 值;</p>
<p>这个等号”=”是一个赋值运算符，将右边的值赋值给左边的变量，也就是将右边的值存储到左边变量的存储空间中：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    i = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    c = <span class="string">'A'</span>;</span><br><span class="line">    </span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>在第4行给变量i赋值一个整型常量10，在第7行给变量c赋值一个字符型常量’A’。像第4、7行这样的赋值操作，称为“赋值运算”。</li>
<li>内存中大致如下图所示，整数10存储在i的存储空间中，字母A存储在c的存储空间中。（其实我这个图并不是很准确，因为内存中的所有数据都是以0和1的形式存储的，比如10，它会存储成1010；字母 A ，它会存储成1000001。这里为了达到直观的效果，就没有写成二进制形式）<br><img src="http://images2015.cnblogs.com/blog/776348/201606/776348-20160607173911043-638078260.png" alt=""></li>
</ul>
<h3 id="定义的同时初始化"><a href="#定义的同时初始化" class="headerlink" title="定义的同时初始化"></a>定义的同时初始化</h3><p>上面的代码也可以写成下面这样，在定义变量的同时进行初始化：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">float</span> f = <span class="number">10.9f</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">double</span> d = <span class="number">9.8</span>;</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>内存分析如下：<br><img src="http://images2015.cnblogs.com/blog/776348/201606/776348-20160607174035683-177628936.png" alt=""></li>
</ul>
<h3 id="可以不断修改"><a href="#可以不断修改" class="headerlink" title="可以不断修改"></a>可以不断修改</h3><p>既然i是个变量，说明它的值可以不断地改变，看下面的代码：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    i = <span class="number">89</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> c = <span class="string">'A'</span>;</span><br><span class="line">    </span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>在第3行定义了变量i，并且初始值为10。紧接着在第5行把i的值改为89，这个89会覆盖以前存储的10。</li>
</ul>
<h3 id="const关键字"><a href="#const关键字" class="headerlink" title="const关键字"></a>const关键字</h3><p>刚才提到，默认情况下，变量的值是可以不断改变的。不过，有时候我们会希望变量的值只在定义的时候初始化一次，以后都不能再改变，这个时候我们就可以使用<code>const</code>关键字来修饰变量：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    i = <span class="number">11</span>;</span><br><span class="line">    </span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>注意第3行，在<code>int</code>的前面加了个<code>const</code>关键字。表示变量i的值只会初始化一次，也就是说i的值永远都是一开始的10，以后都不能再改了。所以编译器会报第5行代码的错误，不允许再次修改i的值。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.cnblogs.com/mjios/" target="_blank" rel="external">M了个J的博客</a></p>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[【04】常量]]></title>
      <url>http://sanfordy.com/2016/06/07/%E3%80%96A%E3%80%97%E3%80%901-0%E3%80%91C-%E8%AF%AD%E6%B3%95/%E3%80%9004%E3%80%91%E5%B8%B8%E9%87%8F/</url>
      <content type="html"><![CDATA[<blockquote>
<p>“量”表示数据。常量，则表示一些固定的数据，也就是不能改变的数据。</p>
</blockquote>
<a id="more"></a>
<h2 id="什么是常量"><a href="#什么是常量" class="headerlink" title="什么是常量"></a>什么是常量</h2><p>“量”表示数据。常量，则表示一些固定的数据，也就是不能改变的数据。</p>
<h2 id="常量的类型"><a href="#常量的类型" class="headerlink" title="常量的类型"></a>常量的类型</h2><h3 id="整型常量（int）"><a href="#整型常量（int）" class="headerlink" title="整型常量（int）"></a>整型常量（int）</h3><p>其实就是<code>int</code>类型的数据，包括了所有的整数，比如6、27、109、256、-10、0、-289等。</p>
<h3 id="浮点型常量（float-double）"><a href="#浮点型常量（float-double）" class="headerlink" title="浮点型常量（float\double）"></a>浮点型常量（float\double）</h3><p>浮点型常量分为<code>double</code>和<code>float</code>两种数据类型。</p>
<h4 id="double"><a href="#double" class="headerlink" title="double"></a>double</h4><p>双精度浮点型，其实就是小数。比如5.43、-2.3、0.0等，注意，0.0也算是个小数。</p>
<h4 id="float"><a href="#float" class="headerlink" title="float"></a>float</h4><p>单精度浮点型，也是小数，比<code>double</code>的精确程度低，也就是说所能表示的小数位数比较少。为了跟<code>double</code>区分开来， <code>float</code> 型数据都是以<code>f</code>结尾的，比如5.43f、-2.3f、0.0f。需要注意的是，绝对不能有10f这样格式的，编译器会直接报错，只有小数才允许加上f。</p>
<h3 id="字符常量（char）"><a href="#字符常量（char）" class="headerlink" title="字符常量（char）"></a>字符常量（char）</h3><p>将一个数字（0~9）、英文字母（a~z、A~Z）或者其他符号（+、-、!、?等）用单引号括起来，这样构成的就是字符常量。比如‘6’、‘a’、‘F’、‘+’、‘$’等。</p>
<blockquote>
<p><strong>注意</strong>：单引号只能括住1个字符，而且不能是中文字符，下面的写法是错误的：‘abc’、‘123456’、‘男’。</p>
</blockquote>
<h3 id="字符串常量"><a href="#字符串常量" class="headerlink" title="字符串常量"></a>字符串常量</h3><p>将一个或者多个字符用双引号（“”）括起来，这样构成的就是字符串常量。比如“6”、“男”、“哇哈哈”、“abcd”、“my_car4”，其实printf(“Hello World”);语句中的“Hello World”就是字符串常量。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.cnblogs.com/mjios/" target="_blank" rel="external">M了个J的博客</a></p>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[【03】数据]]></title>
      <url>http://sanfordy.com/2016/06/07/%E3%80%96A%E3%80%97%E3%80%901-0%E3%80%91C-%E8%AF%AD%E6%B3%95/%E3%80%9003%E3%80%91%E6%95%B0%E6%8D%AE/</url>
      <content type="html"><![CDATA[<blockquote>
<p>在我们使用计算机的过程中，会接触到各种各样的数据，有文档数据、图片数据、视频数据，还有聊QQ时产生的文字数据、用迅雷下载的文件数据等。这讲我们就来介绍C语言中数据的处理。</p>
</blockquote>
<a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在我们使用计算机的过程中，会接触到各种各样的数据，有文档数据、图片数据、视频数据，还有聊QQ时产生的文字数据、用迅雷下载的文件数据等。这讲我们就来介绍C语言中数据的处理。</p>
<h2 id="数据的存储"><a href="#数据的存储" class="headerlink" title="数据的存储"></a>数据的存储</h2><h3 id="数据形态"><a href="#数据形态" class="headerlink" title="数据形态"></a>数据形态</h3><p>首先来看看计算机是怎么存储数据的。总的来说，计算机中存储的数据可以分为两种：静态数据和动态数据。</p>
<h4 id="静态数据"><a href="#静态数据" class="headerlink" title="静态数据"></a>静态数据</h4><p>概念：静态数据是指一些永久性的数据，一般存储在硬盘中。硬盘的存储空间一般都比较大，现在普通计算机的硬盘都有500G左右，因此硬盘中可以存放一些比较大的文件。</p>
<p>存储的时长：计算机关闭之后再开启，这些数据依旧还在，只要你不主动删掉或者硬盘没坏，这些数据永远都在。</p>
<p>哪些是静态数据：静态数据一般是以文件的形式存储在硬盘上，比如文档、照片、视频等。</p>
<h4 id="动态数据"><a href="#动态数据" class="headerlink" title="动态数据"></a>动态数据</h4><p>概念：动态数据指在程序运行过程中，动态产生的临时数据，一般存储在内存中。内存的存储空间一般都比较小，现在普通计算机的内存只有4G左右，因此要谨慎使用内存，不要占用太多的内存空间。</p>
<p>存储的时长：计算机关闭之后，这些临时数据就会被清除。</p>
<p>哪些是动态数据：当运行某个程序（软件）时，整个程序就会被加载到内存中，在程序运行过程中，会产生各种各样的临时数据，这些临时数据都是存储在内存中的。当程序停止运行或者计算机被强制关闭时，这个程序产生的所有临时数据都会被清除。</p>
<blockquote>
<p><strong>说明</strong>：你可能会问，既然硬盘的存储空间这么大，为何不把所有的应用程序加载到硬盘中去执行呢？有个主要原因是内存的访问速度比硬盘快N倍。</p>
</blockquote>
<h4 id="动态数据和静态数据的转换"><a href="#动态数据和静态数据的转换" class="headerlink" title="动态数据和静态数据的转换"></a>动态数据和静态数据的转换</h4><p>硬盘和内存是计算机使用最频繁的两个硬件，它们之间的数据经常要进行转换。</p>
<p>比如，硬盘上有个叫做“C语言.mp4”的视频文件，现在要使用暴风影音来播放：</p>
<p><img src="http://images2015.cnblogs.com/blog/776348/201606/776348-20160607143556418-1431912984.png" alt=""></p>
<p>首先打开暴风影音软件，计算机会将暴风影音加载到内存中，紧接着计算机会读取硬盘中视频文件的内容到内存中。暴风影音会解析读取到的文件内容，以视频的形式呈现给用户看。这就完成了一个由静态数据到动态数据的转换。</p>
<p>再比如，你使用迅雷从网上下载一个叫做“C语言.mp4”的视频文件：</p>
<p><img src="http://images2015.cnblogs.com/blog/776348/201606/776348-20160607143719574-1356202246.png" alt=""></p>
<p>首先打开迅雷软件，计算机会将迅雷加载到内存中，紧接着迅雷就会从互联网下载视频文件。大家都知道，这个下载过程肯定是要耗点时间的，主要受文件大小和下载速度的影响。每个时间段内下载获取的数据都是先放到内存中，然后再写入到硬盘中。所有数据下载完毕后，硬盘中就会有一个完整的视频文件。这就完成了动态数据到静态数据的转换。</p>
<h3 id="存储形式"><a href="#存储形式" class="headerlink" title="存储形式"></a>存储形式</h3><h4 id="二进制存储"><a href="#二进制存储" class="headerlink" title="二进制存储"></a>二进制存储</h4><p>计算机只能识别0和1。因此，前面所说的静态数据和动态数据，都是以0和1的形式存储的，这种存储方式称为“二进制存储”。有人可能觉得很诧异，只是0和1怎么可能表示这多的数据呢？没错，如果只是一位数字的话，只能表示2种数据：要么是0，要么是1。但是如果有多位数字的话，那情况就不一样了。如果有2位数字，那么就能表示4种数据：00、01、10、11；如果有3位数字呢，就能表示8种数据；以此类推，如果有n位数字，就能表示2的n次方种数据。可以发现，只要位数足够，0和1所能表示的数据是非常庞大的。</p>
<h4 id="比特位和字节"><a href="#比特位和字节" class="headerlink" title="比特位和字节"></a>比特位和字节</h4><p>平时我们在计算机上看到的MP4、MP3、照片等文件，都是由0和1组合成的，只不过计算机解析了这些0和1，以图形界面的形式呈现在我们眼前。文件越大，所包含的0和1就越多，为了方便计算文件大小，对计量单位做了个规定：1个二进制位为1bit，也就是1个0或1就为1bit，bit的中文翻译是“比特位”；8个二进制位为1byte，也就是8个0或1就为1byte，1byte=8bit，byte的中文翻译是“字节”。平时我们所说的某个文件大小为64B，就是64字节的意思，内部包含了64x8个0和1。</p>
<p>数据换算：1 KB = 1024 B，1 MB = 1024 KB，1 GB = 1024 MB，1 TB = 1024 GB。</p>
<h2 id="数据的类型"><a href="#数据的类型" class="headerlink" title="数据的类型"></a>数据的类型</h2><p>C语言有丰富的数据类型，因此它很适合用来编写数据库，如DB2、Oracle都是C语言写的。</p>
<p>作为程序员，最关心的肯定是内存中的动态数据，因为我们写的程序就是运行在内存中的。程序在运行过程中，会产生各种各样的动态临时数据，为了方便数据的运算和操作，C语言对这些数据进行了分类，提供了丰富的数据类型。大致如下图所示：</p>
<p><img src="http://images2015.cnblogs.com/blog/776348/201606/776348-20160607143724168-1786196972.jpg" alt=""></p>
<p>在图中众多数据类型中，最常用的是4种基本数据类型：char、int、float、double，而最重要的是指针类型，指针使用得当的话，不仅可以节省代码量，还可以优化内存管理、提高性能。因此，指针是一个非常重要的概念，必须重视。如果你说C语言中除了指针，其他都学得挺好的，那你干脆说你没学过C语言。</p>
<p>这些丰富的数据在C语言中可以用常量或者变量来表示（后面会介绍常量和变量的使用）。</p>
<h2 id="数据的访问"><a href="#数据的访问" class="headerlink" title="数据的访问"></a>数据的访问</h2><p>数据访问一般分为直接访问和间接访问。</p>
<h3 id="直接访问"><a href="#直接访问" class="headerlink" title="直接访问"></a>直接访问</h3><p>直接访问内存单元中的内容。例如: a = 20; b = 2 * a等。</p>
<h3 id="间接访问"><a href="#间接访问" class="headerlink" title="间接访问"></a>间接访问</h3><p>通过内存单元编号以及数据所占字节数访问内存中数据。</p>
<blockquote>
<p><strong>注意</strong>：指针是间接访问的常用方式。</p>
</blockquote>
<h2 id="不同编译器环境下基本数据类型的存储长度"><a href="#不同编译器环境下基本数据类型的存储长度" class="headerlink" title="不同编译器环境下基本数据类型的存储长度"></a>不同编译器环境下基本数据类型的存储长度</h2><p>红色的代表常用的数据类型：</p>
<p><img src="http://images2015.cnblogs.com/blog/776348/201606/776348-20160607143728402-1476722878.png" alt=""></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.cnblogs.com/mjios/" target="_blank" rel="external">M了个J的博客</a></p>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[【02】C语言语法]]></title>
      <url>http://sanfordy.com/2016/05/30/%E3%80%96A%E3%80%97%E3%80%901-0%E3%80%91C-%E8%AF%AD%E6%B3%95/%E3%80%9002%E3%80%91C%E8%AF%AD%E8%A8%80%E8%AF%AD%E6%B3%95/</url>
      <content type="html"><![CDATA[<blockquote>
<p>C语言属于一门高级语言，其实所有的高级语言的基本语法组成部分都是一样的，只是表现形式不太一样。就好像亚洲人和非洲人，大家都有人类的结构：2只手、2只脚、1个头，只是他们外表不太一样，比如肤色、脸型。因此，你掌握好了一门高级语言，再去学习其他高级语言，那是相当快的。而且，很多其他高级语言，比如后面要学习的Objective-C，都是基于C语言、从C语言衍生出来的，好好学习C语言吧，绝对不吃亏。</p>
</blockquote>
<a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>C语言属于一门高级语言，其实所有的高级语言的基本语法组成部分都是一样的，只是表现形式不太一样。就好像亚洲人和非洲人，大家都有人类的结构：2只手、2只脚、1个头，只是他们外表不太一样，比如肤色、脸型。因此，你掌握好了一门高级语言，再去学习其他高级语言，那是相当快的。而且，很多其他高级语言，比如后面要学习的Objective-C，都是基于C语言、从C语言衍生出来的，好好学习C语言吧，绝对不吃亏。</p>
<h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><h3 id="什么是关键字"><a href="#什么是关键字" class="headerlink" title="什么是关键字"></a>什么是关键字</h3><p>关键字就是C语言提供的有特殊含义的符号，有些地方也叫做“保留字”。</p>
<h3 id="都有哪些关键字"><a href="#都有哪些关键字" class="headerlink" title="都有哪些关键字"></a>都有哪些关键字</h3><p>C语言一共提供了32个关键字，这些关键字都被C语言赋予了特殊含义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> <span class="keyword">double</span> <span class="keyword">int</span> <span class="keyword">struct</span> <span class="keyword">break</span> <span class="keyword">else</span> <span class="keyword">long</span> <span class="keyword">switch</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">case</span> <span class="keyword">enum</span> <span class="keyword">register</span> <span class="keyword">typedef</span> <span class="keyword">char</span> <span class="keyword">extern</span> return <span class="keyword">union</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> <span class="keyword">short</span> <span class="keyword">unsigned</span> <span class="keyword">continue</span> <span class="keyword">for</span> <span class="keyword">signed</span> <span class="keyword">void</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">default</span> <span class="keyword">goto</span> <span class="keyword">sizeof</span> <span class="keyword">volatile</span> <span class="keyword">do</span> <span class="keyword">if</span> <span class="keyword">while</span> <span class="keyword">static</span></span><br></pre></td></tr></table></figure>
<p>大致浏览一遍即可，不用去百度每个关键字的作用，这些关键字以后会经常用到的，到时候你想不记住都难。</p>
<h3 id="如何辨别关键字"><a href="#如何辨别关键字" class="headerlink" title="如何辨别关键字"></a>如何辨别关键字</h3><p>这些关键字会经常跟其他符号混在一起使用，一个程序里面这么多英文符号，我怎么知道那些是关键字呢？关键字有2大特征：</p>
<ol>
<li>全部都是小写。</li>
<li>在开发工具或者智能文本编辑工具（比如UltraEdit）中会显示特殊颜色。</li>
</ol>
<p>比如下面这段C程序在UltraEdit中呈现的样子：</p>
<p><img src="http://images2015.cnblogs.com/blog/776348/201606/776348-20160607104437855-2085184487.png" alt=""></p>
<p>在这段代码中，只有int和return是关键字，C语言中的所有关键字在UltraEdit中都会显示蓝色！可以看出，main并不是关键字。至于int和return究竟有什么特殊含义，这里先不做讨论，后面会详细介绍。</p>
<h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><h3 id="什么是标识符"><a href="#什么是标识符" class="headerlink" title="什么是标识符"></a>什么是标识符</h3><p>在程序中使用的变量名、函数名、标号等统称为标识符。除库函数的函数名由系统定义外，其余都由用户自定义。C规定，标识符只能是字母(A～Z，a～z)、数字(0～9)、下划线(_)组成的字符串，并且其第一个字符不能是数字。</p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ol>
<li>标准C不限制标识符的长度，但它受各种版本的C语言编译系统限制，同时也受到具体机器的限制。例如在某版本C中规定标识符前八位有效，当两个标识符前八位相同时，则被认为是同一个标识符。</li>
<li>在标识符中，大小写是有区别的。例如BOOK和book是两个不同的标识符。</li>
<li>标识符虽然可由程序员随意定义，但标识符是用于标识某个量的符号。因此，命名应尽量有相应的意义，以便阅读理解，作到“顾名思义”。如果标识符中含有多个单词，可以使用驼峰标识（除开第一个单词，后面每个单词的首字母都是大写）：firstName、myFirstName，或者使用下划线_来连接：first_name、my_first_name。</li>
</ol>
<h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><p>表达式是由常量、变量与运算符组成的。例如：3+5，a += b!</p>
<blockquote>
<p><strong>注意</strong>：表达式都会返回值。</p>
</blockquote>
<h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><p>语句是程序执⾏的最小单位，以分号结尾。 </p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.cnblogs.com/mjios/" target="_blank" rel="external">M了个J的博客</a></p>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[【01】第一个C程序代码分析]]></title>
      <url>http://sanfordy.com/2016/05/17/%E3%80%96A%E3%80%97%E3%80%901-0%E3%80%91C-%E8%AF%AD%E6%B3%95/%E3%80%9001%E3%80%91%E7%AC%AC%E4%B8%80%E4%B8%AAC%E7%A8%8B%E5%BA%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<blockquote>
<p><code>#include</code>是C语言的预处理指令之一，所谓预处理，就是在编译之前做的处理，预处理指令一般以<code>#</code>开头。</p>
</blockquote>
<a id="more"></a>
<h2 id="Xcode创建C程序步骤"><a href="#Xcode创建C程序步骤" class="headerlink" title="Xcode创建C程序步骤"></a>Xcode创建C程序步骤</h2><h3 id="打开Xcode"><a href="#打开Xcode" class="headerlink" title="打开Xcode"></a>打开Xcode</h3><p><img src="http://images2015.cnblogs.com/blog/776348/201606/776348-20160607114753808-1887444754.png" alt=""></p>
<h3 id="选择命令行程序"><a href="#选择命令行程序" class="headerlink" title="选择命令行程序"></a>选择命令行程序</h3><p><img src="http://images2015.cnblogs.com/blog/776348/201606/776348-20160607114803121-1487331799.png" alt=""></p>
<h3 id="填写项目名称并选择使用C语言"><a href="#填写项目名称并选择使用C语言" class="headerlink" title="填写项目名称并选择使用C语言"></a>填写项目名称并选择使用C语言</h3><p><img src="http://images2015.cnblogs.com/blog/776348/201606/776348-20160607114813058-523307311.png" alt=""></p>
<h3 id="选择保存目录"><a href="#选择保存目录" class="headerlink" title="选择保存目录"></a>选择保存目录</h3><p><img src="http://images2015.cnblogs.com/blog/776348/201606/776348-20160607114825027-90093732.png" alt=""></p>
<h3 id="自动生成如下代码"><a href="#自动生成如下代码" class="headerlink" title="自动生成如下代码"></a>自动生成如下代码</h3><p><img src="http://images2015.cnblogs.com/blog/776348/201606/776348-20160607114837011-470505554.png" alt=""></p>
<h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>打开项目中的main.c文件（C程序的源文件拓展名为<code>.c</code>），可以发现它是C程序中的唯一一个源文件：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">// insert code here...</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello, World!\n"</span>);</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来分析一下每行代码的意义。</p>
<h3 id="预处理命令（-include）"><a href="#预处理命令（-include）" class="headerlink" title="预处理命令（#include）"></a>预处理命令（#include）</h3><p><code>#include</code>是C语言的预处理指令之一，所谓预处理，就是在编译之前做的处理，预处理指令一般以<code>#</code>开头。</p>
<p><code>#include</code>指令后面会跟着一个文件名，预处理器发现<code>#include</code>指令后，就会根据文件名去查找文件，并把这个文件的内容包含到当前文件中。被包含文件中的文本将替换源文件中的<code>#include</code>指令，就像你把被包含文件中的全部内容拷贝到这个<code>#include</code>指令所在的位置一样。</p>
<p>如果被包含的文件拓展名为<code>.h</code>，我们称之为”头文件”（Header File），头文件可以用来声明函数（”函数”就是面向对象中的”方法”），要想使用这些函数，就必须先用<code>#include</code>指令包含函数所在的头文件。</p>
<p><code>#include</code>指令不仅仅限于<code>.h</code>头文件，<code>可以包含任何编译器能识别的C/C++代码文件</code>，包括<code>.c</code>、<code>.hpp</code>、.<code>cpp</code>等，甚至<code>.txt</code>、<code>.abc</code>等等都可以，也就是说你完全可以将第3行到第9行的代码放到其他文件中，然后用 <code>#include</code>指令包含进来。比如将第3行到第9行的代码放到 my.txt 中：</p>
<p><img src="http://images2015.cnblogs.com/blog/776348/201606/776348-20160607114905949-694429859.png" alt=""></p>
<p>在main.c源文件中包含my.txt文件：</p>
<p><img src="http://images2015.cnblogs.com/blog/776348/201606/776348-20160607114916043-985670090.png" alt=""></p>
<p>程序还是可以照常运行的，因为<code>#include</code>的功能就是将文件内容完全拷贝到<code>#include</code>指令所在的位置。</p>
<blockquote>
<p><strong>注意</strong>：不过你可能会疑惑，为什么<code>stdio.h</code>用尖括号&lt;&gt;，而my.txt用双引号””？这个很好区别，如果是系统自带的文件，最好用&lt;&gt;；如果是开发人员自己创建的文件，最好用””。</p>
<p><strong>说明</strong>：这里用txt文件纯属演示，平时做项目不会这样做，除非吃饱了撑着，才会把代码都写到txt中去。</p>
</blockquote>
<h3 id="库函数（stdio-h）"><a href="#库函数（stdio-h）" class="headerlink" title="库函数（stdio.h）"></a>库函数（stdio.h）</h3><p><code>stdio.h</code>是C语言函数库中的一个头文件，里面定义了一些标准输入输出函数。在main.c的第1行代码中，用<code>#include</code>指令包含了<code>stdio.h</code>文件。</p>
<p>这里之所以包含<code>stdio.h</code>文件，是因为在第7行中用到了在<code>stdio.h</code>内部声明的<code>printf</code>函数，这个函数可以向标准输出设备（比如显示器屏幕）输出数据，屏幕上输出的文字就是第7行代码<code>printf(&quot;Hello, World!\n&quot;)</code>造成的，双引号“”内的文本为C语言的字符串。</p>
<h3 id="主函数（main）"><a href="#主函数（main）" class="headerlink" title="主函数（main）"></a>主函数（main）</h3><p>前面也已经提到，C中的函数就是面向对象中的”方法”。 C语言是一门面向过程的语言，是以过程为中心的编程思想，就是先分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用函数就可以了。</p>
<p>一个C程序中一定会有一个<code>main</code>函数，也只能有一个<code>main</code>函数。<code>main</code>函数是整个C程序的入口。<code>main.c</code>的第3行代码就定义了一个<code>main</code>函数。</p>
<p><code>main</code>函数的返回值为<code>int</code>类型，接收2个参数，其实可以不写参数， main 函数可以简化成这样：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// insert code here...</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello, World!\n"</span>);</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>这里的main函数没有写返回值类型，并不代表函数没有返回值，而是表示返回值类型为int类型，void才代表函数没有返回值。</li>
</ul>
<p>由于C语言的语法限制不严格，我们还可以进一步简化 main 函数：</p>
<p>&lt; 代码示例 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// insert code here...</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello, World!\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>虽然它要求main函数返回int类型的值，但我们可以不返回。</li>
</ul>
<h2 id="开发和运行C程序的步骤"><a href="#开发和运行C程序的步骤" class="headerlink" title="开发和运行C程序的步骤"></a>开发和运行C程序的步骤</h2><p>步骤图如下：</p>
<p><img src="http://images2015.cnblogs.com/blog/776348/201606/776348-20160607114923027-1543894669.png" alt=""></p>
<h3 id="编写程序"><a href="#编写程序" class="headerlink" title="编写程序"></a>编写程序</h3><p>C语言源文件的扩展名为<code>.c</code>，源程序（代码）以<code>ASCII</code>码形式存储于源文件，不能直接被计算机执行，因为计算机只能识别二进制指令，也就是0和1。</p>
<h3 id="编译（生成目标文件）"><a href="#编译（生成目标文件）" class="headerlink" title="编译（生成目标文件）"></a>编译（生成目标文件）</h3><p>把C的源文件（代码）翻译成计算机可以识别的二进制形式的目标文件，这个过程称为编译，由C的编译器完成。</p>
<p>在编译的同时，还对源程序的语法等进行检查。若出现语法错误，则编译失败。如果编译成功则生成目标文件，目标文件名跟源程序文件名一样，扩展名为<code>.obj</code>。比如，mj.c编译后生成目标文件mj.obj。</p>
<p>每个源文件是单独进行编译的，假如一个项目中有多个.c源文件，编译成功会生成多个对应的<code>.obj</code>目标。一般情况下，目标文件之间是有关联的，比如a.obj可能会调用b.obj中定义的一个函数，因此它们都不能够单独被计算机执行，而且<code>目标文件中并不包含程序运行所需要的库函数</code>等。</p>
<blockquote>
<p><strong>说明</strong>：在编译之前会进行预处理（例如<code>#include</code>指令）。</p>
<p><strong>注意</strong>：编译器不会编译<code>.h</code>文件，因为在编译前会进行预处理，预处理会把<code>.h</code>文件的代码拷贝到<code>.c</code>文件中，从而一起编译。</p>
</blockquote>
<h3 id="链接（生成可执行文件）"><a href="#链接（生成可执行文件）" class="headerlink" title="链接（生成可执行文件）"></a>链接（生成可执行文件）</h3><p>将所有有关联的<code>obj</code>目标文件，以及系统提供的C库函数等组合在一起生成一个可执行文件的过程，称为”链接”。链接生成的可执行文件的文件名跟源程序文件同名，扩展名为<code>.exe</code>，计算机可以直接执行。</p>
<h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>如果是在Windows环境下，直接双击<code>.exe</code>文件即可运行C语言程序。</p>
<p>由于我们的第一个C程序，是在Mac OS X系统环境下用Xcode创建的命令行项目，Mac OS X系统是基于UNIX系统的，因此生成的可执行文件的这样的:</p>
<p><img src="http://images2015.cnblogs.com/blog/776348/201606/776348-20160607114929699-1395943059.png" alt=""></p>
<p>双击可以用终端打开：</p>
<p><img src="http://images2015.cnblogs.com/blog/776348/201606/776348-20160607114935215-625977268.png" alt=""></p>
<h2 id="多文件开发"><a href="#多文件开发" class="headerlink" title="多文件开发"></a>多文件开发</h2><p>在大型项目开发中程序中所有的代码都写到一个文件中是不现实的，我们通常将一个子操作分为两个文件：<code>.c</code>文件和<code>.h</code>文件。在<code>.c</code>文件中实现对应的函数，在<code>.h</code>中进行函数声明。</p>
<p>&lt; 代码示例 &gt;</p>
<p><em>main.c</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"message.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    showMessage();</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main.c</span><br></pre></td></tr></table></figure>
<p><em>message.h</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showMessage</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p><em>message.c</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"message.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showMessage</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello, World!\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt; 输出结果 &gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello, World!</span><br><span class="line">Program ended with <span class="built_in">exit</span> code: <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>&lt; 代码分析 &gt;</p>
<ul>
<li>可以发现程序仍然可以正常运行。</li>
<li>但是我们思考一个问题，如果我们不分成两个文件，直接在主函数文件中包含message.c是否也可以正常运行呢？答案是否定的，原因是由于编译生成的两个文件main.obj和message.obj在链接时会发现main.obj中已经有message.obj中定义的showMessage函数，抛出“标示符重复”的错误：<br><img src="http://images2015.cnblogs.com/blog/776348/201606/776348-20160607114940746-1062903242.png" alt=""></li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.cnblogs.com/mjios/" target="_blank" rel="external">M了个J的博客</a></p>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[【00】C语言简介]]></title>
      <url>http://sanfordy.com/2016/05/11/%E3%80%96A%E3%80%97%E3%80%901-0%E3%80%91C-%E8%AF%AD%E6%B3%95/%E3%80%9000%E3%80%91C%E8%AF%AD%E8%A8%80%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[<blockquote>
<p>C语言于1972年发明，首次使用是用于重写<code>UNIX</code>操作系统（<code>UNIX</code>以前是用汇编写的）。随着<code>UNIX</code>操作系统的成功，C语言也得到了大幅度地推广，至今还是世界上最流行、使用最广泛的高级程序设计语言之一。</p>
</blockquote>
<a id="more"></a>
<h2 id="计算机常识"><a href="#计算机常识" class="headerlink" title="计算机常识"></a>计算机常识</h2><p>在学习C语言之前，先要了解一些计算机常识。</p>
<h3 id="计算机只能识别0和1"><a href="#计算机只能识别0和1" class="headerlink" title="计算机只能识别0和1"></a>计算机只能识别0和1</h3><p>大家都知道，计算机要通电才能工作，说白了，它跟电视、洗衣机一样，都是电器。电器都有个共同的能力：懂得判断通电还是断电，通电就能工作，断电就停止工作。因此，从根本上讲，计算机只能识别电信号：高电平信号（通电）、低电平信号（断电），它只知道某个开关是通电还是断电。我们用1代表高电平，0代表低电平。也就说，<code>计算机只能识别0和1。</code></p>
<h3 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h3><p>因为计算机只能识别0和1，因此计算机所能识别的指令和数据都是用二进制数（0和1）来表示的。所谓二进制，就是用0和1来表示所有的数。不过我们日常生活中最常用的是十进制，用0~9来表示所有的数。</p>
<h4 id="二进制指令"><a href="#二进制指令" class="headerlink" title="二进制指令"></a>二进制指令</h4><p>给计算机灌输一些指令，它就能执行相应的操作，而计算机只能识别由0和1组成的指令。在计算机发展初期，计算机的指令长度为16，即以16个二进制数（0或1）组成一条指令，例如，用1011011000000000这条指令，是让计算机进行一次加法运算。因此，如果要想计算机执行一系列的操作，就必须编写许多条由0和1组成的指令，可以想象的到，这个工作量是如此巨大。</p>
<h4 id="二进制数据"><a href="#二进制数据" class="headerlink" title="二进制数据"></a>二进制数据</h4><p>平时我们在计算机中存储的一些数据，比如文档、照片、视频等，都是以0和1的形式存储的。只不过计算机解析了这一大堆的0和1，以图形界面的形式将数据展示在我们眼前。</p>
<h2 id="程序设计语言的发展史"><a href="#程序设计语言的发展史" class="headerlink" title="程序设计语言的发展史"></a>程序设计语言的发展史</h2><p>我们可以利用程序设计语言来编写程序，再将编好的程序运行到计算机上，计算机就能够按照程序中所说的去做。从计算机诞生至今，程序设计语言大致经历了3个发展阶段：<code>机器语言</code>、<code>汇编语言</code>、<code>高级语言</code>。其中， C语言属于高级语言。</p>
<h3 id="机器语言"><a href="#机器语言" class="headerlink" title="机器语言"></a>机器语言</h3><h4 id="什么是机器语言"><a href="#什么是机器语言" class="headerlink" title="什么是机器语言"></a>什么是机器语言</h4><p>在计算器诞生初期， 所有的计算机程序都是直接用计算机能识别的二进制指令来编写的，也就是说所有的代码里面只有0和1。这种程序设计语言就是“机器语言”。这些由0和1组成的二进制指令，又叫做“机器指令”。</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol>
<li>执行效率高：由于机器语言编写出来的代码是能被计算机直接识别的，因此机器语言是直接对硬件产生作用的，程序的执行效率非常高。</li>
<li>可操作硬件：机器语言能直接访问、控制计算机的各种硬件设备，如磁盘、存储器、CPU、I/O端口等。</li>
</ol>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol>
<li>难记：用机器语言编写程序，编程人员要首先熟记所用计算机的全部指令和指令的涵义，指令又多又难记。</li>
<li>可读性差：编出的程序全是些0和1的指令代码，可读性差，还容易出错。</li>
<li>可移植性差：由于机器语言是直接对硬件产生作用的，对硬件的依赖性很强，因此不同型号计算机的机器语言又不一样。也就是说，如果2台不同型号的机器想实现一样的功能，需要编写2套完全不同的代码。</li>
</ol>
<blockquote>
<p><strong>说明</strong>：机器语言很难掌握和推广，现在除了计算机生产厂家的专业人员外，绝大多数的程序员已经不再去学习机器语言了。</p>
</blockquote>
<h3 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a>汇编语言</h3><h4 id="什么是汇编语言"><a href="#什么是汇编语言" class="headerlink" title="什么是汇编语言"></a>什么是汇编语言</h4><p>由于机器语言的种种弊端，严重影响开发效率，后面就出现了汇编语言。汇编语言其实就是符号化的机器语言，它用一个符号（英文单词、数字）来代表一条机器指令。比如，在机器语言中，用1011011000000000这条指令，是让计算机进行一次加法运算；而在汇编语言中，用英文单词 “ADD”就可以表示加法运算。一个有意义的英文单词，很明显比一串又臭又长的二进制指令，直观好记多了。</p>
<p>由于计算机只能识别0和1，用汇编语言编写的代码是不能被计算机所识别的，像刚才的”ADD”，计算机肯定不知道是什么意思。因此，用汇编语言编写的代码需要翻译成二进制指令后，才能被计算机识别。这个翻译的工作交给编译器去做。</p>
<h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ol>
<li>可读性较好：对比机器语言，汇编语言的代码可读性好。</li>
<li>可操作硬件：汇编语言能像机器语言一样，可以直接访问、控制计算机的各种硬件设备，如磁盘、存储器、CPU、I/O端口等。使用汇编语言，可以访问所有能够被访问的软、硬件资源。</li>
<li>目标代码简短：目标代码就是经编译器翻译过后的二进制代码，占用内存少，执行速度快。（计算机中所有程序的运行都是在内存中进行的，因此内存的性能对计算机的影响非常大。其作用是用于暂时存放CPU中的运算数据，以及与硬盘等外部存储器交换的数据。只要计算机在运行中， CPU就会把需要运算的数据调到内存中进行运算，当运算完成后内存再将结果传送出来，内存的运行也决定了计算机的稳定运行。）计算机的内存是有限的，因此一个应用程序运行时所占用的内存越少越好。</li>
</ol>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ol>
<li>可移植性差：汇编语言是面向机器的，通常是为特定的计算机或系列计算机专门设计的。因此，不同的机器有不同的汇编语言语法和编译器，代码缺乏可移植性，也就是说，一个程序只能在一种机器上运行，换到其他机器上就不能运行。</li>
<li>难记：汇编语言的符号非常多、难记，即使是完成简单的功能也需要大量的汇编语言代码，很容易产生BUG，难于调试。</li>
<li>开发效率低：使用汇编语言必须对硬件非常了解，开发效率很低，周期长且单调。</li>
</ol>
<h3 id="高级语言"><a href="#高级语言" class="headerlink" title="高级语言"></a>高级语言</h3><h4 id="什么是高级语言"><a href="#什么是高级语言" class="headerlink" title="什么是高级语言"></a>什么是高级语言</h4><p>由于汇编语言依赖于硬件，代码可移植性差，符号又多又难记，于是人类就发明了非常接近自然语言的高级语言。后面要学习的C语言就是高级语言。</p>
<h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><ol>
<li>可读性最好：语法和结构类似于普通英文，且远离对硬件的直接操作，使得一般人经过学习之后都可以编程，而不用太熟悉硬件知识。</li>
<li>代码简洁：比如要计算2个数的和，在高级语言中可以写得非常简洁：d=a+b。但是在机器语言和汇编语言中，就需要几条甚至几十条指令，而且不同机器还要编写不同的指令代码。</li>
<li>可移植性好：用高级语言编写的同一个程序还可以在不同的机器上运行，具有可移植性。</li>
</ol>
<blockquote>
<p><strong>注意</strong>：用高级语言编写的程序不能直接被计算机识别，需要经编译器翻译成二进制指令后，才能运行到计算机上。</p>
</blockquote>
<h2 id="C语言简史"><a href="#C语言简史" class="headerlink" title="C语言简史"></a>C语言简史</h2><p>C语言于1972年发明，首次使用是用于重写<code>UNIX</code>操作系统（<code>UNIX</code>以前是用汇编写的）。随着<code>UNIX</code>操作系统的成功，C语言也得到了大幅度地推广，至今还是世界上最流行、使用最广泛的高级程序设计语言之一。</p>
<blockquote>
<p><strong>注意</strong>：C语言是一门面向过程的语言，非面向对象的语言。</p>
</blockquote>
<h2 id="C语言的优点"><a href="#C语言的优点" class="headerlink" title="C语言的优点"></a>C语言的优点</h2><h3 id="丰富的运算符"><a href="#丰富的运算符" class="headerlink" title="丰富的运算符"></a>丰富的运算符</h3><p>计算机的基本功能就是计算，因此一门程序设计语言的计算能力是非常重要的。C语言提供了34种运算符，计算类型及其丰富，其中包括了最基本的加减乘除运算。</p>
<h3 id="丰富的数据类型"><a href="#丰富的数据类型" class="headerlink" title="丰富的数据类型"></a>丰富的数据类型</h3><p>C语言之所以生命力如何强大，很大一部分是因为它拥有丰富的数据类型。C语言的数据类型有：整型（int）、实型（float）、字符型（char）、数组类型（int []）、指针类型（void *）、结构体类型（struct）、共用体类型（union）等。众多数据类型中，最强大的是指针，通过指针我们可以直接访问内存地址。指针使用得当的话，不仅可以节省代码量，还可以优化内存管理、提高性能。因此，指针是一个非常重要的概念，必须重视。如果你说 C语言中除了指针，其他都学得挺好的，那你干脆说你没学过C语言。正因为C语言数据类型丰富，运算能力极强，因此很多数据库都是用C语言编写的，比如<code>DB2</code>、<code>Oracle</code>等。</p>
<h3 id="允许直接访问物理地址，对硬件进行操作"><a href="#允许直接访问物理地址，对硬件进行操作" class="headerlink" title="允许直接访问物理地址，对硬件进行操作"></a>允许直接访问物理地址，对硬件进行操作</h3><p>由于C语言允许直接访问物理地址，可以直接对硬件进行操作，因此它既具有高级语言的功能，又具有低级语言的许多功能，能够像汇编语言一样对位（bit）、字节和地址进行操作，而这三者是计算机最基本的工作单元。</p>
<h3 id="高效率的目标代码"><a href="#高效率的目标代码" class="headerlink" title="高效率的目标代码"></a>高效率的目标代码</h3><p>对比汇编语言，C语言可读性好，易于调试、修改和移植，代码质量与汇编语言相当。</p>
<h3 id="可移植性好"><a href="#可移植性好" class="headerlink" title="可移植性好"></a>可移植性好</h3><p>在一个环境上用C语言编写的程序，不改动或稍加改动，就可移植到另一个完全不同的环境中运行。</p>
<h2 id="C语言的缺点"><a href="#C语言的缺点" class="headerlink" title="C语言的缺点"></a>C语言的缺点</h2><h3 id="封装性差、安全性低"><a href="#封装性差、安全性低" class="headerlink" title="封装性差、安全性低"></a>封装性差、安全性低</h3><p>由于C语言是面向过程的，因此它的数据封装性差、安全性低，这就是C语言和其他面向对象语言的区别之一。面向对象语言的特性之一就是数据的封装性。</p>
<h3 id="语法限制不严格"><a href="#语法限制不严格" class="headerlink" title="语法限制不严格"></a>语法限制不严格</h3><p>对变量的类型约束不严格，对数组下标越界不作检查等。</p>
<h2 id="C语言能做什么"><a href="#C语言能做什么" class="headerlink" title="C语言能做什么"></a>C语言能做什么</h2><h3 id="开发计算机软件"><a href="#开发计算机软件" class="headerlink" title="开发计算机软件"></a>开发计算机软件</h3><p>由于C语言具有强大的数据处理能力，而且允许直接访问物理地址，直接对硬件操作，因此它适于编写系统软件、图形处理、单片机程序、嵌入式系统开发甚至是用于科研。</p>
<h3 id="开发Android"><a href="#开发Android" class="headerlink" title="开发Android"></a>开发Android</h3><p>很多操作系统的底层都是用C语言写的，比如 android 。</p>
<h3 id="开发iOS"><a href="#开发iOS" class="headerlink" title="开发iOS"></a>开发iOS</h3><p>iOS开发中的核心语言是Objective-C（简称OC），OC是在C语言的基础上加了一层面向对象语法。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.cnblogs.com/mjios/" target="_blank" rel="external">M了个J的博客</a></p>
<hr>
]]></content>
    </entry>
    
  
  
</search>
